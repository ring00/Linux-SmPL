diff --git a/sculld/Makefile b/sculld/Makefile
index 41a7f9b93bf7..554954e0d621 100644
--- a/sculld/Makefile
+++ b/sculld/Makefile
@@ -35,7 +35,7 @@ install:
 	install -c $(TARGET).o $(INSTALLDIR)
 
 clean:
-	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions
+	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions Module.symvers modules.order
 
 
 depend .depend dep:
diff --git a/sculld/main.c b/sculld/main.c
index f5e28a60fa7a..139bde9e6f2b 100644
--- a/sculld/main.c
+++ b/sculld/main.c
@@ -26,6 +26,7 @@
 #include <linux/proc_fs.h>
 #include <linux/fcntl.h>	/* O_ACCMODE */
 #include <linux/aio.h>
+#include <linux/seq_file.h>
 #include <asm/uaccess.h>
 #include "sculld.h"		/* local definitions */
 
@@ -66,61 +67,54 @@ static struct ldd_driver sculld_driver = {
  * The proc filesystem: function to read and entry
  */
 
-void sculld_proc_offset(char *buf, char **start, off_t *offset, int *len)
+static int sculld_read_mem_proc_show(struct seq_file *m, void *v)
 {
-	if (*offset == 0)
-		return;
-	if (*offset >= *len) {
-		/* Not there yet */
-		*offset -= *len;
-		*len = 0;
-	} else {
-		/* We're into the interesting stuff now */
-		*start = buf + *offset;
-		*offset = 0;
-	}
-}
-
-/* FIXME: Do we need this here??  It be ugly  */
-int sculld_read_procmem(char *buf, char **start, off_t offset,
-                   int count, int *eof, void *data)
-{
-	int i, j, order, qset, len = 0;
-	int limit = count - 80; /* Don't print more than this */
+	int i, j, order, qset;
+	int limit = m->size - 80; /* Don't print more than this */
 	struct sculld_dev *d;
 
-	*start = buf;
 	for(i = 0; i < sculld_devs; i++) {
 		d = &sculld_devices[i];
 		if (mutex_lock_interruptible(&d->mutex))
 			return -ERESTARTSYS;
 		qset = d->qset;  /* retrieve the features of each device */
 		order = d->order;
-		len += sprintf(buf+len,"\nDevice %i: qset %i, order %i, sz %li\n",
+		seq_printf(m, "\nDevice %i: qset %i, order %i, sz %li\n",
 				i, qset, order, (long)(d->size));
 		for (; d; d = d->next) { /* scan the list */
-			len += sprintf(buf+len,"  item at %p, qset at %p\n",d,d->data);
-			sculld_proc_offset (buf, start, &offset, &len);
-			if (len > limit)
+			seq_printf(m, "  item at %p, qset at %p\n",d,d->data);
+			if (m->count > limit)
 				goto out;
 			if (d->data && !d->next) /* dump only the last item - save space */
 				for (j = 0; j < qset; j++) {
 					if (d->data[j])
-						len += sprintf(buf+len,"    % 4i:%8p\n",j,d->data[j]);
-					sculld_proc_offset (buf, start, &offset, &len);
-					if (len > limit)
+						seq_printf(m, "    % 4i:%8p\n",j,d->data[j]);
+					if (m->count > limit)
 						goto out;
 				}
 		}
 	  out:
 		mutex_unlock(&sculld_devices[i].mutex);
-		if (len > limit)
+		if (m->count > limit)
 			break;
 	}
-	*eof = 1;
-	return len;
+	return 0;
 }
 
+#define DEFINE_PROC_SEQ_FILE(_name) \
+	static int _name##_proc_open(struct inode *inode, struct file *file)\
+	{\
+		return single_open(file, _name##_proc_show, NULL);\
+	}\
+	\
+	static const struct file_operations _name##_proc_fops = {\
+		.open		= _name##_proc_open,\
+		.read		= seq_read,\
+		.llseek		= seq_lseek,\
+		.release	= single_release,\
+	};
+
+DEFINE_PROC_SEQ_FILE(sculld_read_mem)
 #endif /* SCULLD_USE_PROC */
 
 /*
@@ -665,7 +659,7 @@ int sculld_init(void)
 
 
 #ifdef SCULLD_USE_PROC /* only when available */
-	create_proc_read_entry("sculldmem", 0, NULL, sculld_read_procmem, NULL);
+	proc_create("sculldmem", 0, NULL, &sculld_read_mem_proc_fops);
 #endif
 	return 0; /* succeed */
 
diff --git a/sculld/mmap.c b/sculld/mmap.c
index 08f156fd4f3d..d87e46d18859 100644
--- a/sculld/mmap.c
+++ b/sculld/mmap.c
@@ -112,7 +112,7 @@ int sculld_mmap(struct file *filp, struct vm_area_struct *vma)
 
 	/* don't do anything here: "nopage" will set up page table entries */
 	vma->vm_ops = &sculld_vm_ops;
-	vma->vm_flags |= VM_RESERVED;
+	vma->vm_flags |= (VM_DONTEXPAND | VM_DONTDUMP);
 	vma->vm_private_data = filp->private_data;
 	sculld_vma_open(vma);
 	return 0;
