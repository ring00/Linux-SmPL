diff --git a/tty/Makefile b/tty/Makefile
index 9a6eac295d8b..ed433ada6356 100644
--- a/tty/Makefile
+++ b/tty/Makefile
@@ -30,7 +30,7 @@ endif
 
 
 clean:
-	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions
+	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions Module.symvers modules.order
 
 depend .depend dep:
 	$(CC) $(EXTRA_CFLAGS) -M *.c > .depend
diff --git a/tty/tiny_serial.c b/tty/tiny_serial.c
index 82200d2c4c96..b7d27cb3f4c4 100644
--- a/tty/tiny_serial.c
+++ b/tty/tiny_serial.c
@@ -95,7 +95,7 @@ static void tiny_start_tx(struct uart_port *port)
 static void tiny_timer(unsigned long data)
 {
 	struct uart_port *port;
-	struct tty_struct *tty;
+	struct tty_port *tport;
 
 
 	port = (struct uart_port *)data;
@@ -103,15 +103,13 @@ static void tiny_timer(unsigned long data)
 		return;
 	if (!port->state)
 		return;
-	tty = port->state->port.tty;
-	if (!tty)
-		return;
+	tport = &port->state->port;
 
 	/* add one character to the tty port */
 	/* this doesn't actually push the data through unless tty->low_latency is set */
-	tty_insert_flip_char(tty, TINY_DATA_CHARACTER, 0);
+	tty_insert_flip_char(tport, TINY_DATA_CHARACTER, 0);
 
-	tty_flip_buffer_push(tty);
+	tty_flip_buffer_push(tport);
 
 	/* resubmit the timer again */
 	timer->expires = jiffies + DELAY_TIME;
diff --git a/tty/tiny_tty.c b/tty/tiny_tty.c
index 0379b01e1a43..0c5b86cbb287 100644
--- a/tty/tiny_tty.c
+++ b/tty/tiny_tty.c
@@ -43,9 +43,8 @@ MODULE_LICENSE("GPL");
 #define TINY_TTY_MINORS		4	/* only have 4 devices */
 
 struct tiny_serial {
-	struct tty_struct	*tty;		/* pointer to the tty for this device */
-	int			open_count;	/* number of times this port has been opened */
-	struct mutex	mutex;		/* locks this structure */
+	struct tty_port	port;		/* pointer to the tty for this device */
+	struct mutex	port_write_mutex;
 	struct timer_list	*timer;
 
 	/* for tiocmget and tiocmset functions */
@@ -64,7 +63,7 @@ static struct tiny_serial *tiny_table[TINY_TTY_MINORS];	/* initially all NULL */
 static void tiny_timer(unsigned long timer_data)
 {
 	struct tiny_serial *tiny = (struct tiny_serial *)timer_data;
-	struct tty_struct *tty;
+	struct tty_port *port;
 	int i;
 	char data[1] = {TINY_DATA_CHARACTER};
 	int data_size = 1;
@@ -72,104 +71,99 @@ static void tiny_timer(unsigned long timer_data)
 	if (!tiny)
 		return;
 
-	tty = tiny->tty;
+	port = &tiny->port;
 
 	/* send the data to the tty layer for users to read.  This doesn't
 	 * actually push the data through unless tty->low_latency is set */
-	tty_buffer_request_room(tty, data_size);
+	/* FIXME: when data_size increase,
+	 * we need to call tty_flip_buffer_push during tty_insert_flip_char */
+	tty_buffer_request_room(port, data_size);
 	for (i = 0; i < data_size; ++i) {
-		tty_insert_flip_char(tty, data[i], TTY_NORMAL);
+		tty_insert_flip_char(port, data[i], TTY_NORMAL);
 	}
-	tty_flip_buffer_push(tty);
+	tty_flip_buffer_push(port);
 
 	/* resubmit the timer again */
 	tiny->timer->expires = jiffies + DELAY_TIME;
 	add_timer(tiny->timer);
 }
 
-static int tiny_open(struct tty_struct *tty, struct file *file)
+/*
+ * this is the first time this port is opened
+ * do any hardware initialization needed here
+ */
+static int tiny_activate(struct tty_port *tport, struct tty_struct *tty)
 {
 	struct tiny_serial *tiny;
 	struct timer_list *timer;
-	int index;
 
-	/* initialize the pointer in case something fails */
-	tty->driver_data = NULL;
+	tiny = container_of(tport, struct tiny_serial, port);
 
-	/* get the serial object associated with this tty pointer */
-	index = tty->index;
-	tiny = tiny_table[index];
-	if (tiny == NULL) {
-		/* first time accessing this device, let's create it */
-		tiny = kmalloc(sizeof(*tiny), GFP_KERNEL);
-		if (!tiny)
+	/* create our timer and submit it */
+	if (!tiny->timer) {
+		timer = kmalloc(sizeof(*timer), GFP_KERNEL);
+		if (!timer) {
 			return -ENOMEM;
-
-		mutex_init(&tiny->mutex);
-		tiny->open_count = 0;
-		tiny->timer = NULL;
-
-		tiny_table[index] = tiny;
+		}
+		init_timer(timer);
+		tiny->timer = timer;
 	}
+	tiny->timer->data = (unsigned long )tiny;
+	tiny->timer->expires = jiffies + DELAY_TIME;
+	tiny->timer->function = tiny_timer;
+	add_timer(tiny->timer);
+	return 0;
+}
 
-	mutex_lock(&tiny->mutex);
-
-	/* save our structure within the tty structure */
-	tty->driver_data = tiny;
-	tiny->tty = tty;
-
-	++tiny->open_count;
-	if (tiny->open_count == 1) {
-		/* this is the first time this port is opened */
-		/* do any hardware initialization needed here */
+/*
+ * The port is being closed by the last user.
+ * Do any hardware specific stuff here *
+ */
+static void tiny_shutdown(struct tty_port *tport){
+	struct tiny_serial *tiny;
 
-		/* create our timer and submit it */
-		if (!tiny->timer) {
-			timer = kmalloc(sizeof(*timer), GFP_KERNEL);
-			if (!timer) {
-				mutex_unlock(&tiny->mutex);
-				return -ENOMEM;
-			}
-			init_timer(timer);
-			tiny->timer = timer;
-		}
-		tiny->timer->data = (unsigned long )tiny;
-		tiny->timer->expires = jiffies + DELAY_TIME;
-		tiny->timer->function = tiny_timer;
-		add_timer(tiny->timer);
-	}
+	tiny = container_of(tport, struct tiny_serial, port);
 
-	mutex_unlock(&tiny->mutex);
-	return 0;
+	/* shut down our timer */
+	del_timer(tiny->timer);
 }
 
-static void do_close(struct tiny_serial *tiny)
+static int tiny_open(struct tty_struct *tty, struct file *file)
 {
-	mutex_lock(&tiny->mutex);
+	struct tiny_serial *tiny;
+	int index;
+	struct tty_port *port;
+	int status;
 
-	if (!tiny->open_count) {
-		/* port was never opened */
-		goto exit;
-	}
+	/* initialize the pointer in case something fails */
+	tty->driver_data = NULL;
+
+	/* get the serial object associated with this tty pointer */
+	index = tty->index;
+	tiny = tiny_table[index];
+
+	port = &tiny->port;
 
-	--tiny->open_count;
-	if (tiny->open_count <= 0) {
-		/* The port is being closed by the last user. */
-		/* Do any hardware specific stuff here */
+	status = tty_port_open(port, tty, file);
 
-		/* shut down our timer */
-		del_timer(tiny->timer);
+	if(!status) {
+		/* save our structure within the tty structure */
+		tty->driver_data = tiny;
 	}
-exit:
-	mutex_unlock(&tiny->mutex);
+
+	return status;
 }
 
+
 static void tiny_close(struct tty_struct *tty, struct file *file)
 {
 	struct tiny_serial *tiny = tty->driver_data;
+	struct tty_port *port;
+
+	port = &tiny->port;
 
 	if (tiny)
-		do_close(tiny);
+		tty_port_close(port, tty, file);
 }	
 
 static int tiny_write(struct tty_struct *tty, 
@@ -177,16 +171,24 @@ static int tiny_write(struct tty_struct *tty,
 {
 	struct tiny_serial *tiny = tty->driver_data;
 	int i;
-	int retval = -EINVAL;
+	int retval;
+	struct tty_port *port;
+	unsigned long flags;
 
 	if (!tiny)
 		return -ENODEV;
 
-	mutex_lock(&tiny->mutex);
+	mutex_lock(&tiny->port_write_mutex);
 
-	if (!tiny->open_count)
+	port = &tiny->port;
+	spin_lock_irqsave(&port->lock, flags);
+	if (!port->count) {
+		spin_unlock_irqrestore(&port->lock, flags);
 		/* port was not opened */
+		retval = -EINVAL;
 		goto exit;
+	}
+	spin_unlock_irqrestore(&port->lock, flags);
 
 	/* fake sending the data out a hardware port by
 	 * writing it to the kernel debug log.
@@ -195,9 +197,10 @@ static int tiny_write(struct tty_struct *tty,
 	for (i = 0; i < count; ++i)
 		printk("%02x ", buffer[i]);
 	printk("\n");
+	retval = count;
 		
 exit:
-	mutex_unlock(&tiny->mutex);
+	mutex_unlock(&tiny->port_write_mutex);
 	return retval;
 }
 
@@ -205,22 +208,28 @@ static int tiny_write_room(struct tty_struct *tty)
 {
 	struct tiny_serial *tiny = tty->driver_data;
 	int room = -EINVAL;
+	struct tty_port *port;
+	unsigned long flags;
 
 	if (!tiny)
 		return -ENODEV;
 
-	mutex_lock(&tiny->mutex);
+	mutex_lock(&tiny->port_write_mutex);
 	
-	if (!tiny->open_count) {
+	port = &tiny->port;
+	spin_lock_irqsave(&port->lock, flags);
+	if (!port->count) {
+		spin_unlock_irqrestore(&port->lock, flags);
 		/* port was not opened */
 		goto exit;
 	}
+	spin_unlock_irqrestore(&port->lock, flags);
 
 	/* calculate how much room is left in the device */
 	room = 255;
 
 exit:
-	mutex_unlock(&tiny->mutex);
+	mutex_unlock(&tiny->port_write_mutex);
 	return room;
 }
 
@@ -230,12 +239,12 @@ static void tiny_set_termios(struct tty_struct *tty, struct ktermios *old_termio
 {
 	unsigned int cflag;
 
-	cflag = tty->termios->c_cflag;
+	cflag = tty->termios.c_cflag;
 
 	/* check that they really want us to change something */
 	if (old_termios) {
 		if ((cflag == old_termios->c_cflag) &&
-		    (RELEVANT_IFLAG(tty->termios->c_iflag) == 
+		    (RELEVANT_IFLAG(tty->termios.c_iflag) ==
 		     RELEVANT_IFLAG(old_termios->c_iflag))) {
 			printk(KERN_DEBUG " - nothing to change...\n");
 			return;
@@ -516,12 +525,18 @@ static struct tty_operations serial_ops = {
 	.proc_fops       = &tiny_tty_proc_fops,
 };
 
+static const struct tty_port_operations tiny_port_ops = {
+	.activate		= tiny_activate,
+	.shutdown		= tiny_shutdown,
+};
+
 static struct tty_driver *tiny_tty_driver;
 
 static int __init tiny_init(void)
 {
 	int retval;
 	int i;
+	struct tiny_serial *tiny;
 
 	/* allocate the tty driver */
 	tiny_tty_driver = alloc_tty_driver(TINY_TTY_MINORS);
@@ -544,14 +559,45 @@ static int __init tiny_init(void)
 	retval = tty_register_driver(tiny_tty_driver);
 	if (retval) {
 		printk(KERN_ERR "failed to register tiny tty driver");
-		put_tty_driver(tiny_tty_driver);
-		return retval;
+		goto err_tty_register_driver;
 	}
 
-	for (i = 0; i < TINY_TTY_MINORS; ++i)
-		tty_register_device(tiny_tty_driver, i, NULL);
+	for (i = 0; i < TINY_TTY_MINORS; ++i) {
+		/* let's create it */
+		tiny = kmalloc(sizeof(*tiny), GFP_KERNEL);
+		if (!tiny) {
+			retval = -ENOMEM;
+			printk(KERN_ERR "failed to alloc tiny_serial");
+			goto err_kmalloc_tiny;
+		}
+
+		mutex_init(&tiny->port_write_mutex);
+		tiny->timer = NULL;
+
+		tiny_table[i] = tiny;
+		tty_port_init(&tiny->port);
+		tiny->port.ops = &tiny_port_ops;
+	}
+
+	for (i = 0; i < TINY_TTY_MINORS; ++i) {
+		tty_port_register_device(&tiny_table[i]->port, tiny_tty_driver, i, NULL);
+	}
+
+	printk(KERN_INFO DRIVER_DESC " " DRIVER_VERSION "\n");
+	return retval;
+
+err_kmalloc_tiny:
+	for (i = 0; i < TINY_TTY_MINORS; ++i) {
+		tiny = tiny_table[i];
+		if (tiny) {
+			tty_port_destroy(&tiny->port);
+			kfree(tiny);
+		}
+	}
+
+err_tty_register_driver:
+	put_tty_driver(tiny_tty_driver);
 
-	printk(KERN_INFO DRIVER_DESC " " DRIVER_VERSION);
 	return retval;
 }
 
@@ -563,21 +609,25 @@ static void __exit tiny_exit(void)
 	for (i = 0; i < TINY_TTY_MINORS; ++i)
 		tty_unregister_device(tiny_tty_driver, i);
 	tty_unregister_driver(tiny_tty_driver);
+	put_tty_driver(tiny_tty_driver);
 
 	/* shut down all of the timers and free the memory */
 	for (i = 0; i < TINY_TTY_MINORS; ++i) {
 		tiny = tiny_table[i];
-		if (tiny) {
-			/* close the port */
-			while (tiny->open_count)
-				do_close(tiny);
-
-			/* shut down our timer and free the memory */
+		/* close the port */
+		/* FIXME: how to close the port ???
+		 * using tty_hangup ??? */
+		if(tiny->port.count)
+			tiny_shutdown(&tiny->port);
+
+		/* shut down our timer and free the memory */
+		if(tiny->timer) {
 			del_timer(tiny->timer);
 			kfree(tiny->timer);
-			kfree(tiny);
-			tiny_table[i] = NULL;
 		}
+		tty_port_destroy(&tiny->port);
+		kfree(tiny);
+		tiny_table[i] = NULL;
 	}
 }
 
