diff --git a/scullp/Makefile b/scullp/Makefile
index f3025707b783..3633518289e8 100644
--- a/scullp/Makefile
+++ b/scullp/Makefile
@@ -35,7 +35,7 @@ install:
 	install -c $(TARGET).o $(INSTALLDIR)
 
 clean:
-	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions
+	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions Module.symvers modules.order
 
 
 depend .depend dep:
diff --git a/scullp/main.c b/scullp/main.c
index 3d99be468a6b..ee2532e054e9 100644
--- a/scullp/main.c
+++ b/scullp/main.c
@@ -26,6 +26,7 @@
 #include <linux/proc_fs.h>
 #include <linux/fcntl.h>	/* O_ACCMODE */
 #include <linux/aio.h>
+#include <linux/seq_file.h>
 #include <asm/uaccess.h>
 #include "scullp.h"		/* local definitions */
 
@@ -57,61 +58,54 @@ void scullp_cleanup(void);
  * The proc filesystem: function to read and entry
  */
 
-void scullp_proc_offset(char *buf, char **start, off_t *offset, int *len)
+static int scullp_read_mem_proc_show(struct seq_file *m, void *v)
 {
-	if (*offset == 0)
-		return;
-	if (*offset >= *len) {
-		/* Not there yet */
-		*offset -= *len;
-		*len = 0;
-	} else {
-		/* We're into the interesting stuff now */
-		*start = buf + *offset;
-		*offset = 0;
-	}
-}
-
-/* FIXME: Do we need this here??  It be ugly  */
-int scullp_read_procmem(char *buf, char **start, off_t offset,
-                   int count, int *eof, void *data)
-{
-	int i, j, order, qset, len = 0;
-	int limit = count - 80; /* Don't print more than this */
+	int i, j, order, qset;
+	int limit = m->size - 80; /* Don't print more than this */
 	struct scullp_dev *d;
 
-	*start = buf;
 	for(i = 0; i < scullp_devs; i++) {
 		d = &scullp_devices[i];
 		if (mutex_lock_interruptible(&d->mutex))
 			return -ERESTARTSYS;
 		qset = d->qset;  /* retrieve the features of each device */
 		order = d->order;
-		len += sprintf(buf+len,"\nDevice %i: qset %i, order %i, sz %li\n",
+		seq_printf(m,"\nDevice %i: qset %i, order %i, sz %li\n",
 				i, qset, order, (long)(d->size));
 		for (; d; d = d->next) { /* scan the list */
-			len += sprintf(buf+len,"  item at %p, qset at %p\n",d,d->data);
-			scullp_proc_offset (buf, start, &offset, &len);
-			if (len > limit)
+			seq_printf(m,"  item at %p, qset at %p\n",d,d->data);
+			if (m->count > limit)
 				goto out;
 			if (d->data && !d->next) /* dump only the last item - save space */
 				for (j = 0; j < qset; j++) {
 					if (d->data[j])
-						len += sprintf(buf+len,"    % 4i:%8p\n",j,d->data[j]);
-					scullp_proc_offset (buf, start, &offset, &len);
-					if (len > limit)
+						seq_printf(m,"    % 4i:%8p\n",j,d->data[j]);
+					if (m->count > limit)
 						goto out;
 				}
 		}
 	  out:
 		mutex_unlock(&scullp_devices[i].mutex);
-		if (len > limit)
+		if (m->count > limit)
 			break;
 	}
-	*eof = 1;
-	return len;
+	return 0;
 }
 
+#define DEFINE_PROC_SEQ_FILE(_name) \
+	static int _name##_proc_open(struct inode *inode, struct file *file)\
+	{\
+		return single_open(file, _name##_proc_show, NULL);\
+	}\
+	\
+	static const struct file_operations _name##_proc_fops = {\
+		.open		= _name##_proc_open,\
+		.read		= seq_read,\
+		.llseek		= seq_lseek,\
+		.release	= single_release,\
+	};
+
+DEFINE_PROC_SEQ_FILE(scullp_read_mem)
 #endif /* SCULLP_USE_PROC */
 
 /*
@@ -632,7 +626,7 @@ int scullp_init(void)
 
 
 #ifdef SCULLP_USE_PROC /* only when available */
-	create_proc_read_entry("scullpmem", 0, NULL, scullp_read_procmem, NULL);
+	proc_create("scullpmem", 0, NULL, &scullp_read_mem_proc_fops);
 #endif
 	return 0; /* succeed */
 
diff --git a/scullp/mmap.c b/scullp/mmap.c
index 23efef5b40a7..c241ab46d68d 100644
--- a/scullp/mmap.c
+++ b/scullp/mmap.c
@@ -112,7 +112,7 @@ int scullp_mmap(struct file *filp, struct vm_area_struct *vma)
 
 	/* don't do anything here: "nopage" will set up page table entries */
 	vma->vm_ops = &scullp_vm_ops;
-	vma->vm_flags |= VM_RESERVED;
+	vma->vm_flags |= (VM_DONTEXPAND | VM_DONTDUMP);
 	vma->vm_private_data = filp->private_data;
 	scullp_vma_open(vma);
 	return 0;
