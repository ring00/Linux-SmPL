diff --git a/scull/Makefile b/scull/Makefile
index 3c92537ce138..aeb702b8a958 100644
--- a/scull/Makefile
+++ b/scull/Makefile
@@ -32,7 +32,7 @@ endif
 
 
 clean:
-	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions
+	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions Module.symvers modules.order
 
 depend .depend dep:
 	$(CC) $(EXTRA_CFLAGS) -M *.c > .depend
diff --git a/scull/main.c b/scull/main.c
index 8a9bfcb5cc3e..9ced1c37d6cd 100644
--- a/scull/main.c
+++ b/scull/main.c
@@ -85,34 +85,32 @@ int scull_trim(struct scull_dev *dev)
  * The proc filesystem: function to read and entry
  */
 
-int scull_read_procmem(char *buf, char **start, off_t offset,
-                   int count, int *eof, void *data)
+static int scull_read_mem_proc_show(struct seq_file *m, void *v)
 {
-	int i, j, len = 0;
-	int limit = count - 80; /* Don't print more than this */
+	int i, j;
+	int limit = m->size - 80; /* Don't print more than this */
 
-	for (i = 0; i < scull_nr_devs && len <= limit; i++) {
+	for (i = 0; i < scull_nr_devs && m->count <= limit; i++) {
 		struct scull_dev *d = &scull_devices[i];
 		struct scull_qset *qs = d->data;
 		if (mutex_lock_interruptible(&d->mutex))
 			return -ERESTARTSYS;
-		len += sprintf(buf+len,"\nDevice %i: qset %i, q %i, sz %li\n",
+		seq_printf(m,"\nDevice %i: qset %i, q %i, sz %li\n",
 				i, d->qset, d->quantum, d->size);
-		for (; qs && len <= limit; qs = qs->next) { /* scan the list */
-			len += sprintf(buf + len, "  item at %p, qset at %p\n",
+		for (; qs && m->count <= limit; qs = qs->next) { /* scan the list */
+			seq_printf(m, "  item at %p, qset at %p\n",
 					qs, qs->data);
 			if (qs->data && !qs->next) /* dump only the last item */
 				for (j = 0; j < d->qset; j++) {
 					if (qs->data[j])
-						len += sprintf(buf + len,
+						seq_printf(m,
 								"    % 4i: %8p\n",
 								j, qs->data[j]);
 				}
 		}
 		mutex_unlock(&scull_devices[i].mutex);
 	}
-	*eof = 1;
-	return len;
+	return 0;
 }
 
 
@@ -200,6 +198,21 @@ static struct file_operations scull_proc_ops = {
 };
 	
 
+#define DEFINE_PROC_SEQ_FILE(_name) \
+	static int _name##_proc_open(struct inode *inode, struct file *file)\
+	{\
+		return single_open(file, _name##_proc_show, NULL);\
+	}\
+	\
+	static const struct file_operations _name##_proc_fops = {\
+		.open		= _name##_proc_open,\
+		.read		= seq_read,\
+		.llseek		= seq_lseek,\
+		.release	= single_release,\
+	};
+
+DEFINE_PROC_SEQ_FILE(scull_read_mem)
+
 /*
  * Actually create (and remove) the /proc file(s).
  */
@@ -207,12 +220,12 @@ static struct file_operations scull_proc_ops = {
 static void scull_create_proc(void)
 {
 	struct proc_dir_entry *entry;
-	create_proc_read_entry("scullmem", 0 /* default mode */,
-			NULL /* parent dir */, scull_read_procmem,
-			NULL /* client data */);
-	entry = create_proc_entry("scullseq", 0, NULL);
-	if (entry)
-		entry->proc_fops = &scull_proc_ops;
+	proc_create("scullmem", 0 /* default mode */,
+			NULL /* parent dir */, &scull_read_mem_proc_fops);
+	entry = proc_create("scullseq", 0, NULL, &scull_proc_ops);
+	if (!entry) {
+		printk(KERN_WARNING "proc_create scullseq failed\n");
+    }
 }
 
 static void scull_remove_proc(void)
@@ -222,7 +235,6 @@ static void scull_remove_proc(void)
 	remove_proc_entry("scullseq", NULL);
 }
 
-
 #endif /* SCULL_DEBUG */
 
 
diff --git a/scull/pipe.c b/scull/pipe.c
index c9a487571ec5..01a35b750982 100644
--- a/scull/pipe.c
+++ b/scull/pipe.c
@@ -27,6 +27,7 @@
 #include <linux/fcntl.h>
 #include <linux/poll.h>
 #include <linux/cdev.h>
+#include <linux/seq_file.h>
 #include <asm/uaccess.h>
 
 #include "scull.h"		/* local definitions */
@@ -260,48 +261,42 @@ static int scull_p_fasync(int fd, struct file *filp, int mode)
 
 
 
-/* FIXME this should use seq_file */
 #ifdef SCULL_DEBUG
-static void scullp_proc_offset(char *buf, char **start, off_t *offset, int *len)
+static int scull_read_p_mem_proc_show(struct seq_file *m, void *v)
 {
-	if (*offset == 0)
-		return;
-	if (*offset >= *len) {	/* Not there yet */
-		*offset -= *len;
-		*len = 0;
-	}
-	else {			/* We're into the interesting stuff now */
-		*start = buf + *offset;
-		*offset = 0;
-	}
-}
-
-
-static int scull_read_p_mem(char *buf, char **start, off_t offset, int count,
-		int *eof, void *data)
-{
-	int i, len;
+	int i;
 	struct scull_pipe *p;
 
-#define LIMIT (PAGE_SIZE-200)	/* don't print any more after this size */
-	*start = buf;
-	len = sprintf(buf, "Default buffersize is %i\n", scull_p_buffer);
-	for(i = 0; i<scull_p_nr_devs && len <= LIMIT; i++) {
+#define LIMIT (m->size-200)	/* don't print any more after this size */
+	seq_printf(m, "Default buffersize is %i\n", scull_p_buffer);
+	for(i = 0; i<scull_p_nr_devs && m->count <= LIMIT; i++) {
 		p = &scull_p_devices[i];
 		if (mutex_lock_interruptible(&p->mutex))
 			return -ERESTARTSYS;
-		len += sprintf(buf+len, "\nDevice %i: %p\n", i, p);
-/*		len += sprintf(buf+len, "   Queues: %p %p\n", p->inq, p->outq);*/
-		len += sprintf(buf+len, "   Buffer: %p to %p (%i bytes)\n", p->buffer, p->end, p->buffersize);
-		len += sprintf(buf+len, "   rp %p   wp %p\n", p->rp, p->wp);
-		len += sprintf(buf+len, "   readers %i   writers %i\n", p->nreaders, p->nwriters);
+		seq_printf(m, "\nDevice %i: %p\n", i, p);
+/*		seq_printf(m, "   Queues: %p %p\n", p->inq, p->outq);*/
+		seq_printf(m, "   Buffer: %p to %p (%i bytes)\n", p->buffer, p->end, p->buffersize);
+		seq_printf(m, "   rp %p   wp %p\n", p->rp, p->wp);
+		seq_printf(m, "   readers %i   writers %i\n", p->nreaders, p->nwriters);
 		mutex_unlock(&p->mutex);
-		scullp_proc_offset(buf, start, &offset, &len);
 	}
-	*eof = (len <= LIMIT);
-	return len;
+	return 0;
 }
 
+#define DEFINE_PROC_SEQ_FILE(_name) \
+	static int _name##_proc_open(struct inode *inode, struct file *file)\
+	{\
+		return single_open(file, _name##_proc_show, NULL);\
+	}\
+	\
+	static const struct file_operations _name##_proc_fops = {\
+		.open		= _name##_proc_open,\
+		.read		= seq_read,\
+		.llseek		= seq_lseek,\
+		.release	= single_release,\
+	};
+
+DEFINE_PROC_SEQ_FILE(scull_read_p_mem)
 
 #endif
 
@@ -367,7 +362,7 @@ int scull_p_init(dev_t firstdev)
 		scull_p_setup_cdev(scull_p_devices + i, i);
 	}
 #ifdef SCULL_DEBUG
-	create_proc_read_entry("scullpipe", 0, NULL, scull_read_p_mem, NULL);
+	proc_create("scullpipe", 0, NULL, &scull_read_p_mem_proc_fops);
 #endif
 	return scull_p_nr_devs;
 }
