diff -u -p a/gfs2/super.c b/gfs2/super.c
--- a/gfs2/super.c
+++ b/gfs2/super.c
@@ -1119,7 +1119,7 @@ static int gfs2_statfs_i(struct gfs2_sbd
 
 static int gfs2_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
-	struct super_block *sb = dentry->d_inode->i_sb;
+	struct super_block *sb = d_inode(dentry)->i_sb;
 	struct gfs2_sbd *sdp = sb->s_fs_info;
 	struct gfs2_statfs_change_host sc;
 	int error;
diff -u -p a/gfs2/inode.c b/gfs2/inode.c
--- a/gfs2/inode.c
+++ b/gfs2/inode.c
@@ -294,7 +294,7 @@ struct inode *gfs2_lookupi(struct inode
 
 	if ((name->len == 1 && memcmp(name->name, ".", 1) == 0) ||
 	    (name->len == 2 && memcmp(name->name, "..", 2) == 0 &&
-	     dir == sb->s_root->d_inode)) {
+	     dir == d_inode(sb->s_root))) {
 		igrab(dir);
 		return dir;
 	}
@@ -832,7 +832,7 @@ static int gfs2_link(struct dentry *old_
 {
 	struct gfs2_inode *dip = GFS2_I(dir);
 	struct gfs2_sbd *sdp = GFS2_SB(dir);
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct gfs2_holder ghs[2];
 	struct buffer_head *dibh;
@@ -1018,7 +1018,7 @@ static int gfs2_unlink_inode(struct gfs2
 			     const struct dentry *dentry,
 			     struct buffer_head *bh)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct gfs2_inode *ip = GFS2_I(inode);
 	int error;
 
@@ -1056,7 +1056,7 @@ static int gfs2_unlink(struct inode *dir
 {
 	struct gfs2_inode *dip = GFS2_I(dir);
 	struct gfs2_sbd *sdp = GFS2_SB(dir);
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct buffer_head *bh;
 	struct gfs2_holder ghs[3];
@@ -1204,7 +1204,7 @@ static int gfs2_ok_to_move(struct gfs2_i
 			error = -EINVAL;
 			break;
 		}
-		if (dir == sb->s_root->d_inode) {
+		if (dir == d_inode(sb->s_root)) {
 			error = 0;
 			break;
 		}
@@ -1239,7 +1239,7 @@ static int gfs2_rename(struct inode *odi
 {
 	struct gfs2_inode *odip = GFS2_I(odir);
 	struct gfs2_inode *ndip = GFS2_I(ndir);
-	struct gfs2_inode *ip = GFS2_I(odentry->d_inode);
+	struct gfs2_inode *ip = GFS2_I(d_inode(odentry));
 	struct gfs2_inode *nip = NULL;
 	struct gfs2_sbd *sdp = GFS2_SB(odir);
 	struct gfs2_holder ghs[5], r_gh = { .gh_gl = NULL, }, ri_gh;
@@ -1250,8 +1250,8 @@ static int gfs2_rename(struct inode *odi
 	unsigned int x;
 	int error;
 
-	if (ndentry->d_inode) {
-		nip = GFS2_I(ndentry->d_inode);
+	if (d_inode(ndentry)) {
+		nip = GFS2_I(d_inode(ndentry));
 		if (ip == nip)
 			return 0;
 	}
@@ -1371,7 +1371,7 @@ static int gfs2_rename(struct inode *odi
 	/* Check out the dir to be renamed */
 
 	if (dir_rename) {
-		error = gfs2_permission(odentry->d_inode, MAY_WRITE, 0);
+		error = gfs2_permission(d_inode(odentry), MAY_WRITE, 0);
 		if (error)
 			goto out_gunlock;
 	}
@@ -1483,7 +1483,7 @@ out:
 
 static void *gfs2_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct gfs2_inode *ip = GFS2_I(dentry->d_inode);
+	struct gfs2_inode *ip = GFS2_I(d_inode(dentry));
 	struct gfs2_holder i_gh;
 	struct buffer_head *dibh;
 	unsigned int size;
@@ -1679,7 +1679,7 @@ out_alloc:
 
 static int gfs2_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct gfs2_holder i_gh;
 	int error;
@@ -1730,7 +1730,7 @@ out:
 static int gfs2_getattr(struct vfsmount *mnt, struct dentry *dentry,
 			struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct gfs2_holder gh;
 	int error;
@@ -1753,7 +1753,7 @@ static int gfs2_getattr(struct vfsmount
 static int gfs2_setxattr(struct dentry *dentry, const char *name,
 			 const void *data, size_t size, int flags)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct gfs2_holder gh;
 	int ret;
@@ -1771,7 +1771,7 @@ static int gfs2_setxattr(struct dentry *
 static ssize_t gfs2_getxattr(struct dentry *dentry, const char *name,
 			     void *data, size_t size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct gfs2_holder gh;
 	int ret;
@@ -1788,7 +1788,7 @@ static ssize_t gfs2_getxattr(struct dent
 
 static int gfs2_removexattr(struct dentry *dentry, const char *name)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct gfs2_holder gh;
 	int ret;
diff -u -p a/gfs2/dentry.c b/gfs2/dentry.c
--- a/gfs2/dentry.c
+++ b/gfs2/dentry.c
@@ -48,9 +48,9 @@ static int gfs2_drevalidate(struct dentr
 		return -ECHILD;
 
 	parent = dget_parent(dentry);
-	sdp = GFS2_SB(parent->d_inode);
-	dip = GFS2_I(parent->d_inode);
-	inode = dentry->d_inode;
+	sdp = GFS2_SB(d_inode(parent));
+	dip = GFS2_I(d_inode(parent));
+	inode = d_inode(dentry);
 
 	if (inode) {
 		if (is_bad_inode(inode))
@@ -68,7 +68,7 @@ static int gfs2_drevalidate(struct dentr
 			goto fail;
 	} 
 
-	error = gfs2_dir_check(parent->d_inode, &dentry->d_name, ip);
+	error = gfs2_dir_check(d_inode(parent), &dentry->d_name, ip);
 	switch (error) {
 	case 0:
 		if (!inode)
@@ -120,10 +120,10 @@ static int gfs2_dentry_delete(const stru
 {
 	struct gfs2_inode *ginode;
 
-	if (!dentry->d_inode)
+	if (!d_inode(dentry))
 		return 0;
 
-	ginode = GFS2_I(dentry->d_inode);
+	ginode = GFS2_I(d_inode(dentry));
 	if (!ginode->i_iopen_gh.gh_gl)
 		return 0;
 
diff -u -p a/gfs2/file.c b/gfs2/file.c
--- a/gfs2/file.c
+++ b/gfs2/file.c
@@ -147,7 +147,7 @@ static const u32 gfs2_to_fsflags[32] = {
 
 static int gfs2_get_flags(struct file *filp, u32 __user *ptr)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct gfs2_holder gh;
 	int error;
@@ -204,7 +204,7 @@ void gfs2_set_inode_flags(struct inode *
  */
 static int do_gfs2_set_flags(struct file *filp, u32 reqflags, u32 mask)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct gfs2_sbd *sdp = GFS2_SB(inode);
 	struct buffer_head *bh;
@@ -280,7 +280,7 @@ out_drop_write:
 
 static int gfs2_set_flags(struct file *filp, u32 __user *ptr)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	u32 fsflags, gfsflags;
 
 	if (get_user(fsflags, ptr))
@@ -347,7 +347,7 @@ static int gfs2_allocate_page_backing(st
 static int gfs2_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)
 {
 	struct page *page = vmf->page;
-	struct inode *inode = vma->vm_file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(vma->vm_file->f_path.dentry);
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct gfs2_sbd *sdp = GFS2_SB(inode);
 	unsigned long last_index;
@@ -594,7 +594,7 @@ static ssize_t gfs2_file_aio_write(struc
 
 	if (file->f_flags & O_APPEND) {
 		struct dentry *dentry = file->f_dentry;
-		struct gfs2_inode *ip = GFS2_I(dentry->d_inode);
+		struct gfs2_inode *ip = GFS2_I(d_inode(dentry));
 		struct gfs2_holder gh;
 		int ret;
 
@@ -809,7 +809,7 @@ static void calc_max_reserv(struct gfs2_
 static long gfs2_fallocate(struct file *file, int mode, loff_t offset,
 			   loff_t len)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct gfs2_sbd *sdp = GFS2_SB(inode);
 	struct gfs2_inode *ip = GFS2_I(inode);
 	unsigned int data_blocks = 0, ind_blocks = 0, rblocks;
@@ -972,7 +972,7 @@ static int do_flock(struct file *file, i
 {
 	struct gfs2_file *fp = file->private_data;
 	struct gfs2_holder *fl_gh = &fp->f_fl_gh;
-	struct gfs2_inode *ip = GFS2_I(file->f_path.dentry->d_inode);
+	struct gfs2_inode *ip = GFS2_I(d_inode(file->f_path.dentry));
 	struct gfs2_glock *gl;
 	unsigned int state;
 	int flags;
diff -u -p a/gfs2/dir.c b/gfs2/dir.c
--- a/gfs2/dir.c
+++ b/gfs2/dir.c
@@ -1714,7 +1714,7 @@ int gfs2_dir_del(struct gfs2_inode *dip,
 	gfs2_trans_add_bh(dip->i_gl, bh, 1);
 	dip->i_entries--;
 	dip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME;
-	if (S_ISDIR(dentry->d_inode->i_mode))
+	if (S_ISDIR(d_inode(dentry)->i_mode))
 		drop_nlink(&dip->i_inode);
 	gfs2_dinode_out(dip, bh->b_data);
 	brelse(bh);
diff -u -p a/gfs2/export.c b/gfs2/export.c
--- a/gfs2/export.c
+++ b/gfs2/export.c
@@ -32,7 +32,7 @@ static int gfs2_encode_fh(struct dentry
 			  int connectable)
 {
 	__be32 *fh = (__force __be32 *)p;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct super_block *sb = inode->i_sb;
 	struct gfs2_inode *ip = GFS2_I(inode);
 
@@ -50,11 +50,11 @@ static int gfs2_encode_fh(struct dentry
 	fh[3] = cpu_to_be32(ip->i_no_addr & 0xFFFFFFFF);
 	*len = GFS2_SMALL_FH_SIZE;
 
-	if (!connectable || inode == sb->s_root->d_inode)
+	if (!connectable || inode == d_inode(sb->s_root))
 		return *len;
 
 	spin_lock(&dentry->d_lock);
-	inode = dentry->d_parent->d_inode;
+	inode = d_inode(dentry->d_parent);
 	ip = GFS2_I(inode);
 	igrab(inode);
 	spin_unlock(&dentry->d_lock);
@@ -92,8 +92,8 @@ static int get_name_filldir(void *opaque
 static int gfs2_get_name(struct dentry *parent, char *name,
 			 struct dentry *child)
 {
-	struct inode *dir = parent->d_inode;
-	struct inode *inode = child->d_inode;
+	struct inode *dir = d_inode(parent);
+	struct inode *inode = d_inode(child);
 	struct gfs2_inode *dip, *ip;
 	struct get_name_filldir gnfd;
 	struct gfs2_holder gh;
@@ -130,7 +130,7 @@ static int gfs2_get_name(struct dentry *
 
 static struct dentry *gfs2_get_parent(struct dentry *child)
 {
-	return d_obtain_alias(gfs2_lookupi(child->d_inode, &gfs2_qdotdot, 1));
+	return d_obtain_alias(gfs2_lookupi(d_inode(child), &gfs2_qdotdot, 1));
 }
 
 static struct dentry *gfs2_get_dentry(struct super_block *sb,
diff -u -p a/gfs2/acl.c b/gfs2/acl.c
--- a/gfs2/acl.c
+++ b/gfs2/acl.c
@@ -241,7 +241,7 @@ static int gfs2_acl_type(const char *nam
 static int gfs2_xattr_system_get(struct dentry *dentry, const char *name,
 				 void *buffer, size_t size, int xtype)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct gfs2_sbd *sdp = GFS2_SB(inode);
 	struct posix_acl *acl;
 	int type;
@@ -270,7 +270,7 @@ static int gfs2_xattr_system_set(struct
 				 const void *value, size_t size, int flags,
 				 int xtype)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct gfs2_sbd *sdp = GFS2_SB(inode);
 	struct posix_acl *acl = NULL;
 	int error = 0, type;
diff -u -p a/gfs2/xattr.c b/gfs2/xattr.c
--- a/gfs2/xattr.c
+++ b/gfs2/xattr.c
@@ -424,7 +424,7 @@ static int ea_list_i(struct gfs2_inode *
 
 ssize_t gfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
 {
-	struct gfs2_inode *ip = GFS2_I(dentry->d_inode);
+	struct gfs2_inode *ip = GFS2_I(d_inode(dentry));
 	struct gfs2_ea_request er;
 	struct gfs2_holder i_gh;
 	int error;
@@ -577,7 +577,7 @@ out:
 static int gfs2_xattr_get(struct dentry *dentry, const char *name,
 		void *buffer, size_t size, int type)
 {
-	struct gfs2_inode *ip = GFS2_I(dentry->d_inode);
+	struct gfs2_inode *ip = GFS2_I(d_inode(dentry));
 	struct gfs2_ea_location el;
 	int error;
 
@@ -1225,7 +1225,7 @@ int __gfs2_xattr_set(struct inode *inode
 static int gfs2_xattr_set(struct dentry *dentry, const char *name,
 		const void *value, size_t size, int flags, int type)
 {
-	return __gfs2_xattr_set(dentry->d_inode, name, value,
+	return __gfs2_xattr_set(d_inode(dentry), name, value,
 				size, flags, type);
 }
 
diff -u -p a/gfs2/ops_fstype.c b/gfs2/ops_fstype.c
--- a/gfs2/ops_fstype.c
+++ b/gfs2/ops_fstype.c
@@ -636,7 +636,7 @@ static int gfs2_jindex_hold(struct gfs2_
 
 static int init_journal(struct gfs2_sbd *sdp, int undo)
 {
-	struct inode *master = sdp->sd_master_dir->d_inode;
+	struct inode *master = d_inode(sdp->sd_master_dir);
 	struct gfs2_holder ji_gh;
 	struct gfs2_inode *ip;
 	int jindex = 1;
@@ -765,7 +765,7 @@ static int init_inodes(struct gfs2_sbd *
 {
 	int error = 0;
 	struct gfs2_inode *ip;
-	struct inode *master = sdp->sd_master_dir->d_inode;
+	struct inode *master = d_inode(sdp->sd_master_dir);
 
 	if (undo)
 		goto fail_qinode;
@@ -820,7 +820,7 @@ static int init_per_node(struct gfs2_sbd
 	char buf[30];
 	int error = 0;
 	struct gfs2_inode *ip;
-	struct inode *master = sdp->sd_master_dir->d_inode;
+	struct inode *master = d_inode(sdp->sd_master_dir);
 
 	if (sdp->sd_args.ar_spectator)
 		return 0;
@@ -1356,7 +1356,7 @@ static struct dentry *gfs2_mount_meta(st
 		return ERR_PTR(error);
 	}
 	s = sget(&gfs2_fs_type, test_gfs2_super, set_meta_super,
-		 path.dentry->d_inode->i_sb->s_bdev);
+		 d_inode(path.dentry)->i_sb->s_bdev);
 	path_put(&path);
 	if (IS_ERR(s)) {
 		printk(KERN_WARNING "GFS2: gfs2 mount does not exist\n");
diff -u -p a/proc/base.c b/proc/base.c
--- a/proc/base.c
+++ b/proc/base.c
@@ -457,7 +457,7 @@ static int lstats_open(struct inode *ino
 static ssize_t lstats_write(struct file *file, const char __user *buf,
 			    size_t count, loff_t *offs)
 {
-	struct task_struct *task = get_proc_task(file->f_dentry->d_inode);
+	struct task_struct *task = get_proc_task(d_inode(file->f_dentry));
 
 	if (!task)
 		return -ESRCH;
@@ -606,7 +606,7 @@ static int proc_fd_access_allowed(struct
 int proc_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	int error;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	if (attr->ia_valid & ATTR_MODE)
 		return -EPERM;
@@ -750,7 +750,7 @@ static const struct file_operations proc
 static ssize_t proc_info_read(struct file * file, char __user * buf,
 			  size_t count, loff_t *ppos)
 {
-	struct inode * inode = file->f_path.dentry->d_inode;
+	struct inode * inode = d_inode(file->f_path.dentry);
 	unsigned long page;
 	ssize_t length;
 	struct task_struct *task = get_proc_task(inode);
@@ -825,7 +825,7 @@ static int mem_open(struct inode* inode,
 static ssize_t mem_read(struct file * file, char __user * buf,
 			size_t count, loff_t *ppos)
 {
-	struct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);
+	struct task_struct *task = get_proc_task(d_inode(file->f_path.dentry));
 	char *page;
 	unsigned long src = *ppos;
 	int ret = -ESRCH;
@@ -889,7 +889,7 @@ static ssize_t mem_write(struct file * f
 {
 	int copied;
 	char *page;
-	struct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);
+	struct task_struct *task = get_proc_task(d_inode(file->f_path.dentry));
 	unsigned long dst = *ppos;
 	struct mm_struct *mm;
 
@@ -969,7 +969,7 @@ static const struct file_operations proc
 static ssize_t environ_read(struct file *file, char __user *buf,
 			size_t count, loff_t *ppos)
 {
-	struct task_struct *task = get_proc_task(file->f_dentry->d_inode);
+	struct task_struct *task = get_proc_task(d_inode(file->f_dentry));
 	char *page;
 	unsigned long src = *ppos;
 	int ret = -ESRCH;
@@ -1038,7 +1038,7 @@ static const struct file_operations proc
 static ssize_t oom_adjust_read(struct file *file, char __user *buf,
 				size_t count, loff_t *ppos)
 {
-	struct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);
+	struct task_struct *task = get_proc_task(d_inode(file->f_path.dentry));
 	char buffer[PROC_NUMBUF];
 	size_t len;
 	int oom_adjust = OOM_DISABLE;
@@ -1085,7 +1085,7 @@ static ssize_t oom_adjust_write(struct f
 		goto out;
 	}
 
-	task = get_proc_task(file->f_path.dentry->d_inode);
+	task = get_proc_task(d_inode(file->f_path.dentry));
 	if (!task) {
 		err = -ESRCH;
 		goto out;
@@ -1150,7 +1150,7 @@ static const struct file_operations proc
 static ssize_t oom_score_adj_read(struct file *file, char __user *buf,
 					size_t count, loff_t *ppos)
 {
-	struct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);
+	struct task_struct *task = get_proc_task(d_inode(file->f_path.dentry));
 	char buffer[PROC_NUMBUF];
 	int oom_score_adj = OOM_SCORE_ADJ_MIN;
 	unsigned long flags;
@@ -1193,7 +1193,7 @@ static ssize_t oom_score_adj_write(struc
 		goto out;
 	}
 
-	task = get_proc_task(file->f_path.dentry->d_inode);
+	task = get_proc_task(d_inode(file->f_path.dentry));
 	if (!task) {
 		err = -ESRCH;
 		goto out;
@@ -1254,7 +1254,7 @@ static const struct file_operations proc
 static ssize_t proc_loginuid_read(struct file * file, char __user * buf,
 				  size_t count, loff_t *ppos)
 {
-	struct inode * inode = file->f_path.dentry->d_inode;
+	struct inode * inode = d_inode(file->f_path.dentry);
 	struct task_struct *task = get_proc_task(inode);
 	ssize_t length;
 	char tmpbuf[TMPBUFLEN];
@@ -1270,7 +1270,7 @@ static ssize_t proc_loginuid_read(struct
 static ssize_t proc_loginuid_write(struct file * file, const char __user * buf,
 				   size_t count, loff_t *ppos)
 {
-	struct inode * inode = file->f_path.dentry->d_inode;
+	struct inode * inode = d_inode(file->f_path.dentry);
 	char *page, *tmp;
 	ssize_t length;
 	uid_t loginuid;
@@ -1324,7 +1324,7 @@ static const struct file_operations proc
 static ssize_t proc_sessionid_read(struct file * file, char __user * buf,
 				  size_t count, loff_t *ppos)
 {
-	struct inode * inode = file->f_path.dentry->d_inode;
+	struct inode * inode = d_inode(file->f_path.dentry);
 	struct task_struct *task = get_proc_task(inode);
 	ssize_t length;
 	char tmpbuf[TMPBUFLEN];
@@ -1347,7 +1347,7 @@ static const struct file_operations proc
 static ssize_t proc_fault_inject_read(struct file * file, char __user * buf,
 				      size_t count, loff_t *ppos)
 {
-	struct task_struct *task = get_proc_task(file->f_dentry->d_inode);
+	struct task_struct *task = get_proc_task(d_inode(file->f_dentry));
 	char buffer[PROC_NUMBUF];
 	size_t len;
 	int make_it_fail;
@@ -1379,7 +1379,7 @@ static ssize_t proc_fault_inject_write(s
 	make_it_fail = simple_strtol(strstrip(buffer), &end, 0);
 	if (*end)
 		return -EINVAL;
-	task = get_proc_task(file->f_dentry->d_inode);
+	task = get_proc_task(d_inode(file->f_dentry));
 	if (!task)
 		return -ESRCH;
 	task->make_it_fail = make_it_fail;
@@ -1419,7 +1419,7 @@ static ssize_t
 sched_write(struct file *file, const char __user *buf,
 	    size_t count, loff_t *offset)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct task_struct *p;
 
 	p = get_proc_task(inode);
@@ -1470,7 +1470,7 @@ static ssize_t
 sched_autogroup_write(struct file *file, const char __user *buf,
 	    size_t count, loff_t *offset)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct task_struct *p;
 	char buffer[PROC_NUMBUF];
 	int nice;
@@ -1526,7 +1526,7 @@ static const struct file_operations proc
 static ssize_t comm_write(struct file *file, const char __user *buf,
 				size_t count, loff_t *offset)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct task_struct *p;
 	char buffer[TASK_COMM_LEN];
 
@@ -1607,7 +1607,7 @@ static int proc_exe_link(struct inode *i
 
 static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error = -EACCES;
 
 	/* We don't need a base pointer in the /proc filesystem */
@@ -1649,7 +1649,7 @@ static int do_proc_readlink(struct path
 static int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)
 {
 	int error = -EACCES;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct path path;
 
 	/* Are we allowed to snoop on the tasks file descriptors? */
@@ -1734,7 +1734,7 @@ out_unlock:
 
 int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct task_struct *task;
 	const struct cred *cred;
 
@@ -1782,7 +1782,7 @@ int pid_revalidate(struct dentry *dentry
 	if (nd && nd->flags & LOOKUP_RCU)
 		return -ECHILD;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	task = get_proc_task(inode);
 
 	if (task) {
@@ -1812,7 +1812,7 @@ static int pid_delete_dentry(const struc
 	 * If so, then don't put the dentry on the lru list,
 	 * kill it immediately.
 	 */
-	return !proc_pid(dentry->d_inode)->tasks[PIDTYPE_PID].first;
+	return !proc_pid(d_inode(dentry))->tasks[PIDTYPE_PID].first;
 }
 
 const struct dentry_operations pid_dentry_operations =
@@ -1854,16 +1854,16 @@ int proc_fill_cache(struct file *filp, v
 		struct dentry *new;
 		new = d_alloc(dir, &qname);
 		if (new) {
-			child = instantiate(dir->d_inode, new, task, ptr);
+			child = instantiate(d_inode(dir), new, task, ptr);
 			if (child)
 				dput(new);
 			else
 				child = new;
 		}
 	}
-	if (!child || IS_ERR(child) || !child->d_inode)
+	if (!child || IS_ERR(child) || !d_inode(child))
 		goto end_instantiate;
-	inode = child->d_inode;
+	inode = d_inode(child);
 	if (inode) {
 		ino = inode->i_ino;
 		type = inode->i_mode >> 12;
@@ -1956,7 +1956,7 @@ static int tid_fd_revalidate(struct dent
 	if (nd && nd->flags & LOOKUP_RCU)
 		return -ECHILD;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	task = get_proc_task(inode);
 	fd = proc_fd(inode);
 
@@ -2075,7 +2075,7 @@ static int proc_readfd_common(struct fil
 			      filldir_t filldir, instantiate_t instantiate)
 {
 	struct dentry *dentry = filp->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct task_struct *p = get_proc_task(inode);
 	unsigned int fd, ino;
 	int retval;
@@ -2145,7 +2145,7 @@ static ssize_t proc_fdinfo_read(struct f
 				      size_t len, loff_t *ppos)
 {
 	char tmp[PROC_FDINFO_MAX];
-	int err = proc_fd_info(file->f_path.dentry->d_inode, NULL, tmp);
+	int err = proc_fd_info(d_inode(file->f_path.dentry), NULL, tmp);
 	if (!err)
 		err = simple_read_from_buffer(buf, len, ppos, tmp, strlen(tmp));
 	return err;
@@ -2317,7 +2317,7 @@ static int proc_pident_readdir(struct fi
 {
 	int i;
 	struct dentry *dentry = filp->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct task_struct *task = get_proc_task(inode);
 	const struct pid_entry *p, *last;
 	ino_t ino;
@@ -2371,7 +2371,7 @@ out_no_task:
 static ssize_t proc_pid_attr_read(struct file * file, char __user * buf,
 				  size_t count, loff_t *ppos)
 {
-	struct inode * inode = file->f_path.dentry->d_inode;
+	struct inode * inode = d_inode(file->f_path.dentry);
 	char *p = NULL;
 	ssize_t length;
 	struct task_struct *task = get_proc_task(inode);
@@ -2392,7 +2392,7 @@ static ssize_t proc_pid_attr_read(struct
 static ssize_t proc_pid_attr_write(struct file * file, const char __user * buf,
 				   size_t count, loff_t *ppos)
 {
-	struct inode * inode = file->f_path.dentry->d_inode;
+	struct inode * inode = d_inode(file->f_path.dentry);
 	char *page;
 	ssize_t length;
 	struct task_struct *task = get_proc_task(inode);
@@ -2481,7 +2481,7 @@ static const struct inode_operations pro
 static ssize_t proc_coredump_filter_read(struct file *file, char __user *buf,
 					 size_t count, loff_t *ppos)
 {
-	struct task_struct *task = get_proc_task(file->f_dentry->d_inode);
+	struct task_struct *task = get_proc_task(d_inode(file->f_dentry));
 	struct mm_struct *mm;
 	char buffer[PROC_NUMBUF];
 	size_t len;
@@ -2533,7 +2533,7 @@ static ssize_t proc_coredump_filter_writ
 		goto out_no_task;
 
 	ret = -ESRCH;
-	task = get_proc_task(file->f_dentry->d_inode);
+	task = get_proc_task(d_inode(file->f_dentry));
 	if (!task)
 		goto out_no_task;
 
@@ -3086,7 +3086,7 @@ int proc_pid_readdir(struct file * filp,
 		goto out_no_task;
 	nr = filp->f_pos - FIRST_PROCESS_ENTRY;
 
-	reaper = get_proc_task(filp->f_path.dentry->d_inode);
+	reaper = get_proc_task(d_inode(filp->f_path.dentry));
 	if (!reaper)
 		goto out_no_task;
 
@@ -3359,7 +3359,7 @@ static int proc_task_fill_cache(struct f
 static int proc_task_readdir(struct file * filp, void * dirent, filldir_t filldir)
 {
 	struct dentry *dentry = filp->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct task_struct *leader = NULL;
 	struct task_struct *task;
 	int retval = -ENOENT;
@@ -3422,7 +3422,7 @@ out_no_task:
 
 static int proc_task_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct task_struct *p = get_proc_task(inode);
 	generic_fillattr(inode, stat);
 
diff -u -p a/proc/proc_sysctl.c b/proc/proc_sysctl.c
--- a/proc/proc_sysctl.c
+++ b/proc/proc_sysctl.c
@@ -131,7 +131,7 @@ out:
 static ssize_t proc_sys_call_handler(struct file *filp, void __user *buf,
 		size_t count, loff_t *ppos, int write)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct ctl_table_header *head = grab_header(inode);
 	struct ctl_table *table = PROC_I(inode)->sysctl_entry;
 	ssize_t error;
@@ -208,7 +208,7 @@ static int proc_sys_fill_cache(struct fi
 			return -ENOMEM;
 		}
 	}
-	inode = child->d_inode;
+	inode = d_inode(child);
 	ino  = inode->i_ino;
 	type = inode->i_mode >> 12;
 	dput(child);
@@ -242,7 +242,7 @@ static int scan(struct ctl_table_header
 static int proc_sys_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
 	struct dentry *dentry = filp->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ctl_table_header *head = grab_header(inode);
 	struct ctl_table *table = PROC_I(inode)->sysctl_entry;
 	struct ctl_table_header *h = NULL;
@@ -324,7 +324,7 @@ static int proc_sys_permission(struct in
 
 static int proc_sys_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	if (attr->ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID))
@@ -348,7 +348,7 @@ static int proc_sys_setattr(struct dentr
 
 static int proc_sys_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ctl_table_header *head = grab_header(inode);
 	struct ctl_table *table = PROC_I(inode)->sysctl_entry;
 
@@ -391,12 +391,12 @@ static int proc_sys_revalidate(struct de
 {
 	if (nd->flags & LOOKUP_RCU)
 		return -ECHILD;
-	return !PROC_I(dentry->d_inode)->sysctl->unregistering;
+	return !PROC_I(d_inode(dentry))->sysctl->unregistering;
 }
 
 static int proc_sys_delete(const struct dentry *dentry)
 {
-	return !!PROC_I(dentry->d_inode)->sysctl->unregistering;
+	return !!PROC_I(d_inode(dentry))->sysctl->unregistering;
 }
 
 static int proc_sys_compare(const struct dentry *parent,
diff -u -p a/proc/proc_net.c b/proc/proc_net.c
--- a/proc/proc_net.c
+++ b/proc/proc_net.c
@@ -136,7 +136,7 @@ static struct dentry *proc_tgid_net_look
 static int proc_tgid_net_getattr(struct vfsmount *mnt, struct dentry *dentry,
 		struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct net *net;
 
 	net = get_proc_task_net(inode);
@@ -163,7 +163,7 @@ static int proc_tgid_net_readdir(struct
 	struct net *net;
 
 	ret = -EINVAL;
-	net = get_proc_task_net(filp->f_path.dentry->d_inode);
+	net = get_proc_task_net(d_inode(filp->f_path.dentry));
 	if (net != NULL) {
 		ret = proc_readdir_de(net->proc_net, filp, dirent, filldir);
 		put_net(net);
diff -u -p a/proc/nommu.c b/proc/nommu.c
--- a/proc/nommu.c
+++ b/proc/nommu.c
@@ -45,7 +45,7 @@ static int nommu_region_show(struct seq_
 	file = region->vm_file;
 
 	if (file) {
-		struct inode *inode = region->vm_file->f_path.dentry->d_inode;
+		struct inode *inode = d_inode(region->vm_file->f_path.dentry);
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 	}
diff -u -p a/proc/inode.c b/proc/inode.c
--- a/proc/inode.c
+++ b/proc/inode.c
@@ -126,7 +126,7 @@ void pde_users_dec(struct proc_dir_entry
 
 static loff_t proc_reg_llseek(struct file *file, loff_t offset, int whence)
 {
-	struct proc_dir_entry *pde = PDE(file->f_path.dentry->d_inode);
+	struct proc_dir_entry *pde = PDE(d_inode(file->f_path.dentry));
 	loff_t rv = -EINVAL;
 	loff_t (*llseek)(struct file *, loff_t, int);
 
@@ -161,7 +161,7 @@ static loff_t proc_reg_llseek(struct fil
 
 static ssize_t proc_reg_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 {
-	struct proc_dir_entry *pde = PDE(file->f_path.dentry->d_inode);
+	struct proc_dir_entry *pde = PDE(d_inode(file->f_path.dentry));
 	ssize_t rv = -EIO;
 	ssize_t (*read)(struct file *, char __user *, size_t, loff_t *);
 
@@ -183,7 +183,7 @@ static ssize_t proc_reg_read(struct file
 
 static ssize_t proc_reg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
 {
-	struct proc_dir_entry *pde = PDE(file->f_path.dentry->d_inode);
+	struct proc_dir_entry *pde = PDE(d_inode(file->f_path.dentry));
 	ssize_t rv = -EIO;
 	ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *);
 
@@ -205,7 +205,7 @@ static ssize_t proc_reg_write(struct fil
 
 static unsigned int proc_reg_poll(struct file *file, struct poll_table_struct *pts)
 {
-	struct proc_dir_entry *pde = PDE(file->f_path.dentry->d_inode);
+	struct proc_dir_entry *pde = PDE(d_inode(file->f_path.dentry));
 	unsigned int rv = DEFAULT_POLLMASK;
 	unsigned int (*poll)(struct file *, struct poll_table_struct *);
 
@@ -227,7 +227,7 @@ static unsigned int proc_reg_poll(struct
 
 static long proc_reg_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-	struct proc_dir_entry *pde = PDE(file->f_path.dentry->d_inode);
+	struct proc_dir_entry *pde = PDE(d_inode(file->f_path.dentry));
 	long rv = -ENOTTY;
 	long (*ioctl)(struct file *, unsigned int, unsigned long);
 
@@ -250,7 +250,7 @@ static long proc_reg_unlocked_ioctl(stru
 #ifdef CONFIG_COMPAT
 static long proc_reg_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-	struct proc_dir_entry *pde = PDE(file->f_path.dentry->d_inode);
+	struct proc_dir_entry *pde = PDE(d_inode(file->f_path.dentry));
 	long rv = -ENOTTY;
 	long (*compat_ioctl)(struct file *, unsigned int, unsigned long);
 
@@ -273,7 +273,7 @@ static long proc_reg_compat_ioctl(struct
 
 static int proc_reg_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	struct proc_dir_entry *pde = PDE(file->f_path.dentry->d_inode);
+	struct proc_dir_entry *pde = PDE(d_inode(file->f_path.dentry));
 	int rv = -EIO;
 	int (*mmap)(struct file *, struct vm_area_struct *);
 
diff -u -p a/proc/generic.c b/proc/generic.c
--- a/proc/generic.c
+++ b/proc/generic.c
@@ -42,7 +42,7 @@ static ssize_t
 __proc_file_read(struct file *file, char __user *buf, size_t nbytes,
 	       loff_t *ppos)
 {
-	struct inode * inode = file->f_path.dentry->d_inode;
+	struct inode * inode = d_inode(file->f_path.dentry);
 	char 	*page;
 	ssize_t	retval=0;
 	int	eof=0;
@@ -188,7 +188,7 @@ static ssize_t
 proc_file_read(struct file *file, char __user *buf, size_t nbytes,
 	       loff_t *ppos)
 {
-	struct proc_dir_entry *pde = PDE(file->f_path.dentry->d_inode);
+	struct proc_dir_entry *pde = PDE(d_inode(file->f_path.dentry));
 	ssize_t rv = -EIO;
 
 	spin_lock(&pde->pde_unload_lock);
@@ -209,7 +209,7 @@ static ssize_t
 proc_file_write(struct file *file, const char __user *buffer,
 		size_t count, loff_t *ppos)
 {
-	struct proc_dir_entry *pde = PDE(file->f_path.dentry->d_inode);
+	struct proc_dir_entry *pde = PDE(d_inode(file->f_path.dentry));
 	ssize_t rv = -EIO;
 
 	if (pde->write_proc) {
@@ -253,7 +253,7 @@ static const struct file_operations proc
 
 static int proc_notify_change(struct dentry *dentry, struct iattr *iattr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct proc_dir_entry *de = PDE(inode);
 	int error;
 
@@ -280,7 +280,7 @@ static int proc_notify_change(struct den
 static int proc_getattr(struct vfsmount *mnt, struct dentry *dentry,
 			struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct proc_dir_entry *de = PROC_I(inode)->pde;
 	if (de && de->nlink)
 		inode->i_nlink = de->nlink;
@@ -385,7 +385,7 @@ static void release_inode_number(unsigne
 
 static void *proc_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	nd_set_link(nd, PDE(dentry->d_inode)->data);
+	nd_set_link(nd, PDE(d_inode(dentry))->data);
 	return NULL;
 }
 
@@ -465,7 +465,7 @@ int proc_readdir_de(struct proc_dir_entr
 {
 	unsigned int ino;
 	int i;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	int ret = 0;
 
 	ino = inode->i_ino;
@@ -527,7 +527,7 @@ out:
 
 int proc_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 
 	return proc_readdir_de(PDE(inode), filp, dirent, filldir);
 }
diff -u -p a/proc/task_mmu.c b/proc/task_mmu.c
--- a/proc/task_mmu.c
+++ b/proc/task_mmu.c
@@ -219,7 +219,7 @@ static void show_map_vma(struct seq_file
 	int len;
 
 	if (file) {
-		struct inode *inode = vma->vm_file->f_path.dentry->d_inode;
+		struct inode *inode = d_inode(vma->vm_file->f_path.dentry);
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 		pgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;
@@ -549,7 +549,7 @@ static ssize_t clear_refs_write(struct f
 		return rv;
 	if (type < CLEAR_REFS_ALL || type > CLEAR_REFS_MAPPED)
 		return -EINVAL;
-	task = get_proc_task(file->f_path.dentry->d_inode);
+	task = get_proc_task(d_inode(file->f_path.dentry));
 	if (!task)
 		return -ESRCH;
 	mm = get_task_mm(task);
@@ -757,7 +757,7 @@ static int pagemap_hugetlb_range(pte_t *
 static ssize_t pagemap_read(struct file *file, char __user *buf,
 			    size_t count, loff_t *ppos)
 {
-	struct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);
+	struct task_struct *task = get_proc_task(d_inode(file->f_path.dentry));
 	struct mm_struct *mm;
 	struct pagemapread pm;
 	int ret = -ESRCH;
diff -u -p a/proc/task_nommu.c b/proc/task_nommu.c
--- a/proc/task_nommu.c
+++ b/proc/task_nommu.c
@@ -147,7 +147,7 @@ static int nommu_vma_show(struct seq_fil
 	file = vma->vm_file;
 
 	if (file) {
-		struct inode *inode = vma->vm_file->f_path.dentry->d_inode;
+		struct inode *inode = d_inode(vma->vm_file->f_path.dentry);
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 		pgoff = (loff_t)vma->vm_pgoff << PAGE_SHIFT;
diff -u -p a/proc/root.c b/proc/root.c
--- a/proc/root.c
+++ b/proc/root.c
@@ -64,7 +64,7 @@ static struct dentry *proc_mount(struct
 		sb->s_flags |= MS_ACTIVE;
 	}
 
-	ei = PROC_I(sb->s_root->d_inode);
+	ei = PROC_I(d_inode(sb->s_root));
 	if (!ei->pid) {
 		rcu_read_lock();
 		ei->pid = get_pid(find_pid_ns(1, ns));
@@ -130,7 +130,7 @@ void __init proc_root_init(void)
 static int proc_root_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat
 )
 {
-	generic_fillattr(dentry->d_inode, stat);
+	generic_fillattr(d_inode(dentry), stat);
 	stat->nlink = proc_root.nlink + nr_processes();
 	return 0;
 }
diff -u -p a/proc/namespaces.c b/proc/namespaces.c
--- a/proc/namespaces.c
+++ b/proc/namespaces.c
@@ -80,7 +80,7 @@ static int proc_ns_dir_readdir(struct fi
 {
 	int i;
 	struct dentry *dentry = filp->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct task_struct *task = get_proc_task(inode);
 	const struct proc_ns_operations **entry, **last;
 	ino_t ino;
diff -u -p a/freevxfs/vxfs_lookup.c b/freevxfs/vxfs_lookup.c
--- a/freevxfs/vxfs_lookup.c
+++ b/freevxfs/vxfs_lookup.c
@@ -237,7 +237,7 @@ vxfs_lookup(struct inode *dip, struct de
 static int
 vxfs_readdir(struct file *fp, void *retp, filldir_t filler)
 {
-	struct inode		*ip = fp->f_path.dentry->d_inode;
+	struct inode		*ip = d_inode(fp->f_path.dentry);
 	struct super_block	*sbp = ip->i_sb;
 	u_long			bsize = sbp->s_blocksize;
 	u_long			page, npages, block, pblocks, nblocks, offset;
diff -u -p a/freevxfs/vxfs_immed.c b/freevxfs/vxfs_immed.c
--- a/freevxfs/vxfs_immed.c
+++ b/freevxfs/vxfs_immed.c
@@ -76,7 +76,7 @@ const struct address_space_operations vx
 static void *
 vxfs_immed_follow_link(struct dentry *dp, struct nameidata *np)
 {
-	struct vxfs_inode_info		*vip = VXFS_INO(dp->d_inode);
+	struct vxfs_inode_info		*vip = VXFS_INO(d_inode(dp));
 	nd_set_link(np, vip->vii_immed.vi_immed);
 	return NULL;
 }
diff -u -p a/affs/amigaffs.c b/affs/amigaffs.c
--- a/affs/amigaffs.c
+++ b/affs/amigaffs.c
@@ -124,7 +124,7 @@ affs_remove_hash(struct inode *dir, stru
 static void
 affs_fix_dcache(struct dentry *dentry, u32 entry_ino)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	void *data = dentry->d_fsdata;
 	struct list_head *head, *next;
 
@@ -148,7 +148,7 @@ affs_fix_dcache(struct dentry *dentry, u
 static int
 affs_remove_link(struct dentry *dentry)
 {
-	struct inode *dir, *inode = dentry->d_inode;
+	struct inode *dir, *inode = d_inode(dentry);
 	struct super_block *sb = inode->i_sb;
 	struct buffer_head *bh = NULL, *link_bh = NULL;
 	u32 link_ino, ino;
@@ -274,11 +274,11 @@ affs_remove_header(struct dentry *dentry
 	struct buffer_head *bh = NULL;
 	int retval;
 
-	dir = dentry->d_parent->d_inode;
+	dir = d_inode(dentry->d_parent);
 	sb = dir->i_sb;
 
 	retval = -ENOENT;
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	if (!inode)
 		goto done;
 
diff -u -p a/affs/inode.c b/affs/inode.c
--- a/affs/inode.c
+++ b/affs/inode.c
@@ -217,7 +217,7 @@ affs_write_inode(struct inode *inode, st
 int
 affs_notify_change(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	pr_debug("AFFS: notify_change(%lu,0x%x)\n",inode->i_ino,attr->ia_valid);
diff -u -p a/affs/namei.c b/affs/namei.c
--- a/affs/namei.c
+++ b/affs/namei.c
@@ -248,7 +248,7 @@ int
 affs_unlink(struct inode *dir, struct dentry *dentry)
 {
 	pr_debug("AFFS: unlink(dir=%d, %lu \"%.*s\")\n", (u32)dir->i_ino,
-		 dentry->d_inode->i_ino,
+		 d_inode(dentry)->i_ino,
 		 (int)dentry->d_name.len, dentry->d_name.name);
 
 	return affs_remove_header(dentry);
@@ -317,7 +317,7 @@ int
 affs_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	pr_debug("AFFS: rmdir(dir=%u, %lu \"%.*s\")\n", (u32)dir->i_ino,
-		 dentry->d_inode->i_ino,
+		 d_inode(dentry)->i_ino,
 		 (int)dentry->d_name.len, dentry->d_name.name);
 
 	return affs_remove_header(dentry);
@@ -401,7 +401,7 @@ err:
 int
 affs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 
 	pr_debug("AFFS: link(%u, %u, \"%.*s\")\n", (u32)inode->i_ino, (u32)dir->i_ino,
 		 (int)dentry->d_name.len,dentry->d_name.name);
@@ -426,13 +426,13 @@ affs_rename(struct inode *old_dir, struc
 		return retval;
 
 	/* Unlink destination if it already exists */
-	if (new_dentry->d_inode) {
+	if (d_inode(new_dentry)) {
 		retval = affs_remove_header(new_dentry);
 		if (retval)
 			return retval;
 	}
 
-	bh = affs_bread(sb, old_dentry->d_inode->i_ino);
+	bh = affs_bread(sb, d_inode(old_dentry)->i_ino);
 	if (!bh)
 		return -EIO;
 
diff -u -p a/affs/dir.c b/affs/dir.c
--- a/affs/dir.c
+++ b/affs/dir.c
@@ -42,7 +42,7 @@ const struct inode_operations affs_dir_i
 static int
 affs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode		*inode = filp->f_path.dentry->d_inode;
+	struct inode		*inode = d_inode(filp->f_path.dentry);
 	struct super_block	*sb = inode->i_sb;
 	struct buffer_head	*dir_bh;
 	struct buffer_head	*fh_bh;
diff -u -p a/exofs/super.c b/exofs/super.c
--- a/exofs/super.c
+++ b/exofs/super.c
@@ -915,7 +915,7 @@ struct dentry *exofs_get_parent(struct d
 	if (!ino)
 		return ERR_PTR(-ESTALE);
 
-	return d_obtain_alias(exofs_iget(child->d_inode->i_sb, ino));
+	return d_obtain_alias(exofs_iget(d_inode(child)->i_sb, ino));
 }
 
 static struct inode *exofs_nfs_get_inode(struct super_block *sb,
diff -u -p a/exofs/symlink.c b/exofs/symlink.c
--- a/exofs/symlink.c
+++ b/exofs/symlink.c
@@ -37,7 +37,7 @@
 
 static void *exofs_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct exofs_i_info *oi = exofs_i(dentry->d_inode);
+	struct exofs_i_info *oi = exofs_i(d_inode(dentry));
 
 	nd_set_link(nd, (char *)oi->i_data);
 	return NULL;
diff -u -p a/exofs/inode.c b/exofs/inode.c
--- a/exofs/inode.c
+++ b/exofs/inode.c
@@ -869,7 +869,7 @@ static int _do_truncate(struct inode *in
  */
 int exofs_setattr(struct dentry *dentry, struct iattr *iattr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	/* if we are about to modify an object, and it hasn't been
diff -u -p a/exofs/namei.c b/exofs/namei.c
--- a/exofs/namei.c
+++ b/exofs/namei.c
@@ -146,7 +146,7 @@ out_fail:
 static int exofs_link(struct dentry *old_dentry, struct inode *dir,
 		struct dentry *dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 
 	if (inode->i_nlink >= EXOFS_LINK_MAX)
 		return -EMLINK;
@@ -202,7 +202,7 @@ out_dir:
 
 static int exofs_unlink(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct exofs_dir_entry *de;
 	struct page *page;
 	int err = -ENOENT;
@@ -224,7 +224,7 @@ out:
 
 static int exofs_rmdir(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int err = -ENOTEMPTY;
 
 	if (exofs_empty_dir(inode)) {
@@ -241,8 +241,8 @@ static int exofs_rmdir(struct inode *dir
 static int exofs_rename(struct inode *old_dir, struct dentry *old_dentry,
 		struct inode *new_dir, struct dentry *new_dentry)
 {
-	struct inode *old_inode = old_dentry->d_inode;
-	struct inode *new_inode = new_dentry->d_inode;
+	struct inode *old_inode = d_inode(old_dentry);
+	struct inode *new_inode = d_inode(new_dentry);
 	struct page *dir_page = NULL;
 	struct exofs_dir_entry *dir_de = NULL;
 	struct page *old_page;
diff -u -p a/exofs/dir.c b/exofs/dir.c
--- a/exofs/dir.c
+++ b/exofs/dir.c
@@ -242,7 +242,7 @@ static int
 exofs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
 	loff_t pos = filp->f_pos;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	unsigned int offset = pos & ~PAGE_CACHE_MASK;
 	unsigned long n = pos >> PAGE_CACHE_SHIFT;
 	unsigned long npages = dir_pages(inode);
@@ -385,7 +385,7 @@ ino_t exofs_parent_ino(struct dentry *ch
 	struct exofs_dir_entry *de;
 	ino_t ino;
 
-	de = exofs_dotdot(child->d_inode, &page);
+	de = exofs_dotdot(d_inode(child), &page);
 	if (!de)
 		return 0;
 
@@ -435,7 +435,7 @@ int exofs_set_link(struct inode *dir, st
 
 int exofs_add_link(struct dentry *dentry, struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	const unsigned char *name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
 	unsigned chunk_size = exofs_chunk_size(dir);
diff -u -p a/configfs/inode.c b/configfs/inode.c
--- a/configfs/inode.c
+++ b/configfs/inode.c
@@ -63,7 +63,7 @@ static const struct inode_operations con
 
 int configfs_setattr(struct dentry * dentry, struct iattr * iattr)
 {
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	struct configfs_dirent * sd = dentry->d_fsdata;
 	struct iattr * sd_iattr;
 	unsigned int ia_valid = iattr->ia_valid;
@@ -189,11 +189,11 @@ int configfs_create(struct dentry * dent
 	int error = 0;
 	struct inode * inode = NULL;
 	if (dentry) {
-		if (!dentry->d_inode) {
+		if (!d_inode(dentry)) {
 			struct configfs_dirent *sd = dentry->d_fsdata;
 			if ((inode = configfs_new_inode(mode, sd))) {
-				if (dentry->d_parent && dentry->d_parent->d_inode) {
-					struct inode *p_inode = dentry->d_parent->d_inode;
+				if (dentry->d_parent && d_inode(dentry->d_parent)) {
+					struct inode *p_inode = d_inode(dentry->d_parent);
 					p_inode->i_mtime = p_inode->i_ctime = CURRENT_TIME;
 				}
 				configfs_set_inode_lock_class(sd, inode);
@@ -251,11 +251,11 @@ void configfs_drop_dentry(struct configf
 
 	if (dentry) {
 		spin_lock(&dentry->d_lock);
-		if (!(d_unhashed(dentry) && dentry->d_inode)) {
+		if (!(d_unhashed(dentry) && d_inode(dentry))) {
 			dget_dlock(dentry);
 			__d_drop(dentry);
 			spin_unlock(&dentry->d_lock);
-			simple_unlink(parent->d_inode, dentry);
+			simple_unlink(d_inode(parent), dentry);
 		} else
 			spin_unlock(&dentry->d_lock);
 	}
@@ -266,11 +266,11 @@ void configfs_hash_and_remove(struct den
 	struct configfs_dirent * sd;
 	struct configfs_dirent * parent_sd = dir->d_fsdata;
 
-	if (dir->d_inode == NULL)
+	if (d_inode(dir) == NULL)
 		/* no inode means this hasn't been made visible yet */
 		return;
 
-	mutex_lock(&dir->d_inode->i_mutex);
+	mutex_lock(&d_inode(dir)->i_mutex);
 	list_for_each_entry(sd, &parent_sd->s_children, s_sibling) {
 		if (!sd->s_element)
 			continue;
@@ -283,7 +283,7 @@ void configfs_hash_and_remove(struct den
 			break;
 		}
 	}
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 }
 
 int __init configfs_inode_init(void)
diff -u -p a/configfs/file.c b/configfs/file.c
--- a/configfs/file.c
+++ b/configfs/file.c
@@ -320,9 +320,9 @@ int configfs_add_file(struct dentry * di
 	umode_t mode = (attr->ca_mode & S_IALLUGO) | S_IFREG;
 	int error = 0;
 
-	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_NORMAL);
+	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_NORMAL);
 	error = configfs_make_dirent(parent_sd, NULL, (void *) attr, mode, type);
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 
 	return error;
 }
diff -u -p a/configfs/dir.c b/configfs/dir.c
--- a/configfs/dir.c
+++ b/configfs/dir.c
@@ -278,7 +278,7 @@ static int create_dir(struct config_item
 		configfs_set_dir_dirent_depth(p->d_fsdata, d->d_fsdata);
 		error = configfs_create(d, mode, init_dir);
 		if (!error) {
-			inc_nlink(p->d_inode);
+			inc_nlink(d_inode(p));
 		} else {
 			struct configfs_dirent *sd = d->d_fsdata;
 			if (sd) {
@@ -394,8 +394,8 @@ static void remove_dir(struct dentry * d
 	list_del_init(&sd->s_sibling);
 	spin_unlock(&configfs_dirent_lock);
 	configfs_put(sd);
-	if (d->d_inode)
-		simple_rmdir(parent->d_inode,d);
+	if (d_inode(d))
+		simple_rmdir(d_inode(parent),d);
 
 	pr_debug(" o %s removing done (%d)\n",d->d_name.name, d->d_count);
 
@@ -529,7 +529,7 @@ static int configfs_detach_prep(struct d
 			/* Abort if racing with mkdir() */
 			if (sd->s_type & CONFIGFS_USET_IN_MKDIR) {
 				if (wait_mutex)
-					*wait_mutex = &sd->s_dentry->d_inode->i_mutex;
+					*wait_mutex = &d_inode(sd->s_dentry)->i_mutex;
 				return -EAGAIN;
 			}
 
@@ -640,13 +640,13 @@ static void detach_groups(struct config_
 
 		child = sd->s_dentry;
 
-		mutex_lock(&child->d_inode->i_mutex);
+		mutex_lock(&d_inode(child)->i_mutex);
 
 		configfs_detach_group(sd->s_element);
-		child->d_inode->i_flags |= S_DEAD;
+		d_inode(child)->i_flags |= S_DEAD;
 		dont_mount(child);
 
-		mutex_unlock(&child->d_inode->i_mutex);
+		mutex_unlock(&d_inode(child)->i_mutex);
 
 		d_delete(child);
 		dput(child);
@@ -692,7 +692,7 @@ static int create_default_group(struct c
 			sd = child->d_fsdata;
 			sd->s_type |= CONFIGFS_USET_DEFAULT;
 		} else {
-			BUG_ON(child->d_inode);
+			BUG_ON(d_inode(child));
 			d_drop(child);
 			dput(child);
 		}
@@ -838,11 +838,11 @@ static int configfs_attach_item(struct c
 			 * the VFS may already have hit and used them. Thus,
 			 * we must lock them as rmdir() would.
 			 */
-			mutex_lock(&dentry->d_inode->i_mutex);
+			mutex_lock(&d_inode(dentry)->i_mutex);
 			configfs_remove_dir(item);
-			dentry->d_inode->i_flags |= S_DEAD;
+			d_inode(dentry)->i_flags |= S_DEAD;
 			dont_mount(dentry);
-			mutex_unlock(&dentry->d_inode->i_mutex);
+			mutex_unlock(&d_inode(dentry)->i_mutex);
 			d_delete(dentry);
 		}
 	}
@@ -878,16 +878,16 @@ static int configfs_attach_group(struct
 		 * We must also lock the inode to remove it safely in case of
 		 * error, as rmdir() would.
 		 */
-		mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);
+		mutex_lock_nested(&d_inode(dentry)->i_mutex, I_MUTEX_CHILD);
 		configfs_adjust_dir_dirent_depth_before_populate(sd);
 		ret = populate_groups(to_config_group(item));
 		if (ret) {
 			configfs_detach_item(item);
-			dentry->d_inode->i_flags |= S_DEAD;
+			d_inode(dentry)->i_flags |= S_DEAD;
 			dont_mount(dentry);
 		}
 		configfs_adjust_dir_dirent_depth_after_populate(sd);
-		mutex_unlock(&dentry->d_inode->i_mutex);
+		mutex_unlock(&d_inode(dentry)->i_mutex);
 		if (ret)
 			d_delete(dentry);
 	}
@@ -1093,7 +1093,7 @@ int configfs_depend_item(struct configfs
 	 * subsystem is really registered, and so we need to lock out
 	 * configfs_[un]register_subsystem().
 	 */
-	mutex_lock(&configfs_sb->s_root->d_inode->i_mutex);
+	mutex_lock(&d_inode(configfs_sb->s_root)->i_mutex);
 
 	root_sd = configfs_sb->s_root->d_fsdata;
 
@@ -1129,7 +1129,7 @@ int configfs_depend_item(struct configfs
 out_unlock_dirent_lock:
 	spin_unlock(&configfs_dirent_lock);
 out_unlock_fs:
-	mutex_unlock(&configfs_sb->s_root->d_inode->i_mutex);
+	mutex_unlock(&d_inode(configfs_sb->s_root)->i_mutex);
 
 	/*
 	 * If we succeeded, the fs is pinned via other methods.  If not,
@@ -1503,7 +1503,7 @@ static int configfs_dir_open(struct inod
 	struct configfs_dirent * parent_sd = dentry->d_fsdata;
 	int err;
 
-	mutex_lock(&dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(dentry)->i_mutex);
 	/*
 	 * Fake invisibility if dir belongs to a group/default groups hierarchy
 	 * being attached
@@ -1516,7 +1516,7 @@ static int configfs_dir_open(struct inod
 		else
 			err = 0;
 	}
-	mutex_unlock(&dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dentry)->i_mutex);
 
 	return err;
 }
@@ -1526,11 +1526,11 @@ static int configfs_dir_close(struct ino
 	struct dentry * dentry = file->f_path.dentry;
 	struct configfs_dirent * cursor = file->private_data;
 
-	mutex_lock(&dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(dentry)->i_mutex);
 	spin_lock(&configfs_dirent_lock);
 	list_del_init(&cursor->s_sibling);
 	spin_unlock(&configfs_dirent_lock);
-	mutex_unlock(&dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dentry)->i_mutex);
 
 	release_configfs_dirent(cursor);
 
@@ -1554,7 +1554,7 @@ static int configfs_readdir(struct file
 
 	switch (i) {
 		case 0:
-			ino = dentry->d_inode->i_ino;
+			ino = d_inode(dentry)->i_ino;
 			if (filldir(dirent, ".", 1, i, ino, DT_DIR) < 0)
 				break;
 			filp->f_pos++;
@@ -1603,7 +1603,7 @@ static int configfs_readdir(struct file
 				spin_lock(&configfs_dirent_lock);
 				dentry = next->s_dentry;
 				if (dentry)
-					inode = dentry->d_inode;
+					inode = d_inode(dentry);
 				if (inode)
 					ino = inode->i_ino;
 				spin_unlock(&configfs_dirent_lock);
@@ -1628,7 +1628,7 @@ static loff_t configfs_dir_lseek(struct
 {
 	struct dentry * dentry = file->f_path.dentry;
 
-	mutex_lock(&dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(dentry)->i_mutex);
 	switch (origin) {
 		case 1:
 			offset += file->f_pos;
@@ -1636,7 +1636,7 @@ static loff_t configfs_dir_lseek(struct
 			if (offset >= 0)
 				break;
 		default:
-			mutex_unlock(&file->f_path.dentry->d_inode->i_mutex);
+			mutex_unlock(&d_inode(file->f_path.dentry)->i_mutex);
 			return -EINVAL;
 	}
 	if (offset != file->f_pos) {
@@ -1662,7 +1662,7 @@ static loff_t configfs_dir_lseek(struct
 			spin_unlock(&configfs_dirent_lock);
 		}
 	}
-	mutex_unlock(&dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dentry)->i_mutex);
 	return offset;
 }
 
@@ -1692,8 +1692,8 @@ int configfs_register_subsystem(struct c
 	sd = configfs_sb->s_root->d_fsdata;
 	link_group(to_config_group(sd->s_element), group);
 
-	mutex_lock_nested(&configfs_sb->s_root->d_inode->i_mutex,
-			I_MUTEX_PARENT);
+	mutex_lock_nested(&d_inode(configfs_sb->s_root)->i_mutex,
+			  I_MUTEX_PARENT);
 
 	name.name = group->cg_item.ci_name;
 	name.len = strlen(name.name);
@@ -1707,7 +1707,7 @@ int configfs_register_subsystem(struct c
 		err = configfs_attach_group(sd->s_element, &group->cg_item,
 					    dentry);
 		if (err) {
-			BUG_ON(dentry->d_inode);
+			BUG_ON(d_inode(dentry));
 			d_drop(dentry);
 			dput(dentry);
 		} else {
@@ -1717,7 +1717,7 @@ int configfs_register_subsystem(struct c
 		}
 	}
 
-	mutex_unlock(&configfs_sb->s_root->d_inode->i_mutex);
+	mutex_unlock(&d_inode(configfs_sb->s_root)->i_mutex);
 
 	if (err) {
 		unlink_group(group);
@@ -1737,9 +1737,9 @@ void configfs_unregister_subsystem(struc
 		return;
 	}
 
-	mutex_lock_nested(&configfs_sb->s_root->d_inode->i_mutex,
+	mutex_lock_nested(&d_inode(configfs_sb->s_root)->i_mutex,
 			  I_MUTEX_PARENT);
-	mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);
+	mutex_lock_nested(&d_inode(dentry)->i_mutex, I_MUTEX_CHILD);
 	mutex_lock(&configfs_symlink_mutex);
 	spin_lock(&configfs_dirent_lock);
 	if (configfs_detach_prep(dentry, NULL)) {
@@ -1748,13 +1748,13 @@ void configfs_unregister_subsystem(struc
 	spin_unlock(&configfs_dirent_lock);
 	mutex_unlock(&configfs_symlink_mutex);
 	configfs_detach_group(&group->cg_item);
-	dentry->d_inode->i_flags |= S_DEAD;
+	d_inode(dentry)->i_flags |= S_DEAD;
 	dont_mount(dentry);
-	mutex_unlock(&dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dentry)->i_mutex);
 
 	d_delete(dentry);
 
-	mutex_unlock(&configfs_sb->s_root->d_inode->i_mutex);
+	mutex_unlock(&d_inode(configfs_sb->s_root)->i_mutex);
 
 	dput(dentry);
 
diff -u -p a/namespace.c b/namespace.c
--- a/namespace.c
+++ b/namespace.c
@@ -393,7 +393,7 @@ EXPORT_SYMBOL_GPL(mnt_clone_write);
  */
 int mnt_want_write_file(struct file *file)
 {
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	if (!(file->f_mode & FMODE_WRITE) || special_file(inode->i_mode))
 		return mnt_want_write(file->f_path.mnt);
 	else
@@ -1410,13 +1410,13 @@ static int mount_is_safe(struct path *pa
 		return 0;
 	return -EPERM;
 #ifdef notyet
-	if (S_ISLNK(path->dentry->d_inode->i_mode))
+	if (S_ISLNK(d_inode(path->dentry)->i_mode))
 		return -EPERM;
-	if (path->dentry->d_inode->i_mode & S_ISVTX) {
-		if (current_uid() != path->dentry->d_inode->i_uid)
+	if (d_inode(path->dentry)->i_mode & S_ISVTX) {
+		if (current_uid() != d_inode(path->dentry)->i_uid)
 			return -EPERM;
 	}
-	if (inode_permission(path->dentry->d_inode, MAY_WRITE))
+	if (inode_permission(d_inode(path->dentry), MAY_WRITE))
 		return -EPERM;
 	return 0;
 #endif
@@ -1651,9 +1651,9 @@ static int lock_mount(struct path *path)
 {
 	struct vfsmount *mnt;
 retry:
-	mutex_lock(&path->dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(path->dentry)->i_mutex);
 	if (unlikely(cant_mount(path->dentry))) {
-		mutex_unlock(&path->dentry->d_inode->i_mutex);
+		mutex_unlock(&d_inode(path->dentry)->i_mutex);
 		return -ENOENT;
 	}
 	down_write(&namespace_sem);
@@ -1661,7 +1661,7 @@ retry:
 	if (likely(!mnt))
 		return 0;
 	up_write(&namespace_sem);
-	mutex_unlock(&path->dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(path->dentry)->i_mutex);
 	path_put(path);
 	path->mnt = mnt;
 	path->dentry = dget(mnt->mnt_root);
@@ -1671,7 +1671,7 @@ retry:
 static void unlock_mount(struct path *path)
 {
 	up_write(&namespace_sem);
-	mutex_unlock(&path->dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(path->dentry)->i_mutex);
 }
 
 static int graft_tree(struct vfsmount *mnt, struct path *path)
@@ -1679,8 +1679,8 @@ static int graft_tree(struct vfsmount *m
 	if (mnt->mnt_sb->s_flags & MS_NOUSER)
 		return -EINVAL;
 
-	if (S_ISDIR(path->dentry->d_inode->i_mode) !=
-	      S_ISDIR(mnt->mnt_root->d_inode->i_mode))
+	if (S_ISDIR(d_inode(path->dentry)->i_mode) !=
+	      S_ISDIR(d_inode(mnt->mnt_root)->i_mode))
 		return -ENOTDIR;
 
 	if (d_unlinked(path->dentry))
@@ -1897,8 +1897,8 @@ static int do_move_mount(struct path *pa
 	if (old_path.mnt == old_path.mnt->mnt_parent)
 		goto out1;
 
-	if (S_ISDIR(path->dentry->d_inode->i_mode) !=
-	      S_ISDIR(old_path.dentry->d_inode->i_mode))
+	if (S_ISDIR(d_inode(path->dentry)->i_mode) !=
+	      S_ISDIR(d_inode(old_path.dentry)->i_mode))
 		goto out1;
 	/*
 	 * Don't move a mount residing in a shared parent.
@@ -1997,7 +1997,7 @@ static int do_add_mount(struct vfsmount
 		goto unlock;
 
 	err = -EINVAL;
-	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
+	if (S_ISLNK(d_inode(newmnt->mnt_root)->i_mode))
 		goto unlock;
 
 	newmnt->mnt_flags = mnt_flags;
diff -u -p a/bfs/dir.c b/bfs/dir.c
--- a/bfs/dir.c
+++ b/bfs/dir.c
@@ -28,7 +28,7 @@ static struct buffer_head *bfs_find_entr
 
 static int bfs_readdir(struct file *f, void *dirent, filldir_t filldir)
 {
-	struct inode *dir = f->f_path.dentry->d_inode;
+	struct inode *dir = d_inode(f->f_path.dentry);
 	struct buffer_head *bh;
 	struct bfs_dirent *de;
 	struct bfs_sb_info *info = BFS_SB(dir->i_sb);
@@ -162,7 +162,7 @@ static struct dentry *bfs_lookup(struct
 static int bfs_link(struct dentry *old, struct inode *dir,
 						struct dentry *new)
 {
-	struct inode *inode = old->d_inode;
+	struct inode *inode = d_inode(old);
 	struct bfs_sb_info *info = BFS_SB(inode->i_sb);
 	int err;
 
@@ -185,7 +185,7 @@ static int bfs_link(struct dentry *old,
 static int bfs_unlink(struct inode *dir, struct dentry *dentry)
 {
 	int error = -ENOENT;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct buffer_head *bh;
 	struct bfs_dirent *de;
 	struct bfs_sb_info *info = BFS_SB(inode->i_sb);
@@ -225,7 +225,7 @@ static int bfs_rename(struct inode *old_
 	int error = -ENOENT;
 
 	old_bh = new_bh = NULL;
-	old_inode = old_dentry->d_inode;
+	old_inode = d_inode(old_dentry);
 	if (S_ISDIR(old_inode->i_mode))
 		return -EINVAL;
 
@@ -240,7 +240,7 @@ static int bfs_rename(struct inode *old_
 		goto end_rename;
 
 	error = -EPERM;
-	new_inode = new_dentry->d_inode;
+	new_inode = d_inode(new_dentry);
 	new_bh = bfs_find_entry(new_dir, 
 				new_dentry->d_name.name, 
 				new_dentry->d_name.len, &new_de);
diff -u -p a/splice.c b/splice.c
--- a/splice.c
+++ b/splice.c
@@ -1163,7 +1163,7 @@ ssize_t splice_direct_to_actor(struct fi
 	 * randomly drop data for eg socket -> socket splicing. Use the
 	 * piped splicing for that!
 	 */
-	i_mode = in->f_path.dentry->d_inode->i_mode;
+	i_mode = d_inode(in->f_path.dentry)->i_mode;
 	if (unlikely(!S_ISREG(i_mode) && !S_ISBLK(i_mode)))
 		return -EINVAL;
 
diff -u -p a/omfs/file.c b/omfs/file.c
--- a/omfs/file.c
+++ b/omfs/file.c
@@ -342,7 +342,7 @@ const struct file_operations omfs_file_o
 
 static int omfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	error = inode_change_ok(inode, attr);
diff -u -p a/omfs/dir.c b/omfs/dir.c
--- a/omfs/dir.c
+++ b/omfs/dir.c
@@ -110,7 +110,7 @@ int omfs_make_empty(struct inode *inode,
 
 static int omfs_add_link(struct dentry *dentry, struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	const char *name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
 	struct omfs_inode *oi;
@@ -155,7 +155,7 @@ out:
 
 static int omfs_delete_entry(struct dentry *dentry)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	struct inode *dirty;
 	const char *name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
@@ -237,7 +237,7 @@ static int omfs_dir_is_empty(struct inod
 
 static int omfs_remove(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int ret;
 
 
@@ -330,7 +330,7 @@ int omfs_is_bad(struct omfs_sb_info *sbi
 static int omfs_fill_chain(struct file *filp, void *dirent, filldir_t filldir,
 		u64 fsblock, int hindex)
 {
-	struct inode *dir = filp->f_dentry->d_inode;
+	struct inode *dir = d_inode(filp->f_dentry);
 	struct buffer_head *bh;
 	struct omfs_inode *oi;
 	u64 self;
@@ -375,8 +375,8 @@ out:
 static int omfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 		struct inode *new_dir, struct dentry *new_dentry)
 {
-	struct inode *new_inode = new_dentry->d_inode;
-	struct inode *old_inode = old_dentry->d_inode;
+	struct inode *new_inode = d_inode(new_dentry);
+	struct inode *old_inode = d_inode(old_dentry);
 	int err;
 
 	if (new_inode) {
@@ -405,7 +405,7 @@ out:
 
 static int omfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode *dir = filp->f_dentry->d_inode;
+	struct inode *dir = d_inode(filp->f_dentry);
 	struct buffer_head *bh;
 	loff_t offset, res;
 	unsigned int hchain, hindex;
diff -u -p a/ocfs2/symlink.c b/ocfs2/symlink.c
--- a/ocfs2/symlink.c
+++ b/ocfs2/symlink.c
@@ -82,7 +82,7 @@ static int ocfs2_readlink(struct dentry
 	int ret;
 	char *link;
 	struct buffer_head *bh = NULL;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	link = ocfs2_fast_symlink_getlink(inode, &bh);
 	if (IS_ERR(link)) {
@@ -109,7 +109,7 @@ static void *ocfs2_fast_follow_link(stru
 	int status = 0;
 	int len;
 	char *target, *link = ERR_PTR(-ENOMEM);
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct buffer_head *bh = NULL;
 
 	BUG_ON(!ocfs2_inode_is_fast_symlink(inode));
diff -u -p a/ocfs2/move_extents.c b/ocfs2/move_extents.c
--- a/ocfs2/move_extents.c
+++ b/ocfs2/move_extents.c
@@ -1056,7 +1056,7 @@ int ocfs2_ioctl_move_extents(struct file
 {
 	int status;
 
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct ocfs2_move_extents range;
 	struct ocfs2_move_extents_context *context = NULL;
 
diff -u -p a/ocfs2/inode.c b/ocfs2/inode.c
--- a/ocfs2/inode.c
+++ b/ocfs2/inode.c
@@ -1197,7 +1197,7 @@ int ocfs2_drop_inode(struct inode *inode
  */
 int ocfs2_inode_revalidate(struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int status = 0;
 
 	trace_ocfs2_inode_revalidate(inode,
diff -u -p a/ocfs2/file.c b/ocfs2/file.c
--- a/ocfs2/file.c
+++ b/ocfs2/file.c
@@ -1092,7 +1092,7 @@ out:
 int ocfs2_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	int status = 0, size_change;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct super_block *sb = inode->i_sb;
 	struct ocfs2_super *osb = OCFS2_SB(sb);
 	struct buffer_head *bh = NULL;
@@ -1258,8 +1258,8 @@ int ocfs2_getattr(struct vfsmount *mnt,
 		  struct dentry *dentry,
 		  struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
-	struct super_block *sb = dentry->d_inode->i_sb;
+	struct inode *inode = d_inode(dentry);
+	struct super_block *sb = d_inode(dentry)->i_sb;
 	struct ocfs2_super *osb = sb->s_fs_info;
 	int err;
 
@@ -1952,7 +1952,7 @@ out:
 int ocfs2_change_file_space(struct file *file, unsigned int cmd,
 			    struct ocfs2_space_resv *sr)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
 
 	if ((cmd == OCFS2_IOC_RESVSP || cmd == OCFS2_IOC_RESVSP64) &&
@@ -1974,7 +1974,7 @@ int ocfs2_change_file_space(struct file
 static long ocfs2_fallocate(struct file *file, int mode, loff_t offset,
 			    loff_t len)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
 	struct ocfs2_space_resv sr;
 	int change_size = 1;
@@ -2074,7 +2074,7 @@ static int ocfs2_prepare_inode_for_write
 {
 	int ret = 0, meta_level = 0;
 	struct dentry *dentry = file->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	loff_t saved_pos = 0, end;
 
 	/*
@@ -2212,7 +2212,7 @@ static ssize_t ocfs2_file_aio_write(stru
 	loff_t old_size, *ppos = &iocb->ki_pos;
 	u32 old_clusters;
 	struct file *file = iocb->ki_filp;
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
 	int full_coherency = !(osb->s_mount_opt &
 			       OCFS2_MOUNT_COHERENCY_BUFFERED);
@@ -2480,7 +2480,7 @@ static ssize_t ocfs2_file_splice_read(st
 				      unsigned int flags)
 {
 	int ret = 0, lock_level = 0;
-	struct inode *inode = in->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(in->f_path.dentry);
 
 	trace_ocfs2_file_splice_read(inode, in, in->f_path.dentry,
 			(unsigned long long)OCFS2_I(inode)->ip_blkno,
@@ -2510,7 +2510,7 @@ static ssize_t ocfs2_file_aio_read(struc
 {
 	int ret = 0, rw_level = -1, have_alloc_sem = 0, lock_level = 0;
 	struct file *filp = iocb->ki_filp;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 
 	trace_ocfs2_file_aio_read(inode, filp, filp->f_path.dentry,
 			(unsigned long long)OCFS2_I(inode)->ip_blkno,
diff -u -p a/ocfs2/namei.c b/ocfs2/namei.c
--- a/ocfs2/namei.c
+++ b/ocfs2/namei.c
@@ -638,7 +638,7 @@ static int ocfs2_link(struct dentry *old
 		      struct dentry *dentry)
 {
 	handle_t *handle;
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	int err;
 	struct buffer_head *fe_bh = NULL;
 	struct buffer_head *parent_fe_bh = NULL;
@@ -793,7 +793,7 @@ static int ocfs2_unlink(struct inode *di
 {
 	int status;
 	int child_locked = 0;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct inode *orphan_dir = NULL;
 	struct ocfs2_super *osb = OCFS2_SB(dir->i_sb);
 	u64 blkno;
@@ -812,7 +812,7 @@ static int ocfs2_unlink(struct inode *di
 
 	dquot_initialize(dir);
 
-	BUG_ON(dentry->d_parent->d_inode != dir);
+	BUG_ON(d_inode(dentry->d_parent) != dir);
 
 	if (inode == osb->root_inode)
 		return -EPERM;
@@ -1043,8 +1043,8 @@ static int ocfs2_rename(struct inode *ol
 {
 	int status = 0, rename_lock = 0, parents_locked = 0, target_exists = 0;
 	int old_child_locked = 0, new_child_locked = 0, update_dot_dot = 0;
-	struct inode *old_inode = old_dentry->d_inode;
-	struct inode *new_inode = new_dentry->d_inode;
+	struct inode *old_inode = d_inode(old_dentry);
+	struct inode *new_inode = d_inode(new_dentry);
 	struct inode *orphan_dir = NULL;
 	struct ocfs2_dinode *newfe = NULL;
 	char orphan_name[OCFS2_ORPHAN_NAMELEN + 1];
@@ -1270,7 +1270,7 @@ static int ocfs2_rename(struct inode *ol
 			}
 		}
 	} else {
-		BUG_ON(new_dentry->d_parent->d_inode != new_dir);
+		BUG_ON(d_inode(new_dentry->d_parent) != new_dir);
 
 		status = ocfs2_check_dir_for_entry(new_dir,
 						   new_dentry->d_name.name,
diff -u -p a/ocfs2/dcache.c b/ocfs2/dcache.c
--- a/ocfs2/dcache.c
+++ b/ocfs2/dcache.c
@@ -43,8 +43,8 @@
 void ocfs2_dentry_attach_gen(struct dentry *dentry)
 {
 	unsigned long gen =
-		OCFS2_I(dentry->d_parent->d_inode)->ip_dir_lock_gen;
-	BUG_ON(dentry->d_inode);
+		OCFS2_I(d_inode(dentry->d_parent))->ip_dir_lock_gen;
+	BUG_ON(d_inode(dentry));
 	dentry->d_fsdata = (void *)gen;
 }
 
@@ -59,7 +59,7 @@ static int ocfs2_dentry_revalidate(struc
 	if (nd && nd->flags & LOOKUP_RCU)
 		return -ECHILD;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	osb = OCFS2_SB(dentry->d_sb);
 
 	trace_ocfs2_dentry_revalidate(dentry, dentry->d_name.len,
@@ -72,7 +72,7 @@ static int ocfs2_dentry_revalidate(struc
 	if (inode == NULL) {
 		unsigned long gen = (unsigned long) dentry->d_fsdata;
 		unsigned long pgen =
-			OCFS2_I(dentry->d_parent->d_inode)->ip_dir_lock_gen;
+			OCFS2_I(d_inode(dentry->d_parent))->ip_dir_lock_gen;
 
 		trace_ocfs2_dentry_revalidate_negative(dentry->d_name.len,
 						       dentry->d_name.name,
@@ -147,7 +147,7 @@ static int ocfs2_match_dentry(struct den
 	if (skip_unhashed && d_unhashed(dentry))
 		return 0;
 
-	parent = dentry->d_parent->d_inode;
+	parent = d_inode(dentry->d_parent);
 	/* Negative parent dentry? */
 	if (!parent)
 		return 0;
@@ -250,7 +250,7 @@ int ocfs2_dentry_attach_lock(struct dent
 	if (!inode)
 		return 0;
 
-	if (!dentry->d_inode && dentry->d_fsdata) {
+	if (!d_inode(dentry) && dentry->d_fsdata) {
 		/* Converting a negative dentry to positive
 		   Clear dentry->d_fsdata */
 		dentry->d_fsdata = dl = NULL;
@@ -509,7 +509,7 @@ void ocfs2_dentry_move(struct dentry *de
 {
 	int ret;
 	struct ocfs2_super *osb = OCFS2_SB(old_dir->i_sb);
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	/*
 	 * Move within the same directory, so the actual lock info won't
diff -u -p a/ocfs2/mmap.c b/ocfs2/mmap.c
--- a/ocfs2/mmap.c
+++ b/ocfs2/mmap.c
@@ -62,7 +62,7 @@ static int __ocfs2_page_mkwrite(struct f
 				struct page *page)
 {
 	int ret;
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct address_space *mapping = inode->i_mapping;
 	loff_t pos = page_offset(page);
 	unsigned int len = PAGE_CACHE_SIZE;
@@ -134,7 +134,7 @@ out:
 static int ocfs2_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)
 {
 	struct page *page = vmf->page;
-	struct inode *inode = vma->vm_file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(vma->vm_file->f_path.dentry);
 	struct buffer_head *di_bh = NULL;
 	sigset_t oldset;
 	int ret;
@@ -182,13 +182,13 @@ int ocfs2_mmap(struct file *file, struct
 {
 	int ret = 0, lock_level = 0;
 
-	ret = ocfs2_inode_lock_atime(file->f_dentry->d_inode,
-				    file->f_vfsmnt, &lock_level);
+	ret = ocfs2_inode_lock_atime(d_inode(file->f_dentry),
+				     file->f_vfsmnt, &lock_level);
 	if (ret < 0) {
 		mlog_errno(ret);
 		goto out;
 	}
-	ocfs2_inode_unlock(file->f_dentry->d_inode, lock_level);
+	ocfs2_inode_unlock(d_inode(file->f_dentry), lock_level);
 out:
 	vma->vm_ops = &ocfs2_file_vm_ops;
 	vma->vm_flags |= VM_CAN_NONLINEAR;
diff -u -p a/ocfs2/dir.c b/ocfs2/dir.c
--- a/ocfs2/dir.c
+++ b/ocfs2/dir.c
@@ -2016,7 +2016,7 @@ int ocfs2_dir_foreach(struct inode *inod
 int ocfs2_readdir(struct file * filp, void * dirent, filldir_t filldir)
 {
 	int error = 0;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	int lock_level = 0;
 
 	trace_ocfs2_readdir((unsigned long long)OCFS2_I(inode)->ip_blkno);
diff -u -p a/ocfs2/export.c b/ocfs2/export.c
--- a/ocfs2/export.c
+++ b/ocfs2/export.c
@@ -147,7 +147,7 @@ static struct dentry *ocfs2_get_parent(s
 	int status;
 	u64 blkno;
 	struct dentry *parent;
-	struct inode *dir = child->d_inode;
+	struct inode *dir = d_inode(child);
 
 	trace_ocfs2_get_parent(child, child->d_name.len, child->d_name.name,
 			       (unsigned long long)OCFS2_I(dir)->ip_blkno);
@@ -180,7 +180,7 @@ bail:
 static int ocfs2_encode_fh(struct dentry *dentry, u32 *fh_in, int *max_len,
 			   int connectable)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int len = *max_len;
 	int type = 1;
 	u64 blkno;
@@ -216,7 +216,7 @@ static int ocfs2_encode_fh(struct dentry
 
 		spin_lock(&dentry->d_lock);
 
-		parent = dentry->d_parent->d_inode;
+		parent = d_inode(dentry->d_parent);
 		blkno = OCFS2_I(parent)->ip_blkno;
 		generation = parent->i_generation;
 
diff -u -p a/ocfs2/ioctl.c b/ocfs2/ioctl.c
--- a/ocfs2/ioctl.c
+++ b/ocfs2/ioctl.c
@@ -882,7 +882,7 @@ bail:
 
 long ocfs2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	unsigned int flags;
 	int new_clusters;
 	int status;
@@ -987,7 +987,7 @@ long ocfs2_compat_ioctl(struct file *fil
 {
 	bool preserve;
 	struct reflink_arguments args;
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct ocfs2_info info;
 
 	switch (cmd) {
diff -u -p a/ocfs2/dlmfs/dlmfs.c b/ocfs2/dlmfs/dlmfs.c
--- a/ocfs2/dlmfs/dlmfs.c
+++ b/ocfs2/dlmfs/dlmfs.c
@@ -209,7 +209,7 @@ static int dlmfs_file_release(struct ino
 static int dlmfs_file_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	int error;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	attr->ia_valid &= ~ATTR_SIZE;
 	error = inode_change_ok(inode, attr);
@@ -224,7 +224,7 @@ static int dlmfs_file_setattr(struct den
 static unsigned int dlmfs_file_poll(struct file *file, poll_table *wait)
 {
 	int event = 0;
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct dlmfs_inode_private *ip = DLMFS_I(inode);
 
 	poll_wait(file, &ip->ip_lockres.l_event, wait);
@@ -245,7 +245,7 @@ static ssize_t dlmfs_file_read(struct fi
 	int bytes_left;
 	ssize_t readlen, got;
 	char *lvb_buf;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 
 	mlog(0, "inode %lu, count = %zu, *ppos = %llu\n",
 		inode->i_ino, count, *ppos);
@@ -293,7 +293,7 @@ static ssize_t dlmfs_file_write(struct f
 	int bytes_left;
 	ssize_t writelen;
 	char *lvb_buf;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 
 	mlog(0, "inode %lu, count = %zu, *ppos = %llu\n",
 		inode->i_ino, count, *ppos);
@@ -573,7 +573,7 @@ static int dlmfs_unlink(struct inode *di
 			struct dentry *dentry)
 {
 	int status;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	mlog(0, "unlink inode %lu\n", inode->i_ino);
 
diff -u -p a/ocfs2/aops.c b/ocfs2/aops.c
--- a/ocfs2/aops.c
+++ b/ocfs2/aops.c
@@ -562,7 +562,7 @@ static void ocfs2_dio_end_io(struct kioc
 			     int ret,
 			     bool is_async)
 {
-	struct inode *inode = iocb->ki_filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(iocb->ki_filp->f_path.dentry);
 	int level;
 
 	/* this io's submitter should not have unlocked this before we could */
@@ -610,7 +610,7 @@ static ssize_t ocfs2_direct_IO(int rw,
 			       unsigned long nr_segs)
 {
 	struct file *file = iocb->ki_filp;
-	struct inode *inode = file->f_path.dentry->d_inode->i_mapping->host;
+	struct inode *inode = d_inode(file->f_path.dentry)->i_mapping->host;
 
 	/*
 	 * Fallback to buffered I/O if we see an inode without
diff -u -p a/ocfs2/acl.c b/ocfs2/acl.c
--- a/ocfs2/acl.c
+++ b/ocfs2/acl.c
@@ -472,7 +472,7 @@ static int ocfs2_xattr_get_acl(struct de
 	if (!(osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL))
 		return -EOPNOTSUPP;
 
-	acl = ocfs2_get_acl(dentry->d_inode, type);
+	acl = ocfs2_get_acl(d_inode(dentry), type);
 	if (IS_ERR(acl))
 		return PTR_ERR(acl);
 	if (acl == NULL)
@@ -486,7 +486,7 @@ static int ocfs2_xattr_get_acl(struct de
 static int ocfs2_xattr_set_acl(struct dentry *dentry, const char *name,
 		const void *value, size_t size, int flags, int type)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
 	struct posix_acl *acl;
 	int ret = 0;
diff -u -p a/ocfs2/xattr.c b/ocfs2/xattr.c
--- a/ocfs2/xattr.c
+++ b/ocfs2/xattr.c
@@ -1014,7 +1014,7 @@ ssize_t ocfs2_listxattr(struct dentry *d
 	int ret = 0, i_ret = 0, b_ret = 0;
 	struct buffer_head *di_bh = NULL;
 	struct ocfs2_dinode *di = NULL;
-	struct ocfs2_inode_info *oi = OCFS2_I(dentry->d_inode);
+	struct ocfs2_inode_info *oi = OCFS2_I(d_inode(dentry));
 
 	if (!ocfs2_supports_xattr(OCFS2_SB(dentry->d_sb)))
 		return -EOPNOTSUPP;
@@ -1022,7 +1022,7 @@ ssize_t ocfs2_listxattr(struct dentry *d
 	if (!(oi->ip_dyn_features & OCFS2_HAS_XATTR_FL))
 		return ret;
 
-	ret = ocfs2_inode_lock(dentry->d_inode, &di_bh, 0);
+	ret = ocfs2_inode_lock(d_inode(dentry), &di_bh, 0);
 	if (ret < 0) {
 		mlog_errno(ret);
 		return ret;
@@ -1031,7 +1031,7 @@ ssize_t ocfs2_listxattr(struct dentry *d
 	di = (struct ocfs2_dinode *)di_bh->b_data;
 
 	down_read(&oi->ip_xattr_sem);
-	i_ret = ocfs2_xattr_ibody_list(dentry->d_inode, di, buffer, size);
+	i_ret = ocfs2_xattr_ibody_list(d_inode(dentry), di, buffer, size);
 	if (i_ret < 0)
 		b_ret = 0;
 	else {
@@ -1039,13 +1039,13 @@ ssize_t ocfs2_listxattr(struct dentry *d
 			buffer += i_ret;
 			size -= i_ret;
 		}
-		b_ret = ocfs2_xattr_block_list(dentry->d_inode, di,
+		b_ret = ocfs2_xattr_block_list(d_inode(dentry), di,
 					       buffer, size);
 		if (b_ret < 0)
 			i_ret = 0;
 	}
 	up_read(&oi->ip_xattr_sem);
-	ocfs2_inode_unlock(dentry->d_inode, 0);
+	ocfs2_inode_unlock(d_inode(dentry), 0);
 
 	brelse(di_bh);
 
@@ -7241,7 +7241,7 @@ static int ocfs2_xattr_security_get(stru
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ocfs2_xattr_get(dentry->d_inode, OCFS2_XATTR_INDEX_SECURITY,
+	return ocfs2_xattr_get(d_inode(dentry), OCFS2_XATTR_INDEX_SECURITY,
 			       name, buffer, size);
 }
 
@@ -7251,7 +7251,7 @@ static int ocfs2_xattr_security_set(stru
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
 
-	return ocfs2_xattr_set(dentry->d_inode, OCFS2_XATTR_INDEX_SECURITY,
+	return ocfs2_xattr_set(d_inode(dentry), OCFS2_XATTR_INDEX_SECURITY,
 			       name, value, size, flags);
 }
 
@@ -7310,7 +7310,7 @@ static int ocfs2_xattr_trusted_get(struc
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ocfs2_xattr_get(dentry->d_inode, OCFS2_XATTR_INDEX_TRUSTED,
+	return ocfs2_xattr_get(d_inode(dentry), OCFS2_XATTR_INDEX_TRUSTED,
 			       name, buffer, size);
 }
 
@@ -7320,7 +7320,7 @@ static int ocfs2_xattr_trusted_set(struc
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
 
-	return ocfs2_xattr_set(dentry->d_inode, OCFS2_XATTR_INDEX_TRUSTED,
+	return ocfs2_xattr_set(d_inode(dentry), OCFS2_XATTR_INDEX_TRUSTED,
 			       name, value, size, flags);
 }
 
@@ -7362,7 +7362,7 @@ static int ocfs2_xattr_user_get(struct d
 		return -EINVAL;
 	if (osb->s_mount_opt & OCFS2_MOUNT_NOUSERXATTR)
 		return -EOPNOTSUPP;
-	return ocfs2_xattr_get(dentry->d_inode, OCFS2_XATTR_INDEX_USER, name,
+	return ocfs2_xattr_get(d_inode(dentry), OCFS2_XATTR_INDEX_USER, name,
 			       buffer, size);
 }
 
@@ -7376,7 +7376,7 @@ static int ocfs2_xattr_user_set(struct d
 	if (osb->s_mount_opt & OCFS2_MOUNT_NOUSERXATTR)
 		return -EOPNOTSUPP;
 
-	return ocfs2_xattr_set(dentry->d_inode, OCFS2_XATTR_INDEX_USER,
+	return ocfs2_xattr_set(d_inode(dentry), OCFS2_XATTR_INDEX_USER,
 			       name, value, size, flags);
 }
 
diff -u -p a/ocfs2/refcounttree.c b/ocfs2/refcounttree.c
--- a/ocfs2/refcounttree.c
+++ b/ocfs2/refcounttree.c
@@ -2927,7 +2927,7 @@ int ocfs2_duplicate_clusters_by_page(han
 				     u32 new_cluster, u32 new_len)
 {
 	int ret = 0, partial;
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct ocfs2_caching_info *ci = INODE_CACHE(inode);
 	struct super_block *sb = ocfs2_metadata_cache_get_super(ci);
 	u64 new_block = ocfs2_clusters_to_blocks(sb, new_cluster);
@@ -3020,7 +3020,7 @@ int ocfs2_duplicate_clusters_by_jbd(hand
 				    u32 new_cluster, u32 new_len)
 {
 	int ret = 0;
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct super_block *sb = inode->i_sb;
 	struct ocfs2_caching_info *ci = INODE_CACHE(inode);
 	int i, blocks = ocfs2_clusters_to_blocks(sb, new_len);
@@ -4220,7 +4220,7 @@ static int __ocfs2_reflink(struct dentry
 			   bool preserve)
 {
 	int ret;
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	struct buffer_head *new_bh = NULL;
 
 	if (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SYSTEM_FILE) {
@@ -4289,7 +4289,7 @@ static int ocfs2_reflink(struct dentry *
 			 struct dentry *new_dentry, bool preserve)
 {
 	int error;
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	struct buffer_head *old_bh = NULL;
 	struct inode *new_orphan_inode = NULL;
 
@@ -4361,7 +4361,7 @@ out:
 /* copied from may_create in VFS. */
 static inline int ocfs2_may_create(struct inode *dir, struct dentry *child)
 {
-	if (child->d_inode)
+	if (d_inode(child))
 		return -EEXIST;
 	if (IS_DEADDIR(dir))
 		return -ENOENT;
@@ -4398,7 +4398,7 @@ static int ocfs2_user_path_parent(const
 static int ocfs2_vfs_reflink(struct dentry *old_dentry, struct inode *dir,
 			     struct dentry *new_dentry, bool preserve)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	int error;
 
 	if (!inode)
@@ -4497,13 +4497,13 @@ int ocfs2_reflink_ioctl(struct inode *in
 	}
 
 	error = ocfs2_vfs_reflink(old_path.dentry,
-				  nd.path.dentry->d_inode,
+				  d_inode(nd.path.dentry),
 				  new_dentry, preserve);
 	mnt_drop_write(nd.path.mnt);
 out_dput:
 	dput(new_dentry);
 out_unlock:
-	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(nd.path.dentry)->i_mutex);
 out_release:
 	path_put(&nd.path);
 	putname(to);
diff -u -p a/compat_ioctl.c b/compat_ioctl.c
--- a/compat_ioctl.c
+++ b/compat_ioctl.c
@@ -1595,7 +1595,7 @@ asmlinkage long compat_sys_ioctl(unsigne
 	case FIBMAP:
 	case FIGETBSZ:
 	case FIONREAD:
-		if (S_ISREG(filp->f_path.dentry->d_inode->i_mode))
+		if (S_ISREG(d_inode(filp->f_path.dentry)->i_mode))
 			break;
 		/*FALL THROUGH*/
 
diff -u -p a/ext2/symlink.c b/ext2/symlink.c
--- a/ext2/symlink.c
+++ b/ext2/symlink.c
@@ -23,7 +23,7 @@
 
 static void *ext2_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct ext2_inode_info *ei = EXT2_I(dentry->d_inode);
+	struct ext2_inode_info *ei = EXT2_I(d_inode(dentry));
 	nd_set_link(nd, (char *)ei->i_data);
 	return NULL;
 }
diff -u -p a/ext2/xattr_user.c b/ext2/xattr_user.c
--- a/ext2/xattr_user.c
+++ b/ext2/xattr_user.c
@@ -37,7 +37,7 @@ ext2_xattr_user_get(struct dentry *dentr
 		return -EINVAL;
 	if (!test_opt(dentry->d_sb, XATTR_USER))
 		return -EOPNOTSUPP;
-	return ext2_xattr_get(dentry->d_inode, EXT2_XATTR_INDEX_USER,
+	return ext2_xattr_get(d_inode(dentry), EXT2_XATTR_INDEX_USER,
 			      name, buffer, size);
 }
 
@@ -50,7 +50,7 @@ ext2_xattr_user_set(struct dentry *dentr
 	if (!test_opt(dentry->d_sb, XATTR_USER))
 		return -EOPNOTSUPP;
 
-	return ext2_xattr_set(dentry->d_inode, EXT2_XATTR_INDEX_USER,
+	return ext2_xattr_set(d_inode(dentry), EXT2_XATTR_INDEX_USER,
 			      name, value, size, flags);
 }
 
diff -u -p a/ext2/inode.c b/ext2/inode.c
--- a/ext2/inode.c
+++ b/ext2/inode.c
@@ -1523,7 +1523,7 @@ int ext2_write_inode(struct inode *inode
 
 int ext2_setattr(struct dentry *dentry, struct iattr *iattr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	error = inode_change_ok(inode, iattr);
diff -u -p a/ext2/namei.c b/ext2/namei.c
--- a/ext2/namei.c
+++ b/ext2/namei.c
@@ -84,10 +84,10 @@ static struct dentry *ext2_lookup(struct
 struct dentry *ext2_get_parent(struct dentry *child)
 {
 	struct qstr dotdot = {.name = "..", .len = 2};
-	unsigned long ino = ext2_inode_by_name(child->d_inode, &dotdot);
+	unsigned long ino = ext2_inode_by_name(d_inode(child), &dotdot);
 	if (!ino)
 		return ERR_PTR(-ENOENT);
-	return d_obtain_alias(ext2_iget(child->d_inode->i_sb, ino));
+	return d_obtain_alias(ext2_iget(d_inode(child)->i_sb, ino));
 } 
 
 /*
@@ -196,7 +196,7 @@ out_fail:
 static int ext2_link (struct dentry * old_dentry, struct inode * dir,
 	struct dentry *dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	int err;
 
 	if (inode->i_nlink >= EXT2_LINK_MAX)
@@ -269,7 +269,7 @@ out_dir:
 
 static int ext2_unlink(struct inode * dir, struct dentry *dentry)
 {
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	struct ext2_dir_entry_2 * de;
 	struct page * page;
 	int err = -ENOENT;
@@ -293,7 +293,7 @@ out:
 
 static int ext2_rmdir (struct inode * dir, struct dentry *dentry)
 {
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	int err = -ENOTEMPTY;
 
 	if (ext2_empty_dir(inode)) {
@@ -310,8 +310,8 @@ static int ext2_rmdir (struct inode * di
 static int ext2_rename (struct inode * old_dir, struct dentry * old_dentry,
 	struct inode * new_dir,	struct dentry * new_dentry )
 {
-	struct inode * old_inode = old_dentry->d_inode;
-	struct inode * new_inode = new_dentry->d_inode;
+	struct inode * old_inode = d_inode(old_dentry);
+	struct inode * new_inode = d_inode(new_dentry);
 	struct page * dir_page = NULL;
 	struct ext2_dir_entry_2 * dir_de = NULL;
 	struct page * old_page;
diff -u -p a/ext2/ialloc.c b/ext2/ialloc.c
--- a/ext2/ialloc.c
+++ b/ext2/ialloc.c
@@ -280,7 +280,7 @@ static int find_group_orlov(struct super
 	avefreeb = free_blocks / ngroups;
 	ndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);
 
-	if ((parent == sb->s_root->d_inode) ||
+	if ((parent == d_inode(sb->s_root)) ||
 	    (EXT2_I(parent)->i_flags & EXT2_TOPDIR_FL)) {
 		struct ext2_group_desc *best_desc = NULL;
 		int best_ndir = inodes_per_group;
diff -u -p a/ext2/dir.c b/ext2/dir.c
--- a/ext2/dir.c
+++ b/ext2/dir.c
@@ -290,7 +290,7 @@ static int
 ext2_readdir (struct file * filp, void * dirent, filldir_t filldir)
 {
 	loff_t pos = filp->f_pos;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct super_block *sb = inode->i_sb;
 	unsigned int offset = pos & ~PAGE_CACHE_MASK;
 	unsigned long n = pos >> PAGE_CACHE_SHIFT;
@@ -489,7 +489,7 @@ void ext2_set_link(struct inode *dir, st
  */
 int ext2_add_link (struct dentry *dentry, struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	const char *name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
 	unsigned chunk_size = ext2_chunk_size(dir);
diff -u -p a/ext2/ioctl.c b/ext2/ioctl.c
--- a/ext2/ioctl.c
+++ b/ext2/ioctl.c
@@ -19,7 +19,7 @@
 
 long ext2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = filp->f_dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_dentry);
 	struct ext2_inode_info *ei = EXT2_I(inode);
 	unsigned int flags;
 	unsigned short rsv_window_size;
diff -u -p a/ext2/xattr_trusted.c b/ext2/xattr_trusted.c
--- a/ext2/xattr_trusted.c
+++ b/ext2/xattr_trusted.c
@@ -36,7 +36,7 @@ ext2_xattr_trusted_get(struct dentry *de
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext2_xattr_get(dentry->d_inode, EXT2_XATTR_INDEX_TRUSTED, name,
+	return ext2_xattr_get(d_inode(dentry), EXT2_XATTR_INDEX_TRUSTED, name,
 			      buffer, size);
 }
 
@@ -46,7 +46,7 @@ ext2_xattr_trusted_set(struct dentry *de
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext2_xattr_set(dentry->d_inode, EXT2_XATTR_INDEX_TRUSTED, name,
+	return ext2_xattr_set(d_inode(dentry), EXT2_XATTR_INDEX_TRUSTED, name,
 			      value, size, flags);
 }
 
diff -u -p a/ext2/acl.c b/ext2/acl.c
--- a/ext2/acl.c
+++ b/ext2/acl.c
@@ -384,7 +384,7 @@ ext2_xattr_get_acl(struct dentry *dentry
 	if (!test_opt(dentry->d_sb, POSIX_ACL))
 		return -EOPNOTSUPP;
 
-	acl = ext2_get_acl(dentry->d_inode, type);
+	acl = ext2_get_acl(d_inode(dentry), type);
 	if (IS_ERR(acl))
 		return PTR_ERR(acl);
 	if (acl == NULL)
@@ -406,7 +406,7 @@ ext2_xattr_set_acl(struct dentry *dentry
 		return -EINVAL;
 	if (!test_opt(dentry->d_sb, POSIX_ACL))
 		return -EOPNOTSUPP;
-	if (!inode_owner_or_capable(dentry->d_inode))
+	if (!inode_owner_or_capable(d_inode(dentry)))
 		return -EPERM;
 
 	if (value) {
@@ -421,7 +421,7 @@ ext2_xattr_set_acl(struct dentry *dentry
 	} else
 		acl = NULL;
 
-	error = ext2_set_acl(dentry->d_inode, type, acl);
+	error = ext2_set_acl(d_inode(dentry), type, acl);
 
 release_and_out:
 	posix_acl_release(acl);
diff -u -p a/ext2/xattr.c b/ext2/xattr.c
--- a/ext2/xattr.c
+++ b/ext2/xattr.c
@@ -244,7 +244,7 @@ cleanup:
 static int
 ext2_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct buffer_head *bh = NULL;
 	struct ext2_xattr_entry *entry;
 	char *end;
diff -u -p a/ext2/xattr_security.c b/ext2/xattr_security.c
--- a/ext2/xattr_security.c
+++ b/ext2/xattr_security.c
@@ -32,7 +32,8 @@ ext2_xattr_security_get(struct dentry *d
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext2_xattr_get(dentry->d_inode, EXT2_XATTR_INDEX_SECURITY, name,
+	return ext2_xattr_get(d_inode(dentry), EXT2_XATTR_INDEX_SECURITY,
+			      name,
 			      buffer, size);
 }
 
@@ -42,7 +43,8 @@ ext2_xattr_security_set(struct dentry *d
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext2_xattr_set(dentry->d_inode, EXT2_XATTR_INDEX_SECURITY, name,
+	return ext2_xattr_set(d_inode(dentry), EXT2_XATTR_INDEX_SECURITY,
+			      name,
 			      value, size, flags);
 }
 
diff -u -p a/notify/fsnotify.c b/notify/fsnotify.c
--- a/notify/fsnotify.c
+++ b/notify/fsnotify.c
@@ -70,7 +70,7 @@ void __fsnotify_update_child_dentry_flag
 		 * original inode) */
 		spin_lock(&alias->d_lock);
 		list_for_each_entry(child, &alias->d_subdirs, d_u.d_child) {
-			if (!child->d_inode)
+			if (!d_inode(child))
 				continue;
 
 			spin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);
@@ -99,7 +99,7 @@ int __fsnotify_parent(struct path *path,
 		return 0;
 
 	parent = dget_parent(dentry);
-	p_inode = parent->d_inode;
+	p_inode = d_inode(parent);
 
 	if (unlikely(!fsnotify_inode_watches_children(p_inode)))
 		__fsnotify_update_child_dentry_flags(p_inode);
@@ -112,7 +112,8 @@ int __fsnotify_parent(struct path *path,
 			ret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,
 				       dentry->d_name.name, 0);
 		else
-			ret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,
+			ret = fsnotify(p_inode, mask, d_inode(dentry),
+				       FSNOTIFY_EVENT_INODE,
 				       dentry->d_name.name, 0);
 	}
 
diff -u -p a/notify/fanotify/fanotify.c b/notify/fanotify/fanotify.c
--- a/notify/fanotify/fanotify.c
+++ b/notify/fanotify/fanotify.c
@@ -176,8 +176,8 @@ static bool fanotify_should_send_event(s
 		return false;
 
 	/* sorry, fanotify only gives a damn about files and dirs */
-	if (!S_ISREG(path->dentry->d_inode->i_mode) &&
-	    !S_ISDIR(path->dentry->d_inode->i_mode))
+	if (!S_ISREG(d_inode(path->dentry)->i_mode) &&
+	    !S_ISDIR(d_inode(path->dentry)->i_mode))
 		return false;
 
 	if (inode_mark && vfsmnt_mark) {
@@ -200,7 +200,7 @@ static bool fanotify_should_send_event(s
 		BUG();
 	}
 
-	if (S_ISDIR(path->dentry->d_inode->i_mode) &&
+	if (S_ISDIR(d_inode(path->dentry)->i_mode) &&
 	    (marks_ignored_mask & FS_ISDIR))
 		return false;
 
diff -u -p a/notify/fanotify/fanotify_user.c b/notify/fanotify/fanotify_user.c
--- a/notify/fanotify/fanotify_user.c
+++ b/notify/fanotify/fanotify_user.c
@@ -482,7 +482,7 @@ static int fanotify_find_path(int dfd, c
 
 		ret = -ENOTDIR;
 		if ((flags & FAN_MARK_ONLYDIR) &&
-		    !(S_ISDIR(file->f_path.dentry->d_inode->i_mode))) {
+		    !(S_ISDIR(d_inode(file->f_path.dentry)->i_mode))) {
 			fput_light(file, fput_needed);
 			goto out;
 		}
@@ -504,7 +504,7 @@ static int fanotify_find_path(int dfd, c
 	}
 
 	/* you can only watch an inode if you have read permissions on it */
-	ret = inode_permission(path->dentry->d_inode, MAY_READ);
+	ret = inode_permission(d_inode(path->dentry), MAY_READ);
 	if (ret)
 		path_put(path);
 out:
diff -u -p a/notify/inotify/inotify_user.c b/notify/inotify/inotify_user.c
--- a/notify/inotify/inotify_user.c
+++ b/notify/inotify/inotify_user.c
@@ -356,7 +356,7 @@ static int inotify_find_inode(const char
 	if (error)
 		return error;
 	/* you can only watch an inode if you have read permissions on it */
-	error = inode_permission(path->dentry->d_inode, MAY_READ);
+	error = inode_permission(d_inode(path->dentry), MAY_READ);
 	if (error)
 		path_put(path);
 	return error;
@@ -781,7 +781,7 @@ SYSCALL_DEFINE3(inotify_add_watch, int,
 		goto fput_and_out;
 
 	/* inode held in place by reference to path; group by fget on fd */
-	inode = path.dentry->d_inode;
+	inode = d_inode(path.dentry);
 	group = filp->private_data;
 
 	/* create/update an inode mark */
diff -u -p a/notify/dnotify/dnotify.c b/notify/dnotify/dnotify.c
--- a/notify/dnotify/dnotify.c
+++ b/notify/dnotify/dnotify.c
@@ -174,7 +174,7 @@ void dnotify_flush(struct file *filp, fl
 	struct dnotify_struct **prev;
 	struct inode *inode;
 
-	inode = filp->f_path.dentry->d_inode;
+	inode = d_inode(filp->f_path.dentry);
 	if (!S_ISDIR(inode->i_mode))
 		return;
 
@@ -296,7 +296,7 @@ int fcntl_dirnotify(int fd, struct file
 	}
 
 	/* dnotify only works on directories */
-	inode = filp->f_path.dentry->d_inode;
+	inode = d_inode(filp->f_path.dentry);
 	if (!S_ISDIR(inode->i_mode)) {
 		error = -ENOTDIR;
 		goto out_err;
diff -u -p a/ntfs/inode.c b/ntfs/inode.c
--- a/ntfs/inode.c
+++ b/ntfs/inode.c
@@ -2892,7 +2892,7 @@ void ntfs_truncate_vfs(struct inode *vi)
  */
 int ntfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *vi = dentry->d_inode;
+	struct inode *vi = d_inode(dentry);
 	int err;
 	unsigned int ia_valid = attr->ia_valid;
 
diff -u -p a/ntfs/namei.c b/ntfs/namei.c
--- a/ntfs/namei.c
+++ b/ntfs/namei.c
@@ -299,7 +299,7 @@ const struct inode_operations ntfs_dir_i
  */
 static struct dentry *ntfs_get_parent(struct dentry *child_dent)
 {
-	struct inode *vi = child_dent->d_inode;
+	struct inode *vi = d_inode(child_dent);
 	ntfs_inode *ni = NTFS_I(vi);
 	MFT_RECORD *mrec;
 	ntfs_attr_search_ctx *ctx;
diff -u -p a/ntfs/dir.c b/ntfs/dir.c
--- a/ntfs/dir.c
+++ b/ntfs/dir.c
@@ -1101,7 +1101,7 @@ static int ntfs_readdir(struct file *fil
 {
 	s64 ia_pos, ia_start, prev_ia_pos, bmp_pos;
 	loff_t fpos, i_size;
-	struct inode *bmp_vi, *vdir = filp->f_path.dentry->d_inode;
+	struct inode *bmp_vi, *vdir = d_inode(filp->f_path.dentry);
 	struct super_block *sb = vdir->i_sb;
 	ntfs_inode *ndir = NTFS_I(vdir);
 	ntfs_volume *vol = NTFS_SB(sb);
diff -u -p a/open.c b/open.c
--- a/open.c
+++ b/open.c
@@ -55,9 +55,9 @@ int do_truncate(struct dentry *dentry, l
 	if (ret)
 		newattrs.ia_valid |= ret | ATTR_FORCE;
 
-	mutex_lock(&dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(dentry)->i_mutex);
 	ret = notify_change(dentry, &newattrs);
-	mutex_unlock(&dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dentry)->i_mutex);
 	return ret;
 }
 
@@ -74,7 +74,7 @@ static long do_sys_truncate(const char _
 	error = user_path(pathname, &path);
 	if (error)
 		goto out;
-	inode = path.dentry->d_inode;
+	inode = d_inode(path.dentry);
 
 	/* For directories it's -EISDIR, for other non-regulars - -EINVAL */
 	error = -EISDIR;
@@ -150,7 +150,7 @@ static long do_sys_ftruncate(unsigned in
 		small = 0;
 
 	dentry = file->f_path.dentry;
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	error = -EINVAL;
 	if (!S_ISREG(inode->i_mode) || !(file->f_mode & FMODE_WRITE))
 		goto out_putf;
@@ -216,7 +216,7 @@ SYSCALL_ALIAS(sys_ftruncate64, SyS_ftrun
 
 int do_fallocate(struct file *file, int mode, loff_t offset, loff_t len)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	long ret;
 
 	if (offset < 0 || len <= 0)
@@ -329,7 +329,7 @@ SYSCALL_DEFINE3(faccessat, int, dfd, con
 	if (res)
 		goto out;
 
-	inode = path.dentry->d_inode;
+	inode = d_inode(path.dentry);
 
 	if ((mode & MAY_EXEC) && S_ISREG(inode->i_mode)) {
 		/*
@@ -380,7 +380,7 @@ SYSCALL_DEFINE1(chdir, const char __user
 	if (error)
 		goto out;
 
-	error = inode_permission(path.dentry->d_inode, MAY_EXEC | MAY_CHDIR);
+	error = inode_permission(d_inode(path.dentry), MAY_EXEC | MAY_CHDIR);
 	if (error)
 		goto dput_and_out;
 
@@ -403,7 +403,7 @@ SYSCALL_DEFINE1(fchdir, unsigned int, fd
 	if (!file)
 		goto out;
 
-	inode = file->f_path.dentry->d_inode;
+	inode = d_inode(file->f_path.dentry);
 
 	error = -ENOTDIR;
 	if (!S_ISDIR(inode->i_mode))
@@ -427,7 +427,7 @@ SYSCALL_DEFINE1(chroot, const char __use
 	if (error)
 		goto out;
 
-	error = inode_permission(path.dentry->d_inode, MAY_EXEC | MAY_CHDIR);
+	error = inode_permission(d_inode(path.dentry), MAY_EXEC | MAY_CHDIR);
 	if (error)
 		goto dput_and_out;
 
@@ -459,7 +459,7 @@ SYSCALL_DEFINE2(fchmod, unsigned int, fd
 		goto out;
 
 	dentry = file->f_path.dentry;
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	audit_inode(NULL, dentry);
 
@@ -494,7 +494,7 @@ SYSCALL_DEFINE3(fchmodat, int, dfd, cons
 	error = user_path_at(dfd, filename, LOOKUP_FOLLOW, &path);
 	if (error)
 		goto out;
-	inode = path.dentry->d_inode;
+	inode = d_inode(path.dentry);
 
 	error = mnt_want_write(path.mnt);
 	if (error)
@@ -524,7 +524,7 @@ SYSCALL_DEFINE2(chmod, const char __user
 
 static int chown_common(struct path *path, uid_t user, gid_t group)
 {
-	struct inode *inode = path->dentry->d_inode;
+	struct inode *inode = d_inode(path->dentry);
 	int error;
 	struct iattr newattrs;
 
@@ -681,7 +681,7 @@ static struct file *__dentry_open(struct
 	if (unlikely(f->f_flags & O_PATH))
 		f->f_mode = FMODE_PATH;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	if (f->f_mode & FMODE_WRITE) {
 		error = __get_file_write_access(inode, mnt);
 		if (error)
@@ -982,7 +982,7 @@ struct file *file_open_root(struct dentr
 	if (flags & O_CREAT)
 		return ERR_PTR(-EINVAL);
 	if (!filename && (flags & O_DIRECTORY))
-		if (!dentry->d_inode->i_op->lookup)
+		if (!d_inode(dentry)->i_op->lookup)
 			return ERR_PTR(-ENOTDIR);
 	return do_file_open_root(dentry, mnt, filename, &op, lookup);
 }
diff -u -p a/jffs2/super.c b/jffs2/super.c
--- a/jffs2/super.c
+++ b/jffs2/super.c
@@ -115,16 +115,16 @@ static struct dentry *jffs2_get_parent(s
 	struct jffs2_inode_info *f;
 	uint32_t pino;
 
-	BUG_ON(!S_ISDIR(child->d_inode->i_mode));
+	BUG_ON(!S_ISDIR(d_inode(child)->i_mode));
 
-	f = JFFS2_INODE_INFO(child->d_inode);
+	f = JFFS2_INODE_INFO(d_inode(child));
 
 	pino = f->inocache->pino_nlink;
 
 	JFFS2_DEBUG("Parent of directory ino #%u is #%u\n",
 		    f->inocache->ino, pino);
 
-	return d_obtain_alias(jffs2_iget(child->d_inode->i_sb, pino));
+	return d_obtain_alias(jffs2_iget(d_inode(child)->i_sb, pino));
 }
 
 static const struct export_operations jffs2_export_ops = {
diff -u -p a/jffs2/security.c b/jffs2/security.c
--- a/jffs2/security.c
+++ b/jffs2/security.c
@@ -51,7 +51,7 @@ static int jffs2_security_getxattr(struc
 	if (!strcmp(name, ""))
 		return -EINVAL;
 
-	return do_jffs2_getxattr(dentry->d_inode, JFFS2_XPREFIX_SECURITY,
+	return do_jffs2_getxattr(d_inode(dentry), JFFS2_XPREFIX_SECURITY,
 				 name, buffer, size);
 }
 
@@ -61,7 +61,7 @@ static int jffs2_security_setxattr(struc
 	if (!strcmp(name, ""))
 		return -EINVAL;
 
-	return do_jffs2_setxattr(dentry->d_inode, JFFS2_XPREFIX_SECURITY,
+	return do_jffs2_setxattr(d_inode(dentry), JFFS2_XPREFIX_SECURITY,
 				 name, buffer, size, flags);
 }
 
diff -u -p a/jffs2/symlink.c b/jffs2/symlink.c
--- a/jffs2/symlink.c
+++ b/jffs2/symlink.c
@@ -30,7 +30,7 @@ const struct inode_operations jffs2_syml
 
 static void *jffs2_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct jffs2_inode_info *f = JFFS2_INODE_INFO(dentry->d_inode);
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(d_inode(dentry));
 	char *p = (char *)f->target;
 
 	/*
diff -u -p a/jffs2/xattr_user.c b/jffs2/xattr_user.c
--- a/jffs2/xattr_user.c
+++ b/jffs2/xattr_user.c
@@ -21,7 +21,7 @@ static int jffs2_user_getxattr(struct de
 {
 	if (!strcmp(name, ""))
 		return -EINVAL;
-	return do_jffs2_getxattr(dentry->d_inode, JFFS2_XPREFIX_USER,
+	return do_jffs2_getxattr(d_inode(dentry), JFFS2_XPREFIX_USER,
 				 name, buffer, size);
 }
 
@@ -30,7 +30,7 @@ static int jffs2_user_setxattr(struct de
 {
 	if (!strcmp(name, ""))
 		return -EINVAL;
-	return do_jffs2_setxattr(dentry->d_inode, JFFS2_XPREFIX_USER,
+	return do_jffs2_setxattr(d_inode(dentry), JFFS2_XPREFIX_USER,
 				 name, buffer, size, flags);
 }
 
diff -u -p a/jffs2/dir.c b/jffs2/dir.c
--- a/jffs2/dir.c
+++ b/jffs2/dir.c
@@ -117,7 +117,7 @@ static struct dentry *jffs2_lookup(struc
 static int jffs2_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
 	struct jffs2_inode_info *f;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct jffs2_full_dirent *fd;
 	unsigned long offset, curofs;
 
@@ -240,14 +240,14 @@ static int jffs2_unlink(struct inode *di
 {
 	struct jffs2_sb_info *c = JFFS2_SB_INFO(dir_i->i_sb);
 	struct jffs2_inode_info *dir_f = JFFS2_INODE_INFO(dir_i);
-	struct jffs2_inode_info *dead_f = JFFS2_INODE_INFO(dentry->d_inode);
+	struct jffs2_inode_info *dead_f = JFFS2_INODE_INFO(d_inode(dentry));
 	int ret;
 	uint32_t now = get_seconds();
 
 	ret = jffs2_do_unlink(c, dir_f, dentry->d_name.name,
 			      dentry->d_name.len, dead_f, now);
 	if (dead_f->inocache)
-		dentry->d_inode->i_nlink = dead_f->inocache->pino_nlink;
+		d_inode(dentry)->i_nlink = dead_f->inocache->pino_nlink;
 	if (!ret)
 		dir_i->i_mtime = dir_i->i_ctime = ITIME(now);
 	return ret;
@@ -257,8 +257,8 @@ static int jffs2_unlink(struct inode *di
 
 static int jffs2_link (struct dentry *old_dentry, struct inode *dir_i, struct dentry *dentry)
 {
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_dentry->d_inode->i_sb);
-	struct jffs2_inode_info *f = JFFS2_INODE_INFO(old_dentry->d_inode);
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(d_inode(old_dentry)->i_sb);
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(d_inode(old_dentry));
 	struct jffs2_inode_info *dir_f = JFFS2_INODE_INFO(dir_i);
 	int ret;
 	uint8_t type;
@@ -268,11 +268,11 @@ static int jffs2_link (struct dentry *ol
 	if (!f->inocache)
 		return -EIO;
 
-	if (S_ISDIR(old_dentry->d_inode->i_mode))
+	if (S_ISDIR(d_inode(old_dentry)->i_mode))
 		return -EPERM;
 
 	/* XXX: This is ugly */
-	type = (old_dentry->d_inode->i_mode & S_IFMT) >> 12;
+	type = (d_inode(old_dentry)->i_mode & S_IFMT) >> 12;
 	if (!type) type = DT_REG;
 
 	now = get_seconds();
@@ -280,11 +280,11 @@ static int jffs2_link (struct dentry *ol
 
 	if (!ret) {
 		mutex_lock(&f->sem);
-		old_dentry->d_inode->i_nlink = ++f->inocache->pino_nlink;
+		d_inode(old_dentry)->i_nlink = ++f->inocache->pino_nlink;
 		mutex_unlock(&f->sem);
-		d_instantiate(dentry, old_dentry->d_inode);
+		d_instantiate(dentry, d_inode(old_dentry));
 		dir_i->i_mtime = dir_i->i_ctime = ITIME(now);
-		ihold(old_dentry->d_inode);
+		ihold(d_inode(old_dentry));
 	}
 	return ret;
 }
@@ -600,7 +600,7 @@ static int jffs2_rmdir (struct inode *di
 {
 	struct jffs2_sb_info *c = JFFS2_SB_INFO(dir_i->i_sb);
 	struct jffs2_inode_info *dir_f = JFFS2_INODE_INFO(dir_i);
-	struct jffs2_inode_info *f = JFFS2_INODE_INFO(dentry->d_inode);
+	struct jffs2_inode_info *f = JFFS2_INODE_INFO(d_inode(dentry));
 	struct jffs2_full_dirent *fd;
 	int ret;
 	uint32_t now = get_seconds();
@@ -614,7 +614,7 @@ static int jffs2_rmdir (struct inode *di
 			      dentry->d_name.len, f, now);
 	if (!ret) {
 		dir_i->i_mtime = dir_i->i_ctime = ITIME(now);
-		clear_nlink(dentry->d_inode);
+		clear_nlink(d_inode(dentry));
 		drop_nlink(dir_i);
 	}
 	return ret;
@@ -785,9 +785,9 @@ static int jffs2_rename (struct inode *o
 	 * the VFS can't check whether the victim is empty. The filesystem
 	 * needs to do that for itself.
 	 */
-	if (new_dentry->d_inode) {
-		victim_f = JFFS2_INODE_INFO(new_dentry->d_inode);
-		if (S_ISDIR(new_dentry->d_inode->i_mode)) {
+	if (d_inode(new_dentry)) {
+		victim_f = JFFS2_INODE_INFO(d_inode(new_dentry));
+		if (S_ISDIR(d_inode(new_dentry)->i_mode)) {
 			struct jffs2_full_dirent *fd;
 
 			mutex_lock(&victim_f->sem);
@@ -809,12 +809,12 @@ static int jffs2_rename (struct inode *o
 	/* Make a hard link */
 
 	/* XXX: This is ugly */
-	type = (old_dentry->d_inode->i_mode & S_IFMT) >> 12;
+	type = (d_inode(old_dentry)->i_mode & S_IFMT) >> 12;
 	if (!type) type = DT_REG;
 
 	now = get_seconds();
 	ret = jffs2_do_link(c, JFFS2_INODE_INFO(new_dir_i),
-			    old_dentry->d_inode->i_ino, type,
+			    d_inode(old_dentry)->i_ino, type,
 			    new_dentry->d_name.name, new_dentry->d_name.len, now);
 
 	if (ret)
@@ -822,12 +822,12 @@ static int jffs2_rename (struct inode *o
 
 	if (victim_f) {
 		/* There was a victim. Kill it off nicely */
-		drop_nlink(new_dentry->d_inode);
+		drop_nlink(d_inode(new_dentry));
 		/* Don't oops if the victim was a dirent pointing to an
 		   inode which didn't exist. */
 		if (victim_f->inocache) {
 			mutex_lock(&victim_f->sem);
-			if (S_ISDIR(new_dentry->d_inode->i_mode))
+			if (S_ISDIR(d_inode(new_dentry)->i_mode))
 				victim_f->inocache->pino_nlink = 0;
 			else
 				victim_f->inocache->pino_nlink--;
@@ -837,7 +837,7 @@ static int jffs2_rename (struct inode *o
 
 	/* If it was a directory we moved, and there was no victim,
 	   increase i_nlink on its new parent */
-	if (S_ISDIR(old_dentry->d_inode->i_mode) && !victim_f)
+	if (S_ISDIR(d_inode(old_dentry)->i_mode) && !victim_f)
 		inc_nlink(new_dir_i);
 
 	/* Unlink the original */
@@ -848,22 +848,22 @@ static int jffs2_rename (struct inode *o
 
 	if (ret) {
 		/* Oh shit. We really ought to make a single node which can do both atomically */
-		struct jffs2_inode_info *f = JFFS2_INODE_INFO(old_dentry->d_inode);
+		struct jffs2_inode_info *f = JFFS2_INODE_INFO(d_inode(old_dentry));
 		mutex_lock(&f->sem);
-		inc_nlink(old_dentry->d_inode);
-		if (f->inocache && !S_ISDIR(old_dentry->d_inode->i_mode))
+		inc_nlink(d_inode(old_dentry));
+		if (f->inocache && !S_ISDIR(d_inode(old_dentry)->i_mode))
 			f->inocache->pino_nlink++;
 		mutex_unlock(&f->sem);
 
 		printk(KERN_NOTICE "jffs2_rename(): Link succeeded, unlink failed (err %d). You now have a hard link\n", ret);
 		/* Might as well let the VFS know */
-		d_instantiate(new_dentry, old_dentry->d_inode);
-		ihold(old_dentry->d_inode);
+		d_instantiate(new_dentry, d_inode(old_dentry));
+		ihold(d_inode(old_dentry));
 		new_dir_i->i_mtime = new_dir_i->i_ctime = ITIME(now);
 		return ret;
 	}
 
-	if (S_ISDIR(old_dentry->d_inode->i_mode))
+	if (S_ISDIR(d_inode(old_dentry)->i_mode))
 		drop_nlink(old_dir_i);
 
 	new_dir_i->i_mtime = new_dir_i->i_ctime = old_dir_i->i_mtime = old_dir_i->i_ctime = ITIME(now);
diff -u -p a/jffs2/xattr_trusted.c b/jffs2/xattr_trusted.c
--- a/jffs2/xattr_trusted.c
+++ b/jffs2/xattr_trusted.c
@@ -21,7 +21,7 @@ static int jffs2_trusted_getxattr(struct
 {
 	if (!strcmp(name, ""))
 		return -EINVAL;
-	return do_jffs2_getxattr(dentry->d_inode, JFFS2_XPREFIX_TRUSTED,
+	return do_jffs2_getxattr(d_inode(dentry), JFFS2_XPREFIX_TRUSTED,
 				 name, buffer, size);
 }
 
@@ -30,7 +30,7 @@ static int jffs2_trusted_setxattr(struct
 {
 	if (!strcmp(name, ""))
 		return -EINVAL;
-	return do_jffs2_setxattr(dentry->d_inode, JFFS2_XPREFIX_TRUSTED,
+	return do_jffs2_setxattr(d_inode(dentry), JFFS2_XPREFIX_TRUSTED,
 				 name, buffer, size, flags);
 }
 
diff -u -p a/jffs2/acl.c b/jffs2/acl.c
--- a/jffs2/acl.c
+++ b/jffs2/acl.c
@@ -383,7 +383,7 @@ static int jffs2_acl_getxattr(struct den
 	if (name[0] != '\0')
 		return -EINVAL;
 
-	acl = jffs2_get_acl(dentry->d_inode, type);
+	acl = jffs2_get_acl(d_inode(dentry), type);
 	if (IS_ERR(acl))
 		return PTR_ERR(acl);
 	if (!acl)
@@ -402,7 +402,7 @@ static int jffs2_acl_setxattr(struct den
 
 	if (name[0] != '\0')
 		return -EINVAL;
-	if (!inode_owner_or_capable(dentry->d_inode))
+	if (!inode_owner_or_capable(d_inode(dentry)))
 		return -EPERM;
 
 	if (value) {
@@ -417,7 +417,7 @@ static int jffs2_acl_setxattr(struct den
 	} else {
 		acl = NULL;
 	}
-	rc = jffs2_set_acl(dentry->d_inode, type, acl);
+	rc = jffs2_set_acl(d_inode(dentry), type, acl);
  out:
 	posix_acl_release(acl);
 	return rc;
diff -u -p a/jffs2/xattr.c b/jffs2/xattr.c
--- a/jffs2/xattr.c
+++ b/jffs2/xattr.c
@@ -949,7 +949,7 @@ static const struct xattr_handler *xpref
 
 ssize_t jffs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
 	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
 	struct jffs2_inode_cache *ic = f->inocache;
diff -u -p a/jffs2/fs.c b/jffs2/fs.c
--- a/jffs2/fs.c
+++ b/jffs2/fs.c
@@ -186,13 +186,13 @@ int jffs2_setattr(struct dentry *dentry,
 {
 	int rc;
 
-	rc = inode_change_ok(dentry->d_inode, iattr);
+	rc = inode_change_ok(d_inode(dentry), iattr);
 	if (rc)
 		return rc;
 
-	rc = jffs2_do_setattr(dentry->d_inode, iattr);
+	rc = jffs2_do_setattr(d_inode(dentry), iattr);
 	if (!rc && (iattr->ia_valid & ATTR_MODE))
-		rc = jffs2_acl_chmod(dentry->d_inode);
+		rc = jffs2_acl_chmod(d_inode(dentry));
 
 	return rc;
 }
diff -u -p a/stat.c b/stat.c
--- a/stat.c
+++ b/stat.c
@@ -39,7 +39,7 @@ EXPORT_SYMBOL(generic_fillattr);
 
 int vfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int retval;
 
 	retval = security_inode_getattr(mnt, dentry);
@@ -302,7 +302,7 @@ SYSCALL_DEFINE4(readlinkat, int, dfd, co
 
 	error = user_path_at(dfd, pathname, LOOKUP_EMPTY, &path);
 	if (!error) {
-		struct inode *inode = path.dentry->d_inode;
+		struct inode *inode = d_inode(path.dentry);
 
 		error = -EINVAL;
 		if (inode->i_op->readlink) {
diff -u -p a/nilfs2/super.c b/nilfs2/super.c
--- a/nilfs2/super.c
+++ b/nilfs2/super.c
@@ -604,7 +604,7 @@ static int nilfs_unfreeze(struct super_b
 static int nilfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct super_block *sb = dentry->d_sb;
-	struct nilfs_root *root = NILFS_I(dentry->d_inode)->i_root;
+	struct nilfs_root *root = NILFS_I(d_inode(dentry))->i_root;
 	struct the_nilfs *nilfs = root->nilfs;
 	u64 id = huge_encode_dev(sb->s_bdev->bd_dev);
 	unsigned long long blocks;
@@ -654,7 +654,7 @@ static int nilfs_show_options(struct seq
 {
 	struct super_block *sb = vfs->mnt_sb;
 	struct the_nilfs *nilfs = sb->s_fs_info;
-	struct nilfs_root *root = NILFS_I(vfs->mnt_root->d_inode)->i_root;
+	struct nilfs_root *root = NILFS_I(d_inode(vfs->mnt_root))->i_root;
 
 	if (!nilfs_test_opt(nilfs, BARRIER))
 		seq_puts(seq, ",nobarrier");
@@ -1176,7 +1176,7 @@ static int nilfs_remount(struct super_bl
 
 		sb->s_flags &= ~MS_RDONLY;
 
-		root = NILFS_I(sb->s_root->d_inode)->i_root;
+		root = NILFS_I(d_inode(sb->s_root))->i_root;
 		err = nilfs_attach_log_writer(sb, root);
 		if (err)
 			goto restore_opts;
diff -u -p a/nilfs2/inode.c b/nilfs2/inode.c
--- a/nilfs2/inode.c
+++ b/nilfs2/inode.c
@@ -764,7 +764,7 @@ void nilfs_evict_inode(struct inode *ino
 int nilfs_setattr(struct dentry *dentry, struct iattr *iattr)
 {
 	struct nilfs_transaction_info ti;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct super_block *sb = inode->i_sb;
 	int err;
 
diff -u -p a/nilfs2/file.c b/nilfs2/file.c
--- a/nilfs2/file.c
+++ b/nilfs2/file.c
@@ -55,7 +55,7 @@ int nilfs_sync_file(struct file *file, i
 static int nilfs_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)
 {
 	struct page *page = vmf->page;
-	struct inode *inode = vma->vm_file->f_dentry->d_inode;
+	struct inode *inode = d_inode(vma->vm_file->f_dentry);
 	struct nilfs_transaction_info ti;
 	int ret;
 
diff -u -p a/nilfs2/namei.c b/nilfs2/namei.c
--- a/nilfs2/namei.c
+++ b/nilfs2/namei.c
@@ -194,7 +194,7 @@ out_fail:
 static int nilfs_link(struct dentry *old_dentry, struct inode *dir,
 		      struct dentry *dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	struct nilfs_transaction_info ti;
 	int err;
 
@@ -285,7 +285,7 @@ static int nilfs_do_unlink(struct inode
 	if (!de)
 		goto out;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	err = -EIO;
 	if (le64_to_cpu(de->inode) != inode->i_ino)
 		goto out;
@@ -320,7 +320,7 @@ static int nilfs_unlink(struct inode *di
 
 	if (!err) {
 		nilfs_mark_inode_dirty(dir);
-		nilfs_mark_inode_dirty(dentry->d_inode);
+		nilfs_mark_inode_dirty(d_inode(dentry));
 		err = nilfs_transaction_commit(dir->i_sb);
 	} else
 		nilfs_transaction_abort(dir->i_sb);
@@ -330,7 +330,7 @@ static int nilfs_unlink(struct inode *di
 
 static int nilfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct nilfs_transaction_info ti;
 	int err;
 
@@ -360,8 +360,8 @@ static int nilfs_rmdir(struct inode *dir
 static int nilfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 			struct inode *new_dir,	struct dentry *new_dentry)
 {
-	struct inode *old_inode = old_dentry->d_inode;
-	struct inode *new_inode = new_dentry->d_inode;
+	struct inode *old_inode = d_inode(old_dentry);
+	struct inode *new_inode = d_inode(new_dentry);
 	struct page *dir_page = NULL;
 	struct nilfs_dir_entry *dir_de = NULL;
 	struct page *old_page;
@@ -460,13 +460,13 @@ static struct dentry *nilfs_get_parent(s
 	struct qstr dotdot = {.name = "..", .len = 2};
 	struct nilfs_root *root;
 
-	ino = nilfs_inode_by_name(child->d_inode, &dotdot);
+	ino = nilfs_inode_by_name(d_inode(child), &dotdot);
 	if (!ino)
 		return ERR_PTR(-ENOENT);
 
-	root = NILFS_I(child->d_inode)->i_root;
+	root = NILFS_I(d_inode(child))->i_root;
 
-	inode = nilfs_iget(child->d_inode->i_sb, root, ino);
+	inode = nilfs_iget(d_inode(child)->i_sb, root, ino);
 	if (IS_ERR(inode))
 		return ERR_CAST(inode);
 
@@ -528,7 +528,7 @@ static int nilfs_encode_fh(struct dentry
 			   int connectable)
 {
 	struct nilfs_fid *fid = (struct nilfs_fid *)fh;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct nilfs_root *root = NILFS_I(inode)->i_root;
 	int type;
 
@@ -544,7 +544,7 @@ static int nilfs_encode_fh(struct dentry
 		struct inode *parent;
 
 		spin_lock(&dentry->d_lock);
-		parent = dentry->d_parent->d_inode;
+		parent = d_inode(dentry->d_parent);
 		fid->parent_ino = parent->i_ino;
 		fid->parent_gen = parent->i_generation;
 		spin_unlock(&dentry->d_lock);
diff -u -p a/nilfs2/dir.c b/nilfs2/dir.c
--- a/nilfs2/dir.c
+++ b/nilfs2/dir.c
@@ -259,7 +259,7 @@ static void nilfs_set_de_type(struct nil
 static int nilfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
 	loff_t pos = filp->f_pos;
-	struct inode *inode = filp->f_dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_dentry);
 	struct super_block *sb = inode->i_sb;
 	unsigned int offset = pos & ~PAGE_CACHE_MASK;
 	unsigned long n = pos >> PAGE_CACHE_SHIFT;
@@ -447,7 +447,7 @@ void nilfs_set_link(struct inode *dir, s
  */
 int nilfs_add_link(struct dentry *dentry, struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	const unsigned char *name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
 	unsigned chunk_size = nilfs_chunk_size(dir);
diff -u -p a/nilfs2/ioctl.c b/nilfs2/ioctl.c
--- a/nilfs2/ioctl.c
+++ b/nilfs2/ioctl.c
@@ -784,7 +784,7 @@ static int nilfs_ioctl_get_info(struct i
 
 long nilfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = filp->f_dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_dentry);
 	void __user *argp = (void __user *)arg;
 
 	switch (cmd) {
diff -u -p a/hugetlbfs/inode.c b/hugetlbfs/inode.c
--- a/hugetlbfs/inode.c
+++ b/hugetlbfs/inode.c
@@ -78,7 +78,7 @@ static void huge_pagevec_release(struct
 
 static int hugetlbfs_file_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	loff_t len, vma_len;
 	int ret;
 	struct hstate *h = hstate_file(file);
@@ -422,7 +422,7 @@ static int hugetlb_vmtruncate(struct ino
 
 static int hugetlbfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct hstate *h = hstate_inode(inode);
 	int error;
 	unsigned int ia_valid = attr->ia_valid;
@@ -590,7 +590,7 @@ static int hugetlbfs_migrate_page(struct
 static int hugetlbfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(dentry->d_sb);
-	struct hstate *h = hstate_inode(dentry->d_inode);
+	struct hstate *h = hstate_inode(d_inode(dentry));
 
 	buf->f_type = HUGETLBFS_MAGIC;
 	buf->f_bsize = huge_page_size(h);
diff -u -p a/adfs/inode.c b/adfs/inode.c
--- a/adfs/inode.c
+++ b/adfs/inode.c
@@ -293,7 +293,7 @@ out:
 int
 adfs_notify_change(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct super_block *sb = inode->i_sb;
 	unsigned int ia_valid = attr->ia_valid;
 	int error;
diff -u -p a/adfs/dir.c b/adfs/dir.c
--- a/adfs/dir.c
+++ b/adfs/dir.c
@@ -19,7 +19,7 @@ static DEFINE_RWLOCK(adfs_dir_lock);
 static int
 adfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct super_block *sb = inode->i_sb;
 	struct adfs_dir_ops *ops = ADFS_SB(sb)->s_dir;
 	struct object_info obj;
diff -u -p a/debugfs/inode.c b/debugfs/inode.c
--- a/debugfs/inode.c
+++ b/debugfs/inode.c
@@ -75,7 +75,7 @@ static int debugfs_mknod(struct inode *d
 	struct inode *inode;
 	int error = -EPERM;
 
-	if (dentry->d_inode)
+	if (d_inode(dentry))
 		return -EEXIST;
 
 	inode = debugfs_get_inode(dir->i_sb, mode, dev, data, fops);
@@ -122,7 +122,7 @@ static int debugfs_create(struct inode *
 
 static inline int debugfs_positive(struct dentry *dentry)
 {
-	return dentry->d_inode && !d_unhashed(dentry);
+	return d_inode(dentry) && !d_unhashed(dentry);
 }
 
 static int debug_fill_super(struct super_block *sb, void *data, int silent)
@@ -163,27 +163,27 @@ static int debugfs_create_by_name(const
 		parent = debugfs_mount->mnt_sb->s_root;
 
 	*dentry = NULL;
-	mutex_lock(&parent->d_inode->i_mutex);
+	mutex_lock(&d_inode(parent)->i_mutex);
 	*dentry = lookup_one_len(name, parent, strlen(name));
 	if (!IS_ERR(*dentry)) {
 		switch (mode & S_IFMT) {
 		case S_IFDIR:
-			error = debugfs_mkdir(parent->d_inode, *dentry, mode,
+			error = debugfs_mkdir(d_inode(parent), *dentry, mode,
 					      data, fops);
 			break;
 		case S_IFLNK:
-			error = debugfs_link(parent->d_inode, *dentry, mode,
+			error = debugfs_link(d_inode(parent), *dentry, mode,
 					     data, fops);
 			break;
 		default:
-			error = debugfs_create(parent->d_inode, *dentry, mode,
+			error = debugfs_create(d_inode(parent), *dentry, mode,
 					       data, fops);
 			break;
 		}
 		dput(*dentry);
 	} else
 		error = PTR_ERR(*dentry);
-	mutex_unlock(&parent->d_inode->i_mutex);
+	mutex_unlock(&d_inode(parent)->i_mutex);
 
 	return error;
 }
@@ -312,17 +312,17 @@ static int __debugfs_remove(struct dentr
 	int ret = 0;
 
 	if (debugfs_positive(dentry)) {
-		if (dentry->d_inode) {
+		if (d_inode(dentry)) {
 			dget(dentry);
-			switch (dentry->d_inode->i_mode & S_IFMT) {
+			switch (d_inode(dentry)->i_mode & S_IFMT) {
 			case S_IFDIR:
-				ret = simple_rmdir(parent->d_inode, dentry);
+				ret = simple_rmdir(d_inode(parent), dentry);
 				break;
 			case S_IFLNK:
-				kfree(dentry->d_inode->i_private);
+				kfree(d_inode(dentry)->i_private);
 				/* fall through */
 			default:
-				simple_unlink(parent->d_inode, dentry);
+				simple_unlink(d_inode(parent), dentry);
 				break;
 			}
 			if (!ret)
@@ -355,12 +355,12 @@ void debugfs_remove(struct dentry *dentr
 		return;
 
 	parent = dentry->d_parent;
-	if (!parent || !parent->d_inode)
+	if (!parent || !d_inode(parent))
 		return;
 
-	mutex_lock(&parent->d_inode->i_mutex);
+	mutex_lock(&d_inode(parent)->i_mutex);
 	ret = __debugfs_remove(dentry, parent);
-	mutex_unlock(&parent->d_inode->i_mutex);
+	mutex_unlock(&d_inode(parent)->i_mutex);
 	if (!ret)
 		simple_release_fs(&debugfs_mount, &debugfs_mount_count);
 }
@@ -387,11 +387,11 @@ void debugfs_remove_recursive(struct den
 		return;
 
 	parent = dentry->d_parent;
-	if (!parent || !parent->d_inode)
+	if (!parent || !d_inode(parent))
 		return;
 
 	parent = dentry;
-	mutex_lock(&parent->d_inode->i_mutex);
+	mutex_lock(&d_inode(parent)->i_mutex);
 
 	while (1) {
 		/*
@@ -399,11 +399,11 @@ void debugfs_remove_recursive(struct den
 		 * walk up the tree until we reach our starting point.
 		 */
 		if (list_empty(&parent->d_subdirs)) {
-			mutex_unlock(&parent->d_inode->i_mutex);
+			mutex_unlock(&d_inode(parent)->i_mutex);
 			if (parent == dentry)
 				break;
 			parent = parent->d_parent;
-			mutex_lock(&parent->d_inode->i_mutex);
+			mutex_lock(&d_inode(parent)->i_mutex);
 		}
 		child = list_entry(parent->d_subdirs.next, struct dentry,
 				d_u.d_child);
@@ -414,9 +414,9 @@ void debugfs_remove_recursive(struct den
 		 * remove all its descendants first.
 		 */
 		if (!list_empty(&child->d_subdirs)) {
-			mutex_unlock(&parent->d_inode->i_mutex);
+			mutex_unlock(&d_inode(parent)->i_mutex);
 			parent = child;
-			mutex_lock(&parent->d_inode->i_mutex);
+			mutex_lock(&d_inode(parent)->i_mutex);
 			continue;
 		}
 		__debugfs_remove(child, parent);
@@ -435,16 +435,16 @@ void debugfs_remove_recursive(struct den
 			 * Avoid infinite loop if we fail to remove
 			 * one dentry.
 			 */
-			mutex_unlock(&parent->d_inode->i_mutex);
+			mutex_unlock(&d_inode(parent)->i_mutex);
 			break;
 		}
 		simple_release_fs(&debugfs_mount, &debugfs_mount_count);
 	}
 
 	parent = dentry->d_parent;
-	mutex_lock(&parent->d_inode->i_mutex);
+	mutex_lock(&d_inode(parent)->i_mutex);
 	__debugfs_remove(dentry, parent);
-	mutex_unlock(&parent->d_inode->i_mutex);
+	mutex_unlock(&d_inode(parent)->i_mutex);
 	simple_release_fs(&debugfs_mount, &debugfs_mount_count);
 }
 EXPORT_SYMBOL_GPL(debugfs_remove_recursive);
@@ -477,29 +477,29 @@ struct dentry *debugfs_rename(struct den
 
 	trap = lock_rename(new_dir, old_dir);
 	/* Source or destination directories don't exist? */
-	if (!old_dir->d_inode || !new_dir->d_inode)
+	if (!d_inode(old_dir) || !d_inode(new_dir))
 		goto exit;
 	/* Source does not exist, cyclic rename, or mountpoint? */
-	if (!old_dentry->d_inode || old_dentry == trap ||
+	if (!d_inode(old_dentry) || old_dentry == trap ||
 	    d_mountpoint(old_dentry))
 		goto exit;
 	dentry = lookup_one_len(new_name, new_dir, strlen(new_name));
 	/* Lookup failed, cyclic rename or target exists? */
-	if (IS_ERR(dentry) || dentry == trap || dentry->d_inode)
+	if (IS_ERR(dentry) || dentry == trap || d_inode(dentry))
 		goto exit;
 
 	old_name = fsnotify_oldname_init(old_dentry->d_name.name);
 
-	error = simple_rename(old_dir->d_inode, old_dentry, new_dir->d_inode,
-		dentry);
+	error = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),
+			      dentry);
 	if (error) {
 		fsnotify_oldname_free(old_name);
 		goto exit;
 	}
 	d_move(old_dentry, dentry);
-	fsnotify_move(old_dir->d_inode, new_dir->d_inode, old_name,
-		S_ISDIR(old_dentry->d_inode->i_mode),
-		NULL, old_dentry);
+	fsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,
+		      S_ISDIR(d_inode(old_dentry)->i_mode),
+		      NULL, old_dentry);
 	fsnotify_oldname_free(old_name);
 	unlock_rename(new_dir, old_dir);
 	dput(dentry);
diff -u -p a/debugfs/file.c b/debugfs/file.c
--- a/debugfs/file.c
+++ b/debugfs/file.c
@@ -48,7 +48,7 @@ const struct file_operations debugfs_fil
 
 static void *debugfs_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	nd_set_link(nd, dentry->d_inode->i_private);
+	nd_set_link(nd, d_inode(dentry)->i_private);
 	return NULL;
 }
 
diff -u -p a/fcntl.c b/fcntl.c
--- a/fcntl.c
+++ b/fcntl.c
@@ -147,7 +147,7 @@ SYSCALL_DEFINE1(dup, unsigned int, filde
 
 static int setfl(int fd, struct file * filp, unsigned long arg)
 {
-	struct inode * inode = filp->f_path.dentry->d_inode;
+	struct inode * inode = d_inode(filp->f_path.dentry);
 	int error = 0;
 
 	/*
diff -u -p a/exportfs/expfs.c b/exportfs/expfs.c
--- a/exportfs/expfs.c
+++ b/exportfs/expfs.c
@@ -48,7 +48,7 @@ find_acceptable_alias(struct dentry *res
 	if (acceptable(context, result))
 		return result;
 
-	inode = result->d_inode;
+	inode = d_inode(result);
 	spin_lock(&inode->i_lock);
 	list_for_each_entry(dentry, &inode->i_dentry, d_alias) {
 		dget(dentry);
@@ -143,21 +143,21 @@ reconnect_path(struct vfsmount *mnt, str
 			struct dentry *ppd = ERR_PTR(-EACCES);
 			struct dentry *npd;
 
-			mutex_lock(&pd->d_inode->i_mutex);
+			mutex_lock(&d_inode(pd)->i_mutex);
 			if (mnt->mnt_sb->s_export_op->get_parent)
 				ppd = mnt->mnt_sb->s_export_op->get_parent(pd);
-			mutex_unlock(&pd->d_inode->i_mutex);
+			mutex_unlock(&d_inode(pd)->i_mutex);
 
 			if (IS_ERR(ppd)) {
 				err = PTR_ERR(ppd);
 				dprintk("%s: get_parent of %ld failed, err %d\n",
-					__func__, pd->d_inode->i_ino, err);
+					__func__, d_inode(pd)->i_ino, err);
 				dput(pd);
 				break;
 			}
 
 			dprintk("%s: find name of %lu in %lu\n", __func__,
-				pd->d_inode->i_ino, ppd->d_inode->i_ino);
+				d_inode(pd)->i_ino, d_inode(ppd)->i_ino);
 			err = exportfs_get_name(mnt, ppd, nbuf, pd);
 			if (err) {
 				dput(ppd);
@@ -170,9 +170,9 @@ reconnect_path(struct vfsmount *mnt, str
 				break;
 			}
 			dprintk("%s: found name: %s\n", __func__, nbuf);
-			mutex_lock(&ppd->d_inode->i_mutex);
+			mutex_lock(&d_inode(ppd)->i_mutex);
 			npd = lookup_one_len(nbuf, ppd, strlen(nbuf));
-			mutex_unlock(&ppd->d_inode->i_mutex);
+			mutex_unlock(&d_inode(ppd)->i_mutex);
 			if (IS_ERR(npd)) {
 				err = PTR_ERR(npd);
 				dprintk("%s: lookup failed: %d\n",
@@ -252,7 +252,7 @@ static int get_name(struct vfsmount *mnt
 		char *name, struct dentry *child)
 {
 	const struct cred *cred = current_cred();
-	struct inode *dir = dentry->d_inode;
+	struct inode *dir = d_inode(dentry);
 	int error;
 	struct file *file;
 	struct getdents_callback buffer;
@@ -276,7 +276,7 @@ static int get_name(struct vfsmount *mnt
 		goto out_close;
 
 	buffer.name = name;
-	buffer.ino = child->d_inode->i_ino;
+	buffer.ino = d_inode(child)->i_ino;
 	buffer.found = 0;
 	buffer.sequence = 0;
 	while (1) {
@@ -317,7 +317,7 @@ out:
 static int export_encode_fh(struct dentry *dentry, struct fid *fid,
 		int *max_len, int connectable)
 {
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	int len = *max_len;
 	int type = FILEID_INO32_GEN;
 
@@ -336,7 +336,7 @@ static int export_encode_fh(struct dentr
 		struct inode *parent;
 
 		spin_lock(&dentry->d_lock);
-		parent = dentry->d_parent->d_inode;
+		parent = d_inode(dentry->d_parent);
 		fid->i32.parent_ino = parent->i_ino;
 		fid->i32.parent_gen = parent->i_generation;
 		spin_unlock(&dentry->d_lock);
@@ -382,7 +382,7 @@ struct dentry *exportfs_decode_fh(struct
 	if (IS_ERR(result))
 		return result;
 
-	if (S_ISDIR(result->d_inode->i_mode)) {
+	if (S_ISDIR(d_inode(result)->i_mode)) {
 		/*
 		 * This request is for a directory.
 		 *
@@ -456,12 +456,12 @@ struct dentry *exportfs_decode_fh(struct
 		 */
 		err = exportfs_get_name(mnt, target_dir, nbuf, result);
 		if (!err) {
-			mutex_lock(&target_dir->d_inode->i_mutex);
+			mutex_lock(&d_inode(target_dir)->i_mutex);
 			nresult = lookup_one_len(nbuf, target_dir,
 						 strlen(nbuf));
-			mutex_unlock(&target_dir->d_inode->i_mutex);
+			mutex_unlock(&d_inode(target_dir)->i_mutex);
 			if (!IS_ERR(nresult)) {
-				if (nresult->d_inode) {
+				if (d_inode(nresult)) {
 					dput(result);
 					result = nresult;
 				} else
diff -u -p a/nfs/super.c b/nfs/super.c
--- a/nfs/super.c
+++ b/nfs/super.c
@@ -453,7 +453,7 @@ static int nfs_statfs(struct dentry *den
 	struct nfs_server *server = NFS_SB(dentry->d_sb);
 	unsigned char blockbits;
 	unsigned long blockres;
-	struct nfs_fh *fh = NFS_FH(dentry->d_inode);
+	struct nfs_fh *fh = NFS_FH(d_inode(dentry));
 	struct nfs_fsstat res;
 	int error = -ENOMEM;
 
@@ -467,7 +467,7 @@ static int nfs_statfs(struct dentry *den
 
 		pd_dentry = dget_parent(dentry);
 		if (pd_dentry != NULL) {
-			nfs_zap_caches(pd_dentry->d_inode);
+			nfs_zap_caches(d_inode(pd_dentry));
 			dput(pd_dentry);
 		}
 	}
@@ -2388,7 +2388,7 @@ nfs_xdev_mount(struct file_system_type *
 		error = PTR_ERR(mntroot);
 		goto error_splat_super;
 	}
-	if (mntroot->d_inode->i_op != NFS_SB(s)->nfs_client->rpc_ops->dir_inode_ops) {
+	if (d_inode(mntroot)->i_op != NFS_SB(s)->nfs_client->rpc_ops->dir_inode_ops) {
 		dput(mntroot);
 		error = -ESTALE;
 		goto error_splat_super;
@@ -2949,7 +2949,7 @@ nfs4_xdev_mount(struct file_system_type
 		error = PTR_ERR(mntroot);
 		goto error_splat_super;
 	}
-	if (mntroot->d_inode->i_op != NFS_SB(s)->nfs_client->rpc_ops->dir_inode_ops) {
+	if (d_inode(mntroot)->i_op != NFS_SB(s)->nfs_client->rpc_ops->dir_inode_ops) {
 		dput(mntroot);
 		error = -ESTALE;
 		goto error_splat_super;
@@ -3036,7 +3036,7 @@ nfs4_remote_referral_mount(struct file_s
 		error = PTR_ERR(mntroot);
 		goto error_splat_super;
 	}
-	if (mntroot->d_inode->i_op != NFS_SB(s)->nfs_client->rpc_ops->dir_inode_ops) {
+	if (d_inode(mntroot)->i_op != NFS_SB(s)->nfs_client->rpc_ops->dir_inode_ops) {
 		dput(mntroot);
 		error = -ESTALE;
 		goto error_splat_super;
diff -u -p a/nfs/nfs4namespace.c b/nfs/nfs4namespace.c
--- a/nfs/nfs4namespace.c
+++ b/nfs/nfs4namespace.c
@@ -248,7 +248,8 @@ struct vfsmount *nfs_do_refmount(struct
 	dprintk("%s: getting locations for %s/%s\n",
 		__func__, parent->d_name.name, dentry->d_name.name);
 
-	err = nfs4_proc_fs_locations(parent->d_inode, &dentry->d_name, fs_locations, page);
+	err = nfs4_proc_fs_locations(d_inode(parent), &dentry->d_name,
+				     fs_locations, page);
 	dput(parent);
 	if (err != 0 ||
 	    fs_locations->nlocations <= 0 ||
diff -u -p a/nfs/read.c b/nfs/read.c
--- a/nfs/read.c
+++ b/nfs/read.c
@@ -144,7 +144,7 @@ int nfs_readpage_async(struct nfs_open_c
 
 static void nfs_readpage_release(struct nfs_page *req)
 {
-	struct inode *d_inode = req->wb_context->path.dentry->d_inode;
+	struct inode *d_inode = d_inode(req->wb_context->path.dentry);
 
 	if (PageUptodate(req->wb_page))
 		nfs_readpage_to_fscache(d_inode, req->wb_page, 0);
@@ -152,8 +152,8 @@ static void nfs_readpage_release(struct
 	unlock_page(req->wb_page);
 
 	dprintk("NFS: read done (%s/%Ld %d@%Ld)\n",
-			req->wb_context->path.dentry->d_inode->i_sb->s_id,
-			(long long)NFS_FILEID(req->wb_context->path.dentry->d_inode),
+			d_inode(req->wb_context->path.dentry)->i_sb->s_id,
+			(long long)NFS_FILEID(d_inode(req->wb_context->path.dentry)),
 			req->wb_bytes,
 			(long long)req_offset(req));
 	nfs_release_request(req);
@@ -207,7 +207,7 @@ static int nfs_read_rpcsetup(struct nfs_
 		unsigned int count, unsigned int offset,
 		struct pnfs_layout_segment *lseg)
 {
-	struct inode *inode = req->wb_context->path.dentry->d_inode;
+	struct inode *inode = d_inode(req->wb_context->path.dentry);
 
 	data->req	  = req;
 	data->inode	  = inode;
diff -u -p a/nfs/nfs3proc.c b/nfs/nfs3proc.c
--- a/nfs/nfs3proc.c
+++ b/nfs/nfs3proc.c
@@ -117,7 +117,7 @@ static int
 nfs3_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,
 			struct iattr *sattr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct nfs3_sattrargs	arg = {
 		.fh		= NFS_FH(inode),
 		.sattr		= sattr,
@@ -380,12 +380,12 @@ nfs3_proc_create(struct inode *dir, stru
 		 * not sure this buys us anything (and I'd have
 		 * to revamp the NFSv3 XDR code) */
 		status = nfs3_proc_setattr(dentry, data->res.fattr, sattr);
-		nfs_post_op_update_inode(dentry->d_inode, data->res.fattr);
+		nfs_post_op_update_inode(d_inode(dentry), data->res.fattr);
 		dprintk("NFS reply setattr (post-create): %d\n", status);
 		if (status != 0)
 			goto out;
 	}
-	status = nfs3_proc_set_default_acl(dir, dentry->d_inode, mode);
+	status = nfs3_proc_set_default_acl(dir, d_inode(dentry), mode);
 out:
 	nfs3_free_createdata(data);
 	dprintk("NFS reply create: %d\n", status);
@@ -583,7 +583,7 @@ nfs3_proc_mkdir(struct inode *dir, struc
 	if (status != 0)
 		goto out;
 
-	status = nfs3_proc_set_default_acl(dir, dentry->d_inode, mode);
+	status = nfs3_proc_set_default_acl(dir, d_inode(dentry), mode);
 out:
 	nfs3_free_createdata(data);
 	dprintk("NFS reply mkdir: %d\n", status);
@@ -632,7 +632,7 @@ static int
 nfs3_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,
 		  u64 cookie, struct page **pages, unsigned int count, int plus)
 {
-	struct inode		*dir = dentry->d_inode;
+	struct inode		*dir = d_inode(dentry);
 	__be32			*verf = NFS_COOKIEVERF(dir);
 	struct nfs3_readdirargs	arg = {
 		.fh		= NFS_FH(dir),
@@ -721,7 +721,7 @@ nfs3_proc_mknod(struct inode *dir, struc
 	status = nfs3_do_create(dir, dentry, data);
 	if (status != 0)
 		goto out;
-	status = nfs3_proc_set_default_acl(dir, dentry->d_inode, mode);
+	status = nfs3_proc_set_default_acl(dir, d_inode(dentry), mode);
 out:
 	nfs3_free_createdata(data);
 	dprintk("NFS reply mknod: %d\n", status);
@@ -843,7 +843,7 @@ static void nfs3_proc_commit_setup(struc
 static int
 nfs3_proc_lock(struct file *filp, int cmd, struct file_lock *fl)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 
 	return nlmclnt_proc(NFS_SERVER(inode)->nlm_host, cmd, fl);
 }
diff -u -p a/nfs/idmap.c b/nfs/idmap.c
--- a/nfs/idmap.c
+++ b/nfs/idmap.c
@@ -511,7 +511,7 @@ nfs_idmap_id(struct idmap *idmap, struct
 	msg.len = sizeof(*im);
 
 	add_wait_queue(&idmap->idmap_wq, &wq);
-	if (rpc_queue_upcall(idmap->idmap_dentry->d_inode, &msg) < 0) {
+	if (rpc_queue_upcall(d_inode(idmap->idmap_dentry), &msg) < 0) {
 		remove_wait_queue(&idmap->idmap_wq, &wq);
 		goto out;
 	}
@@ -572,7 +572,7 @@ nfs_idmap_name(struct idmap *idmap, stru
 
 	add_wait_queue(&idmap->idmap_wq, &wq);
 
-	if (rpc_queue_upcall(idmap->idmap_dentry->d_inode, &msg) < 0) {
+	if (rpc_queue_upcall(d_inode(idmap->idmap_dentry), &msg) < 0) {
 		remove_wait_queue(&idmap->idmap_wq, &wq);
 		goto out;
 	}
@@ -622,7 +622,7 @@ idmap_pipe_upcall(struct file *filp, str
 static ssize_t
 idmap_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)
 {
-	struct rpc_inode *rpci = RPC_I(filp->f_path.dentry->d_inode);
+	struct rpc_inode *rpci = RPC_I(d_inode(filp->f_path.dentry));
 	struct idmap *idmap = (struct idmap *)rpci->private;
 	struct idmap_msg im_in, *im = &idmap->idmap_im;
 	struct idmap_hashtable *h;
diff -u -p a/nfs/direct.c b/nfs/direct.c
--- a/nfs/direct.c
+++ b/nfs/direct.c
@@ -284,7 +284,7 @@ static ssize_t nfs_direct_read_schedule_
 						loff_t pos)
 {
 	struct nfs_open_context *ctx = dreq->ctx;
-	struct inode *inode = ctx->path.dentry->d_inode;
+	struct inode *inode = d_inode(ctx->path.dentry);
 	unsigned long user_addr = (unsigned long)iov->iov_base;
 	size_t count = iov->iov_len;
 	size_t rsize = NFS_SERVER(inode)->rsize;
@@ -715,7 +715,7 @@ static ssize_t nfs_direct_write_schedule
 						 loff_t pos, int sync)
 {
 	struct nfs_open_context *ctx = dreq->ctx;
-	struct inode *inode = ctx->path.dentry->d_inode;
+	struct inode *inode = d_inode(ctx->path.dentry);
 	unsigned long user_addr = (unsigned long)iov->iov_base;
 	size_t count = iov->iov_len;
 	struct rpc_task *task;
diff -u -p a/nfs/namespace.c b/nfs/namespace.c
--- a/nfs/namespace.c
+++ b/nfs/namespace.c
@@ -157,7 +157,7 @@ static int nfs_negotiate_security(const
 	int (*secinfo)(struct inode *, const struct qstr *, struct nfs4_secinfo_flavors *);
 	int ret = -EPERM;
 
-	secinfo = NFS_PROTO(parent->d_inode)->secinfo;
+	secinfo = NFS_PROTO(d_inode(parent))->secinfo;
 	if (secinfo != NULL) {
 		page = alloc_page(GFP_KERNEL);
 		if (!page) {
@@ -165,7 +165,7 @@ static int nfs_negotiate_security(const
 			goto out;
 		}
 		flavors = page_address(page);
-		ret = secinfo(parent->d_inode, &dentry->d_name, flavors);
+		ret = secinfo(d_inode(parent), &dentry->d_name, flavors);
 		*flavor = nfs_find_best_sec(flavors);
 		put_page(page);
 	}
@@ -192,7 +192,7 @@ static int nfs_lookup_with_sec(struct nf
 		err = -EIO;
 		goto out_shutdown;
 	}
-	err = server->nfs_client->rpc_ops->lookup(clone, parent->d_inode,
+	err = server->nfs_client->rpc_ops->lookup(clone, d_inode(parent),
 						  &path->dentry->d_name,
 						  fh, fattr);
 out_shutdown:
@@ -226,7 +226,7 @@ static inline int nfs_lookup_with_sec(st
 struct vfsmount *nfs_d_automount(struct path *path)
 {
 	struct vfsmount *mnt;
-	struct nfs_server *server = NFS_SERVER(path->dentry->d_inode);
+	struct nfs_server *server = NFS_SERVER(d_inode(path->dentry));
 	struct dentry *parent;
 	struct nfs_fh *fh = NULL;
 	struct nfs_fattr *fattr = NULL;
@@ -249,10 +249,11 @@ struct vfsmount *nfs_d_automount(struct
 
 	/* Look it up again to get its attributes */
 	parent = dget_parent(path->dentry);
-	err = server->nfs_client->rpc_ops->lookup(server->client, parent->d_inode,
+	err = server->nfs_client->rpc_ops->lookup(server->client,
+						  d_inode(parent),
 						  &path->dentry->d_name,
 						  fh, fattr);
-	if (err == -EPERM && NFS_PROTO(parent->d_inode)->secinfo != NULL)
+	if (err == -EPERM && NFS_PROTO(d_inode(parent))->secinfo != NULL)
 		err = nfs_lookup_with_sec(server, parent, path->dentry, path, fh, fattr, &flavor);
 	dput(parent);
 	if (err != 0) {
diff -u -p a/nfs/nfs3acl.c b/nfs/nfs3acl.c
--- a/nfs/nfs3acl.c
+++ b/nfs/nfs3acl.c
@@ -12,7 +12,7 @@
 
 ssize_t nfs3_listxattr(struct dentry *dentry, char *buffer, size_t size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct posix_acl *acl;
 	int pos=0, len=0;
 
@@ -52,7 +52,7 @@ ssize_t nfs3_listxattr(struct dentry *de
 ssize_t nfs3_getxattr(struct dentry *dentry, const char *name,
 		void *buffer, size_t size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct posix_acl *acl;
 	int type, error = 0;
 
@@ -81,7 +81,7 @@ ssize_t nfs3_getxattr(struct dentry *den
 int nfs3_setxattr(struct dentry *dentry, const char *name,
 	     const void *value, size_t size, int flags)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct posix_acl *acl;
 	int type, error;
 
@@ -103,7 +103,7 @@ int nfs3_setxattr(struct dentry *dentry,
 
 int nfs3_removexattr(struct dentry *dentry, const char *name)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int type;
 
 	if (strcmp(name, POSIX_ACL_XATTR_ACCESS) == 0)
diff -u -p a/nfs/symlink.c b/nfs/symlink.c
--- a/nfs/symlink.c
+++ b/nfs/symlink.c
@@ -45,7 +45,7 @@ error:
 
 static void *nfs_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct page *page;
 	void *err;
 
diff -u -p a/nfs/inode.c b/nfs/inode.c
--- a/nfs/inode.c
+++ b/nfs/inode.c
@@ -405,7 +405,7 @@ out_no_inode:
 int
 nfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct nfs_fattr *fattr;
 	int error = -ENOMEM;
 
@@ -505,7 +505,7 @@ void nfs_setattr_update_inode(struct ino
 
 int nfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int need_atime = NFS_I(inode)->cache_validity & NFS_INO_INVALID_ATIME;
 	int err;
 
@@ -567,7 +567,7 @@ static struct nfs_lock_context *__nfs_fi
 struct nfs_lock_context *nfs_get_lock_context(struct nfs_open_context *ctx)
 {
 	struct nfs_lock_context *res, *new = NULL;
-	struct inode *inode = ctx->path.dentry->d_inode;
+	struct inode *inode = d_inode(ctx->path.dentry);
 
 	spin_lock(&inode->i_lock);
 	res = __nfs_find_lock_context(ctx);
@@ -594,7 +594,7 @@ struct nfs_lock_context *nfs_get_lock_co
 void nfs_put_lock_context(struct nfs_lock_context *l_ctx)
 {
 	struct nfs_open_context *ctx = l_ctx->open_context;
-	struct inode *inode = ctx->path.dentry->d_inode;
+	struct inode *inode = d_inode(ctx->path.dentry);
 
 	if (!atomic_dec_and_lock(&l_ctx->count, &inode->i_lock))
 		return;
@@ -620,7 +620,7 @@ void nfs_close_context(struct nfs_open_c
 		return;
 	if (!is_sync)
 		return;
-	inode = ctx->path.dentry->d_inode;
+	inode = d_inode(ctx->path.dentry);
 	if (!list_empty(&NFS_I(inode)->open_files))
 		return;
 	server = NFS_SERVER(inode);
@@ -658,7 +658,7 @@ struct nfs_open_context *get_nfs_open_co
 
 static void __put_nfs_open_context(struct nfs_open_context *ctx, int is_sync)
 {
-	struct inode *inode = ctx->path.dentry->d_inode;
+	struct inode *inode = d_inode(ctx->path.dentry);
 
 	if (!list_empty(&ctx->list)) {
 		if (!atomic_dec_and_lock(&ctx->lock_context.count, &inode->i_lock))
@@ -686,7 +686,7 @@ void put_nfs_open_context(struct nfs_ope
  */
 void nfs_file_set_open_context(struct file *filp, struct nfs_open_context *ctx)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct nfs_inode *nfsi = NFS_I(inode);
 
 	filp->private_data = get_nfs_open_context(ctx);
@@ -718,7 +718,7 @@ struct nfs_open_context *nfs_find_open_c
 
 static void nfs_file_clear_open_context(struct file *filp)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct nfs_open_context *ctx = nfs_file_open_context(filp);
 
 	if (ctx) {
diff -u -p a/nfs/unlink.c b/nfs/unlink.c
--- a/nfs/unlink.c
+++ b/nfs/unlink.c
@@ -156,7 +156,7 @@ static int nfs_do_call_unlink(struct den
 		 */
 		nfs_free_dname(data);
 		spin_lock(&alias->d_lock);
-		if (alias->d_inode != NULL &&
+		if (d_inode(alias) != NULL &&
 		    !(alias->d_flags & DCACHE_NFSFS_RENAMED)) {
 			devname_garbage = alias->d_fsdata;
 			alias->d_fsdata = data;
@@ -203,7 +203,7 @@ static int nfs_call_unlink(struct dentry
 	parent = dget_parent(dentry);
 	if (parent == NULL)
 		goto out_free;
-	dir = parent->d_inode;
+	dir = d_inode(parent);
 	if (nfs_copy_dname(dentry, data) != 0)
 		goto out_dput;
 	/* Non-exclusive lock protects against concurrent lookup() calls */
@@ -225,14 +225,14 @@ out_free:
 
 void nfs_block_sillyrename(struct dentry *dentry)
 {
-	struct nfs_inode *nfsi = NFS_I(dentry->d_inode);
+	struct nfs_inode *nfsi = NFS_I(d_inode(dentry));
 
 	wait_event(nfsi->waitqueue, atomic_cmpxchg(&nfsi->silly_count, 1, 0) == 1);
 }
 
 void nfs_unblock_sillyrename(struct dentry *dentry)
 {
-	struct inode *dir = dentry->d_inode;
+	struct inode *dir = d_inode(dentry);
 	struct nfs_inode *nfsi = NFS_I(dir);
 	struct nfs_unlinkdata *data;
 
@@ -390,8 +390,8 @@ static void nfs_async_rename_release(voi
 	struct nfs_renamedata	*data = calldata;
 	struct super_block *sb = data->old_dir->i_sb;
 
-	if (data->old_dentry->d_inode)
-		nfs_mark_for_revalidate(data->old_dentry->d_inode);
+	if (d_inode(data->old_dentry))
+		nfs_mark_for_revalidate(d_inode(data->old_dentry));
 
 	dput(data->old_dentry);
 	dput(data->new_dentry);
@@ -506,7 +506,7 @@ int
 nfs_sillyrename(struct inode *dir, struct dentry *dentry)
 {
 	static unsigned int sillycounter;
-	const int      fileidsize  = sizeof(NFS_FILEID(dentry->d_inode))*2;
+	const int      fileidsize  = sizeof(NFS_FILEID(d_inode(dentry)))*2;
 	const int      countersize = sizeof(sillycounter)*2;
 	const int      slen        = sizeof(".nfs")+fileidsize+countersize-1;
 	char           silly[slen+1];
@@ -528,10 +528,10 @@ nfs_sillyrename(struct inode *dir, struc
 
 	sprintf(silly, ".nfs%*.*Lx",
 		fileidsize, fileidsize,
-		(unsigned long long)NFS_FILEID(dentry->d_inode));
+		(unsigned long long)NFS_FILEID(d_inode(dentry)));
 
 	/* Return delegation in anticipation of the rename */
-	nfs_inode_return_delegation(dentry->d_inode);
+	nfs_inode_return_delegation(d_inode(dentry));
 
 	sdentry = NULL;
 	do {
@@ -551,7 +551,7 @@ nfs_sillyrename(struct inode *dir, struc
 		 */
 		if (IS_ERR(sdentry))
 			goto out;
-	} while (sdentry->d_inode != NULL); /* need negative lookup */
+	} while (d_inode(sdentry) != NULL); /* need negative lookup */
 
 	/* queue unlink first. Can't do this from rpc_release as it
 	 * has to allocate memory
diff -u -p a/nfs/getroot.c b/nfs/getroot.c
--- a/nfs/getroot.c
+++ b/nfs/getroot.c
@@ -63,11 +63,11 @@ static int nfs_superblock_set_dummy_root
 		 * This again causes shrink_dcache_for_umount_subtree() to
 		 * Oops, since the test for IS_ROOT() will fail.
 		 */
-		spin_lock(&sb->s_root->d_inode->i_lock);
+		spin_lock(&d_inode(sb->s_root)->i_lock);
 		spin_lock(&sb->s_root->d_lock);
 		list_del_init(&sb->s_root->d_alias);
 		spin_unlock(&sb->s_root->d_lock);
-		spin_unlock(&sb->s_root->d_inode->i_lock);
+		spin_unlock(&d_inode(sb->s_root)->i_lock);
 	}
 	return 0;
 }
diff -u -p a/nfs/file.c b/nfs/file.c
--- a/nfs/file.c
+++ b/nfs/file.c
@@ -210,7 +210,7 @@ static int
 nfs_file_flush(struct file *file, fl_owner_t id)
 {
 	struct dentry	*dentry = file->f_path.dentry;
-	struct inode	*inode = dentry->d_inode;
+	struct inode	*inode = d_inode(dentry);
 
 	dprintk("NFS: flush(%s/%s)\n",
 			dentry->d_parent->d_name.name,
@@ -229,7 +229,7 @@ nfs_file_read(struct kiocb *iocb, const
 		unsigned long nr_segs, loff_t pos)
 {
 	struct dentry * dentry = iocb->ki_filp->f_path.dentry;
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	ssize_t result;
 	size_t count = iov_length(iov, nr_segs);
 
@@ -255,7 +255,7 @@ nfs_file_splice_read(struct file *filp,
 		     unsigned int flags)
 {
 	struct dentry *dentry = filp->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	ssize_t res;
 
 	dprintk("NFS: splice_read(%s/%s, %lu@%Lu)\n",
@@ -275,7 +275,7 @@ static int
 nfs_file_mmap(struct file * file, struct vm_area_struct * vma)
 {
 	struct dentry *dentry = file->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int	status;
 
 	dprintk("NFS: mmap(%s/%s)\n",
@@ -309,7 +309,7 @@ nfs_file_fsync(struct file *file, int da
 {
 	struct dentry *dentry = file->f_path.dentry;
 	struct nfs_open_context *ctx = nfs_file_open_context(file);
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int have_error, status;
 	int ret = 0;
 
@@ -564,11 +564,11 @@ static int nfs_vm_page_mkwrite(struct vm
 		(long long)page_offset(page));
 
 	/* make sure the cache has finished storing the page */
-	nfs_fscache_wait_on_page_write(NFS_I(dentry->d_inode), page);
+	nfs_fscache_wait_on_page_write(NFS_I(d_inode(dentry)), page);
 
 	lock_page(page);
 	mapping = page->mapping;
-	if (mapping != dentry->d_inode->i_mapping)
+	if (mapping != d_inode(dentry)->i_mapping)
 		goto out_unlock;
 
 	pagelen = nfs_page_length(page);
@@ -608,7 +608,7 @@ static ssize_t nfs_file_write(struct kio
 				unsigned long nr_segs, loff_t pos)
 {
 	struct dentry * dentry = iocb->ki_filp->f_path.dentry;
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	unsigned long written = 0;
 	ssize_t result;
 	size_t count = iov_length(iov, nr_segs);
@@ -661,7 +661,7 @@ static ssize_t nfs_file_splice_write(str
 				     size_t count, unsigned int flags)
 {
 	struct dentry *dentry = filp->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	unsigned long written = 0;
 	ssize_t ret;
 
diff -u -p a/nfs/dir.c b/nfs/dir.c
--- a/nfs/dir.c
+++ b/nfs/dir.c
@@ -445,9 +445,9 @@ static int xdr_decode(nfs_readdir_descri
 static
 int nfs_same_file(struct dentry *dentry, struct nfs_entry *entry)
 {
-	if (dentry->d_inode == NULL)
+	if (d_inode(dentry) == NULL)
 		goto different;
-	if (nfs_compare_fh(entry->fh, NFS_FH(dentry->d_inode)) != 0)
+	if (nfs_compare_fh(entry->fh, NFS_FH(d_inode(dentry))) != 0)
 		goto different;
 	return 1;
 different:
@@ -463,7 +463,7 @@ void nfs_prime_dcache(struct dentry *par
 	};
 	struct dentry *dentry;
 	struct dentry *alias;
-	struct inode *dir = parent->d_inode;
+	struct inode *dir = d_inode(parent);
 	struct inode *inode;
 
 	if (filename.name[0] == '.') {
@@ -477,7 +477,7 @@ void nfs_prime_dcache(struct dentry *par
 	dentry = d_lookup(parent, &filename);
 	if (dentry != NULL) {
 		if (nfs_same_file(dentry, entry)) {
-			nfs_refresh_inode(dentry->d_inode, entry->fattr);
+			nfs_refresh_inode(d_inode(dentry), entry->fattr);
 			goto out;
 		} else {
 			d_drop(dentry);
@@ -658,7 +658,7 @@ out:
 static
 int nfs_readdir_filler(nfs_readdir_descriptor_t *desc, struct page* page)
 {
-	struct inode	*inode = desc->file->f_path.dentry->d_inode;
+	struct inode	*inode = d_inode(desc->file->f_path.dentry);
 	int ret;
 
 	ret = nfs_readdir_xdr_to_array(desc, page, inode);
@@ -689,8 +689,9 @@ void cache_page_release(nfs_readdir_desc
 static
 struct page *get_cache_page(nfs_readdir_descriptor_t *desc)
 {
-	return read_cache_page(desc->file->f_path.dentry->d_inode->i_mapping,
-			desc->page_index, (filler_t *)nfs_readdir_filler, desc);
+	return read_cache_page(d_inode(desc->file->f_path.dentry)->i_mapping,
+			       desc->page_index,
+			       (filler_t *)nfs_readdir_filler, desc);
 }
 
 /*
@@ -804,7 +805,7 @@ int uncached_readdir(nfs_readdir_descrip
 {
 	struct page	*page = NULL;
 	int		status;
-	struct inode *inode = desc->file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(desc->file->f_path.dentry);
 
 	dfprintk(DIRCACHE, "NFS: uncached_readdir() searching for cookie %Lu\n",
 			(unsigned long long)*desc->dir_cookie);
@@ -841,7 +842,7 @@ int uncached_readdir(nfs_readdir_descrip
 static int nfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
 	struct dentry	*dentry = filp->f_path.dentry;
-	struct inode	*inode = dentry->d_inode;
+	struct inode	*inode = d_inode(dentry);
 	nfs_readdir_descriptor_t my_desc,
 			*desc = &my_desc;
 	struct nfs_open_dir_context *dir_ctx = filp->private_data;
@@ -912,7 +913,7 @@ out:
 static loff_t nfs_llseek_dir(struct file *filp, loff_t offset, int origin)
 {
 	struct dentry *dentry = filp->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct nfs_open_dir_context *dir_ctx = filp->private_data;
 
 	dfprintk(FILE, "NFS: llseek dir(%s/%s, %lld, %d)\n",
@@ -953,7 +954,7 @@ static int nfs_fsync_dir(struct file *fi
 			dentry->d_parent->d_name.name, dentry->d_name.name,
 			datasync);
 
-	nfs_inc_stats(dentry->d_inode, NFSIOS_VFSFSYNC);
+	nfs_inc_stats(d_inode(dentry), NFSIOS_VFSFSYNC);
 	return 0;
 }
 
@@ -1094,9 +1095,9 @@ static int nfs_lookup_revalidate(struct
 		return -ECHILD;
 
 	parent = dget_parent(dentry);
-	dir = parent->d_inode;
+	dir = d_inode(parent);
 	nfs_inc_stats(dir, NFSIOS_DENTRYREVALIDATE);
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	if (!inode) {
 		if (nfs_neg_need_reval(dir, dentry, nd))
@@ -1190,7 +1191,7 @@ static int nfs_dentry_delete(const struc
 		dentry->d_flags);
 
 	/* Unhash any dentry with a stale inode */
-	if (dentry->d_inode != NULL && NFS_STALE(dentry->d_inode))
+	if (d_inode(dentry) != NULL && NFS_STALE(d_inode(dentry)))
 		return 1;
 
 	if (dentry->d_flags & DCACHE_NFSFS_RENAMED) {
@@ -1376,9 +1377,9 @@ static int nfs_intent_set_file(struct na
 
 	/* If the open_intent is for execute, we have an extra check to make */
 	if (ctx->mode & FMODE_EXEC) {
-		ret = nfs_may_open(ctx->path.dentry->d_inode,
-				ctx->cred,
-				nd->intent.open.flags);
+		ret = nfs_may_open(d_inode(ctx->path.dentry),
+				   ctx->cred,
+				   nd->intent.open.flags);
 		if (ret < 0)
 			goto out;
 	}
@@ -1491,12 +1492,12 @@ static int nfs_open_revalidate(struct de
 	if (nd->flags & LOOKUP_RCU)
 		return -ECHILD;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	if (!is_atomic_open(nd) || d_mountpoint(dentry))
 		goto no_open;
 
 	parent = dget_parent(dentry);
-	dir = parent->d_inode;
+	dir = d_inode(parent);
 
 	/* We can't create new files in nfs_open_revalidate(), so we
 	 * optimize away revalidation of negative dentries.
@@ -1541,7 +1542,7 @@ static int nfs_open_revalidate(struct de
 		}
 	}
 	iput(inode);
-	if (inode != dentry->d_inode)
+	if (inode != d_inode(dentry))
 		goto out_drop;
 
 	nfs_set_verifier(dentry, nfs_save_change_attribute(dir));
@@ -1614,14 +1615,14 @@ int nfs_instantiate(struct dentry *dentr
 				struct nfs_fattr *fattr)
 {
 	struct dentry *parent = dget_parent(dentry);
-	struct inode *dir = parent->d_inode;
+	struct inode *dir = d_inode(parent);
 	struct inode *inode;
 	int error = -EACCES;
 
 	d_drop(dentry);
 
 	/* We may have been initialized further down */
-	if (dentry->d_inode)
+	if (d_inode(dentry))
 		goto out;
 	if (fhandle->size == 0) {
 		error = NFS_PROTO(dir)->lookup(NFS_SERVER(dir)->client, dir, &dentry->d_name, fhandle, fattr);
@@ -1732,7 +1733,7 @@ out_err:
 
 static void nfs_dentry_handle_enoent(struct dentry *dentry)
 {
-	if (dentry->d_inode != NULL && !d_unhashed(dentry))
+	if (d_inode(dentry) != NULL && !d_unhashed(dentry))
 		d_delete(dentry);
 }
 
@@ -1745,8 +1746,8 @@ static int nfs_rmdir(struct inode *dir,
 
 	error = NFS_PROTO(dir)->rmdir(dir, &dentry->d_name);
 	/* Ensure the VFS deletes this inode */
-	if (error == 0 && dentry->d_inode != NULL)
-		clear_nlink(dentry->d_inode);
+	if (error == 0 && d_inode(dentry) != NULL)
+		clear_nlink(d_inode(dentry));
 	else if (error == -ENOENT)
 		nfs_dentry_handle_enoent(dentry);
 
@@ -1762,8 +1763,8 @@ static int nfs_rmdir(struct inode *dir,
  */
 static int nfs_safe_remove(struct dentry *dentry)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
-	struct inode *inode = dentry->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
+	struct inode *inode = d_inode(dentry);
 	int error = -EBUSY;
 		
 	dfprintk(VFS, "NFS: safe_remove(%s/%s)\n",
@@ -1807,7 +1808,7 @@ static int nfs_unlink(struct inode *dir,
 	if (dentry->d_count > 1) {
 		spin_unlock(&dentry->d_lock);
 		/* Start asynchronous writeout of the inode */
-		write_inode_now(dentry->d_inode, 0);
+		write_inode_now(d_inode(dentry), 0);
 		error = nfs_sillyrename(dir, dentry);
 		return error;
 	}
@@ -1882,7 +1883,7 @@ static int nfs_symlink(struct inode *dir
 	 * READLINK will get the missing page from the server if needed.
 	 */
 	pagevec_init(&lru_pvec, 0);
-	if (!add_to_page_cache(page, dentry->d_inode->i_mapping, 0,
+	if (!add_to_page_cache(page, d_inode(dentry)->i_mapping, 0,
 							GFP_KERNEL)) {
 		pagevec_add(&lru_pvec, page);
 		pagevec_lru_add_file(&lru_pvec);
@@ -1897,7 +1898,7 @@ static int nfs_symlink(struct inode *dir
 static int 
 nfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	int error;
 
 	dfprintk(VFS, "NFS: link(%s/%s -> %s/%s)\n",
@@ -1942,8 +1943,8 @@ nfs_link(struct dentry *old_dentry, stru
 static int nfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 		      struct inode *new_dir, struct dentry *new_dentry)
 {
-	struct inode *old_inode = old_dentry->d_inode;
-	struct inode *new_inode = new_dentry->d_inode;
+	struct inode *old_inode = d_inode(old_dentry);
+	struct inode *new_inode = d_inode(new_dentry);
 	struct dentry *dentry = NULL, *rehash = NULL;
 	int error = -EBUSY;
 
diff -u -p a/nfs/proc.c b/nfs/proc.c
--- a/nfs/proc.c
+++ b/nfs/proc.c
@@ -150,7 +150,7 @@ static int
 nfs_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,
 		 struct iattr *sattr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct nfs_sattrargs	arg = { 
 		.fh	= NFS_FH(inode),
 		.sattr	= sattr
@@ -537,7 +537,7 @@ static int
 nfs_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,
 		 u64 cookie, struct page **pages, unsigned int count, int plus)
 {
-	struct inode		*dir = dentry->d_inode;
+	struct inode		*dir = d_inode(dentry);
 	struct nfs_readdirargs	arg = {
 		.fh		= NFS_FH(dir),
 		.cookie		= cookie,
@@ -676,7 +676,7 @@ nfs_proc_commit_setup(struct nfs_write_d
 static int
 nfs_proc_lock(struct file *filp, int cmd, struct file_lock *fl)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 
 	return nlmclnt_proc(NFS_SERVER(inode)->nlm_host, cmd, fl);
 }
diff -u -p a/nfs/nfs4proc.c b/nfs/nfs4proc.c
--- a/nfs/nfs4proc.c
+++ b/nfs/nfs4proc.c
@@ -200,7 +200,7 @@ static void nfs4_setup_readdir(u64 cooki
 		*p++ = xdr_one;                         /* bitmap length */
 		*p++ = htonl(FATTR4_WORD0_FILEID);             /* bitmap */
 		*p++ = htonl(8);              /* attribute buffer length */
-		p = xdr_encode_hyper(p, NFS_FILEID(dentry->d_inode));
+		p = xdr_encode_hyper(p, NFS_FILEID(d_inode(dentry)));
 	}
 	
 	*p++ = xdr_one;                                  /* next */
@@ -212,7 +212,7 @@ static void nfs4_setup_readdir(u64 cooki
 	*p++ = xdr_one;                         /* bitmap length */
 	*p++ = htonl(FATTR4_WORD0_FILEID);             /* bitmap */
 	*p++ = htonl(8);              /* attribute buffer length */
-	p = xdr_encode_hyper(p, NFS_FILEID(dentry->d_parent->d_inode));
+	p = xdr_encode_hyper(p, NFS_FILEID(d_inode(dentry->d_parent)));
 
 	readdir->pgbase = (char *)p - (char *)start;
 	readdir->count -= readdir->pgbase;
@@ -792,7 +792,7 @@ static struct nfs4_opendata *nfs4_openda
 		gfp_t gfp_mask)
 {
 	struct dentry *parent = dget_parent(path->dentry);
-	struct inode *dir = parent->d_inode;
+	struct inode *dir = d_inode(parent);
 	struct nfs_server *server = NFS_SERVER(dir);
 	struct nfs4_opendata *p;
 
@@ -1367,7 +1367,7 @@ static const struct rpc_call_ops nfs4_op
  */
 static int _nfs4_proc_open_confirm(struct nfs4_opendata *data)
 {
-	struct nfs_server *server = NFS_SERVER(data->dir->d_inode);
+	struct nfs_server *server = NFS_SERVER(d_inode(data->dir));
 	struct rpc_task *task;
 	struct  rpc_message msg = {
 		.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_CONFIRM],
@@ -1516,7 +1516,7 @@ static const struct rpc_call_ops nfs4_re
 
 static int nfs4_run_open_task(struct nfs4_opendata *data, int isrecover)
 {
-	struct inode *dir = data->dir->d_inode;
+	struct inode *dir = d_inode(data->dir);
 	struct nfs_server *server = NFS_SERVER(dir);
 	struct nfs_openargs *o_arg = &data->o_arg;
 	struct nfs_openres *o_res = &data->o_res;
@@ -1559,7 +1559,7 @@ static int nfs4_run_open_task(struct nfs
 
 static int _nfs4_recover_proc_open(struct nfs4_opendata *data)
 {
-	struct inode *dir = data->dir->d_inode;
+	struct inode *dir = d_inode(data->dir);
 	struct nfs_openres *o_res = &data->o_res;
         int status;
 
@@ -1583,7 +1583,7 @@ static int _nfs4_recover_proc_open(struc
  */
 static int _nfs4_proc_open(struct nfs4_opendata *data)
 {
-	struct inode *dir = data->dir->d_inode;
+	struct inode *dir = d_inode(data->dir);
 	struct nfs_server *server = NFS_SERVER(dir);
 	struct nfs_openargs *o_arg = &data->o_arg;
 	struct nfs_openres *o_res = &data->o_res;
@@ -1723,15 +1723,17 @@ static int _nfs4_do_open(struct inode *d
 	status = nfs4_recover_expired_lease(server);
 	if (status != 0)
 		goto err_put_state_owner;
-	if (path->dentry->d_inode != NULL)
-		nfs4_return_incompatible_delegation(path->dentry->d_inode, fmode);
+	if (d_inode(path->dentry) != NULL)
+		nfs4_return_incompatible_delegation(d_inode(path->dentry),
+						    fmode);
 	status = -ENOMEM;
 	opendata = nfs4_opendata_alloc(path, sp, fmode, flags, sattr, GFP_KERNEL);
 	if (opendata == NULL)
 		goto err_put_state_owner;
 
-	if (path->dentry->d_inode != NULL)
-		opendata->state = nfs4_get_open_state(path->dentry->d_inode, sp);
+	if (d_inode(path->dentry) != NULL)
+		opendata->state = nfs4_get_open_state(d_inode(path->dentry),
+						      sp);
 
 	status = _nfs4_proc_open(opendata);
 	if (status != 0)
@@ -2361,7 +2363,7 @@ static int
 nfs4_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,
 		  struct iattr *sattr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct rpc_cred *cred = NULL;
 	struct nfs4_state *state = NULL;
 	int status;
@@ -2974,13 +2976,13 @@ static int nfs4_proc_mkdir(struct inode
 static int _nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,
 		u64 cookie, struct page **pages, unsigned int count, int plus)
 {
-	struct inode		*dir = dentry->d_inode;
+	struct inode		*dir = d_inode(dentry);
 	struct nfs4_readdir_arg args = {
 		.fh = NFS_FH(dir),
 		.pages = pages,
 		.pgbase = 0,
 		.count = count,
-		.bitmask = NFS_SERVER(dentry->d_inode)->attr_bitmask,
+		.bitmask = NFS_SERVER(d_inode(dentry))->attr_bitmask,
 		.plus = plus,
 	};
 	struct nfs4_readdir_res res;
@@ -3016,10 +3018,10 @@ static int nfs4_proc_readdir(struct dent
 	struct nfs4_exception exception = { };
 	int err;
 	do {
-		err = nfs4_handle_exception(NFS_SERVER(dentry->d_inode),
-				_nfs4_proc_readdir(dentry, cred, cookie,
-					pages, count, plus),
-				&exception);
+		err = nfs4_handle_exception(NFS_SERVER(d_inode(dentry)),
+					    _nfs4_proc_readdir(dentry, cred, cookie,
+							       pages, count, plus),
+					    &exception);
 	} while (exception.retry);
 	return err;
 }
@@ -4294,7 +4296,8 @@ static void nfs4_lock_done(struct rpc_ta
 		memcpy(data->lsp->ls_stateid.data, data->res.stateid.data,
 					sizeof(data->lsp->ls_stateid.data));
 		data->lsp->ls_flags |= NFS_LOCK_INITIALIZED;
-		renew_lease(NFS_SERVER(data->ctx->path.dentry->d_inode), data->timestamp);
+		renew_lease(NFS_SERVER(d_inode(data->ctx->path.dentry)),
+			    data->timestamp);
 	}
 out:
 	dprintk("%s: done, ret = %d!\n", __func__, data->rpc_status);
@@ -4644,7 +4647,7 @@ static int nfs4_xattr_set_nfs4_acl(struc
 	if (strcmp(key, "") != 0)
 		return -EINVAL;
 
-	return nfs4_proc_set_acl(dentry->d_inode, buf, buflen);
+	return nfs4_proc_set_acl(d_inode(dentry), buf, buflen);
 }
 
 static int nfs4_xattr_get_nfs4_acl(struct dentry *dentry, const char *key,
@@ -4653,7 +4656,7 @@ static int nfs4_xattr_get_nfs4_acl(struc
 	if (strcmp(key, "") != 0)
 		return -EINVAL;
 
-	return nfs4_proc_get_acl(dentry->d_inode, buf, buflen);
+	return nfs4_proc_get_acl(d_inode(dentry), buf, buflen);
 }
 
 static size_t nfs4_xattr_list_nfs4_acl(struct dentry *dentry, char *list,
@@ -4662,7 +4665,7 @@ static size_t nfs4_xattr_list_nfs4_acl(s
 {
 	size_t len = sizeof(XATTR_NAME_NFSV4_ACL);
 
-	if (!nfs4_server_supports_acls(NFS_SERVER(dentry->d_inode)))
+	if (!nfs4_server_supports_acls(NFS_SERVER(d_inode(dentry))))
 		return 0;
 
 	if (list && len <= list_len)
diff -u -p a/nfs/pagelist.c b/nfs/pagelist.c
--- a/nfs/pagelist.c
+++ b/nfs/pagelist.c
@@ -114,7 +114,8 @@ int nfs_set_page_tag_locked(struct nfs_p
 	if (!nfs_lock_request_dontget(req))
 		return 0;
 	if (test_bit(PG_MAPPED, &req->wb_flags))
-		radix_tree_tag_set(&NFS_I(req->wb_context->path.dentry->d_inode)->nfs_page_tree, req->wb_index, NFS_PAGE_TAG_LOCKED);
+		radix_tree_tag_set(&NFS_I(d_inode(req->wb_context->path.dentry))->nfs_page_tree,
+				   req->wb_index, NFS_PAGE_TAG_LOCKED);
 	return 1;
 }
 
@@ -124,7 +125,7 @@ int nfs_set_page_tag_locked(struct nfs_p
 void nfs_clear_page_tag_locked(struct nfs_page *req)
 {
 	if (test_bit(PG_MAPPED, &req->wb_flags)) {
-		struct inode *inode = req->wb_context->path.dentry->d_inode;
+		struct inode *inode = d_inode(req->wb_context->path.dentry);
 		struct nfs_inode *nfsi = NFS_I(inode);
 
 		spin_lock(&inode->i_lock);
diff -u -p a/nfs/write.c b/nfs/write.c
--- a/nfs/write.c
+++ b/nfs/write.c
@@ -409,7 +409,7 @@ out:
  */
 static void nfs_inode_remove_request(struct nfs_page *req)
 {
-	struct inode *inode = req->wb_context->path.dentry->d_inode;
+	struct inode *inode = d_inode(req->wb_context->path.dentry);
 	struct nfs_inode *nfsi = NFS_I(inode);
 
 	BUG_ON (!NFS_WBACK_BUSY(req));
@@ -438,7 +438,7 @@ nfs_mark_request_dirty(struct nfs_page *
 static void
 nfs_mark_request_commit(struct nfs_page *req, struct pnfs_layout_segment *lseg)
 {
-	struct inode *inode = req->wb_context->path.dentry->d_inode;
+	struct inode *inode = d_inode(req->wb_context->path.dentry);
 	struct nfs_inode *nfsi = NFS_I(inode);
 
 	spin_lock(&inode->i_lock);
@@ -852,13 +852,13 @@ static int nfs_write_rpcsetup(struct nfs
 		struct pnfs_layout_segment *lseg,
 		int how)
 {
-	struct inode *inode = req->wb_context->path.dentry->d_inode;
+	struct inode *inode = d_inode(req->wb_context->path.dentry);
 
 	/* Set up the RPC argument and reply structs
 	 * NB: take care not to mess about with data->commit et al. */
 
 	data->req = req;
-	data->inode = inode = req->wb_context->path.dentry->d_inode;
+	data->inode = inode = d_inode(req->wb_context->path.dentry);
 	data->cred = req->wb_context->cred;
 	data->lseg = get_lseg(lseg);
 
@@ -1053,10 +1053,10 @@ static void nfs_writeback_done_partial(s
 
 	dprintk("NFS: %5u write(%s/%lld %d@%lld)",
 		task->tk_pid,
-		data->req->wb_context->path.dentry->d_inode->i_sb->s_id,
+		d_inode(data->req->wb_context->path.dentry)->i_sb->s_id,
 		(long long)
-		  NFS_FILEID(data->req->wb_context->path.dentry->d_inode),
-		data->req->wb_bytes, (long long)req_offset(data->req));
+		  NFS_FILEID(d_inode(data->req->wb_context->path.dentry)),
+		  data->req->wb_bytes, (long long)req_offset(data->req));
 
 	nfs_writeback_done(task, data);
 }
@@ -1148,8 +1148,8 @@ static void nfs_writeback_release_full(v
 
 		dprintk("NFS: %5u write (%s/%lld %d@%lld)",
 			data->task.tk_pid,
-			req->wb_context->path.dentry->d_inode->i_sb->s_id,
-			(long long)NFS_FILEID(req->wb_context->path.dentry->d_inode),
+			d_inode(req->wb_context->path.dentry)->i_sb->s_id,
+			(long long)NFS_FILEID(d_inode(req->wb_context->path.dentry)),
 			req->wb_bytes,
 			(long long)req_offset(req));
 
@@ -1347,7 +1347,7 @@ void nfs_init_commit(struct nfs_write_da
 			    struct pnfs_layout_segment *lseg)
 {
 	struct nfs_page *first = nfs_list_entry(head->next);
-	struct inode *inode = first->wb_context->path.dentry->d_inode;
+	struct inode *inode = d_inode(first->wb_context->path.dentry);
 
 	/* Set up the RPC argument and reply structs
 	 * NB: take care not to mess about with data->commit et al. */
@@ -1435,8 +1435,8 @@ void nfs_commit_release_pages(struct nfs
 		nfs_clear_request_commit(req);
 
 		dprintk("NFS:       commit (%s/%lld %d@%lld)",
-			req->wb_context->path.dentry->d_inode->i_sb->s_id,
-			(long long)NFS_FILEID(req->wb_context->path.dentry->d_inode),
+			d_inode(req->wb_context->path.dentry)->i_sb->s_id,
+			(long long)NFS_FILEID(d_inode(req->wb_context->path.dentry)),
 			req->wb_bytes,
 			(long long)req_offset(req));
 		if (status < 0) {
diff -u -p a/fat/namei_msdos.c b/fat/namei_msdos.c
--- a/fat/namei_msdos.c
+++ b/fat/namei_msdos.c
@@ -322,7 +322,7 @@ out:
 static int msdos_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	struct super_block *sb = dir->i_sb;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct fat_slot_info sinfo;
 	int err;
 
@@ -416,7 +416,7 @@ out:
 /***** Unlink a file */
 static int msdos_unlink(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct super_block *sb= inode->i_sb;
 	struct fat_slot_info sinfo;
 	int err;
@@ -454,8 +454,8 @@ static int do_msdos_rename(struct inode
 	int err, old_attrs, is_dir, update_dotdot, corrupt = 0;
 
 	old_sinfo.bh = sinfo.bh = dotdot_bh = NULL;
-	old_inode = old_dentry->d_inode;
-	new_inode = new_dentry->d_inode;
+	old_inode = d_inode(old_dentry);
+	new_inode = d_inode(new_dentry);
 
 	err = fat_scan(old_dir, old_name, &old_sinfo);
 	if (err) {
diff -u -p a/fat/inode.c b/fat/inode.c
--- a/fat/inode.c
+++ b/fat/inode.c
@@ -754,7 +754,7 @@ static int
 fat_encode_fh(struct dentry *de, __u32 *fh, int *lenp, int connectable)
 {
 	int len = *lenp;
-	struct inode *inode =  de->d_inode;
+	struct inode *inode =  d_inode(de);
 	u32 ipos_h, ipos_m, ipos_l;
 
 	if (len < 5) {
@@ -771,7 +771,7 @@ fat_encode_fh(struct dentry *de, __u32 *
 	fh[2] = ipos_h;
 	fh[3] = ipos_m | MSDOS_I(inode)->i_logstart;
 	spin_lock(&de->d_lock);
-	fh[4] = ipos_l | MSDOS_I(de->d_parent->d_inode)->i_logstart;
+	fh[4] = ipos_l | MSDOS_I(d_inode(de->d_parent))->i_logstart;
 	spin_unlock(&de->d_lock);
 	return 3;
 }
@@ -788,7 +788,7 @@ static struct dentry *fat_get_parent(str
 
 	lock_super(sb);
 
-	err = fat_get_dotdot_entry(child->d_inode, &bh, &de, &i_pos);
+	err = fat_get_dotdot_entry(d_inode(child), &bh, &de, &i_pos);
 	if (err) {
 		parent = ERR_PTR(err);
 		goto out;
diff -u -p a/fat/file.c b/fat/file.c
--- a/fat/file.c
+++ b/fat/file.c
@@ -32,7 +32,7 @@ static int fat_ioctl_get_attributes(stru
 
 static int fat_ioctl_set_attributes(struct file *file, u32 __user *user_attr)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);
 	int is_dir = S_ISDIR(inode->i_mode);
 	u32 attr, oldattr;
@@ -117,7 +117,7 @@ out:
 
 long fat_generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	u32 __user *user_attr = (u32 __user *)arg;
 
 	switch (cmd) {
@@ -304,7 +304,7 @@ void fat_truncate_blocks(struct inode *i
 
 int fat_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	generic_fillattr(inode, stat);
 	stat->blksize = MSDOS_SB(inode->i_sb)->cluster_size;
 	return 0;
@@ -371,7 +371,7 @@ static int fat_allow_set_time(struct msd
 int fat_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	struct msdos_sb_info *sbi = MSDOS_SB(dentry->d_sb);
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	unsigned int ia_valid;
 	int error;
 
diff -u -p a/fat/dir.c b/fat/dir.c
--- a/fat/dir.c
+++ b/fat/dir.c
@@ -676,7 +676,7 @@ out:
 
 static int fat_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	return __fat_readdir(inode, filp, dirent, filldir, 0, 0);
 }
 
@@ -757,7 +757,7 @@ static int fat_ioctl_readdir(struct inod
 static long fat_dir_ioctl(struct file *filp, unsigned int cmd,
 			  unsigned long arg)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct __fat_dirent __user *d1 = (struct __fat_dirent __user *)arg;
 	int short_only, both;
 
@@ -797,7 +797,7 @@ FAT_IOCTL_FILLDIR_FUNC(fat_compat_ioctl_
 static long fat_compat_dir_ioctl(struct file *filp, unsigned cmd,
 				 unsigned long arg)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct compat_dirent __user *d1 = compat_ptr(arg);
 	int short_only, both;
 
diff -u -p a/fat/namei_vfat.c b/fat/namei_vfat.c
--- a/fat/namei_vfat.c
+++ b/fat/namei_vfat.c
@@ -35,7 +35,7 @@ static int vfat_revalidate_shortname(str
 {
 	int ret = 1;
 	spin_lock(&dentry->d_lock);
-	if (dentry->d_time != dentry->d_parent->d_inode->i_version)
+	if (dentry->d_time != d_inode(dentry->d_parent)->i_version)
 		ret = 0;
 	spin_unlock(&dentry->d_lock);
 	return ret;
@@ -47,7 +47,7 @@ static int vfat_revalidate(struct dentry
 		return -ECHILD;
 
 	/* This is not negative dentry. Always valid. */
-	if (dentry->d_inode)
+	if (d_inode(dentry))
 		return 1;
 	return vfat_revalidate_shortname(dentry);
 }
@@ -67,7 +67,7 @@ static int vfat_revalidate_ci(struct den
 	 * positive dentry isn't good idea. So it's unsupported like
 	 * rename("filename", "FILENAME") for now.
 	 */
-	if (dentry->d_inode)
+	if (d_inode(dentry))
 		return 1;
 
 	/*
@@ -772,10 +772,10 @@ static struct dentry *vfat_lookup(struct
 
 out:
 	unlock_super(sb);
-	dentry->d_time = dentry->d_parent->d_inode->i_version;
+	dentry->d_time = d_inode(dentry->d_parent)->i_version;
 	dentry = d_splice_alias(inode, dentry);
 	if (dentry)
-		dentry->d_time = dentry->d_parent->d_inode->i_version;
+		dentry->d_time = d_inode(dentry->d_parent)->i_version;
 	return dentry;
 
 error:
@@ -810,7 +810,7 @@ static int vfat_create(struct inode *dir
 	inode->i_mtime = inode->i_atime = inode->i_ctime = ts;
 	/* timestamp is already written, so mark_inode_dirty() is unneeded. */
 
-	dentry->d_time = dentry->d_parent->d_inode->i_version;
+	dentry->d_time = d_inode(dentry->d_parent)->i_version;
 	d_instantiate(dentry, inode);
 out:
 	unlock_super(sb);
@@ -819,7 +819,7 @@ out:
 
 static int vfat_rmdir(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct super_block *sb = dir->i_sb;
 	struct fat_slot_info sinfo;
 	int err;
@@ -849,7 +849,7 @@ out:
 
 static int vfat_unlink(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct super_block *sb = dir->i_sb;
 	struct fat_slot_info sinfo;
 	int err;
@@ -906,7 +906,7 @@ static int vfat_mkdir(struct inode *dir,
 	inode->i_mtime = inode->i_atime = inode->i_ctime = ts;
 	/* timestamp is already written, so mark_inode_dirty() is unneeded. */
 
-	dentry->d_time = dentry->d_parent->d_inode->i_version;
+	dentry->d_time = d_inode(dentry->d_parent)->i_version;
 	d_instantiate(dentry, inode);
 
 	unlock_super(sb);
@@ -932,8 +932,8 @@ static int vfat_rename(struct inode *old
 	struct super_block *sb = old_dir->i_sb;
 
 	old_sinfo.bh = sinfo.bh = dotdot_bh = NULL;
-	old_inode = old_dentry->d_inode;
-	new_inode = new_dentry->d_inode;
+	old_inode = d_inode(old_dentry);
+	new_inode = d_inode(new_dentry);
 	lock_super(sb);
 	err = vfat_find(old_dir, &old_dentry->d_name, &old_sinfo);
 	if (err)
diff -u -p a/hppfs/hppfs.c b/hppfs/hppfs.c
--- a/hppfs/hppfs.c
+++ b/hppfs/hppfs.c
@@ -151,9 +151,9 @@ static struct dentry *hppfs_lookup(struc
 		return ERR_PTR(-ENOENT);
 
 	parent = HPPFS_I(ino)->proc_dentry;
-	mutex_lock(&parent->d_inode->i_mutex);
+	mutex_lock(&d_inode(parent)->i_mutex);
 	proc_dentry = lookup_one_len(name->name, parent, name->len);
-	mutex_unlock(&parent->d_inode->i_mutex);
+	mutex_unlock(&d_inode(parent)->i_mutex);
 
 	if (IS_ERR(proc_dentry))
 		return proc_dentry;
@@ -179,7 +179,7 @@ static ssize_t read_proc(struct file *fi
 	ssize_t (*read)(struct file *, char __user *, size_t, loff_t *);
 	ssize_t n;
 
-	read = file->f_path.dentry->d_inode->i_fop->read;
+	read = d_inode(file->f_path.dentry)->i_fop->read;
 
 	if (!is_user)
 		set_fs(KERNEL_DS);
@@ -287,7 +287,7 @@ static ssize_t hppfs_write(struct file *
 	struct file *proc_file = data->proc_file;
 	ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *);
 
-	write = proc_file->f_path.dentry->d_inode->i_fop->write;
+	write = d_inode(proc_file->f_path.dentry)->i_fop->write;
 	return (*write)(proc_file, buf, len, ppos);
 }
 
@@ -516,7 +516,7 @@ static loff_t hppfs_llseek(struct file *
 	loff_t (*llseek)(struct file *, loff_t, int);
 	loff_t ret;
 
-	llseek = proc_file->f_path.dentry->d_inode->i_fop->llseek;
+	llseek = d_inode(proc_file->f_path.dentry)->i_fop->llseek;
 	if (llseek != NULL) {
 		ret = (*llseek)(proc_file, off, where);
 		if (ret < 0)
@@ -564,7 +564,7 @@ static int hppfs_readdir(struct file *fi
 				      });
 	int err;
 
-	readdir = proc_file->f_path.dentry->d_inode->i_fop->readdir;
+	readdir = d_inode(proc_file->f_path.dentry)->i_fop->readdir;
 
 	proc_file->f_pos = file->f_pos;
 	err = (*readdir)(proc_file, &dirent, hppfs_filldir);
@@ -639,25 +639,25 @@ static const struct super_operations hpp
 static int hppfs_readlink(struct dentry *dentry, char __user *buffer,
 			  int buflen)
 {
-	struct dentry *proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;
-	return proc_dentry->d_inode->i_op->readlink(proc_dentry, buffer,
+	struct dentry *proc_dentry = HPPFS_I(d_inode(dentry))->proc_dentry;
+	return d_inode(proc_dentry)->i_op->readlink(proc_dentry, buffer,
 						    buflen);
 }
 
 static void *hppfs_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct dentry *proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;
+	struct dentry *proc_dentry = HPPFS_I(d_inode(dentry))->proc_dentry;
 
-	return proc_dentry->d_inode->i_op->follow_link(proc_dentry, nd);
+	return d_inode(proc_dentry)->i_op->follow_link(proc_dentry, nd);
 }
 
 static void hppfs_put_link(struct dentry *dentry, struct nameidata *nd,
 			   void *cookie)
 {
-	struct dentry *proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;
+	struct dentry *proc_dentry = HPPFS_I(d_inode(dentry))->proc_dentry;
 
-	if (proc_dentry->d_inode->i_op->put_link)
-		proc_dentry->d_inode->i_op->put_link(proc_dentry, nd, cookie);
+	if (d_inode(proc_dentry)->i_op->put_link)
+		d_inode(proc_dentry)->i_op->put_link(proc_dentry, nd, cookie);
 }
 
 static const struct inode_operations hppfs_dir_iops = {
@@ -672,7 +672,7 @@ static const struct inode_operations hpp
 
 static struct inode *get_inode(struct super_block *sb, struct dentry *dentry)
 {
-	struct inode *proc_ino = dentry->d_inode;
+	struct inode *proc_ino = d_inode(dentry);
 	struct inode *inode = new_inode(sb);
 
 	if (!inode) {
@@ -680,10 +680,10 @@ static struct inode *get_inode(struct su
 		return ERR_PTR(-ENOMEM);
 	}
 
-	if (S_ISDIR(dentry->d_inode->i_mode)) {
+	if (S_ISDIR(d_inode(dentry)->i_mode)) {
 		inode->i_op = &hppfs_dir_iops;
 		inode->i_fop = &hppfs_dir_fops;
-	} else if (S_ISLNK(dentry->d_inode->i_mode)) {
+	} else if (S_ISLNK(d_inode(dentry)->i_mode)) {
 		inode->i_op = &hppfs_link_iops;
 		inode->i_fop = &hppfs_file_fops;
 	} else {
diff -u -p a/readdir.c b/readdir.c
--- a/readdir.c
+++ b/readdir.c
@@ -22,7 +22,7 @@
 
 int vfs_readdir(struct file *file, filldir_t filler, void *buf)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	int res = -ENOTDIR;
 	if (!file->f_op || !file->f_op->readdir)
 		goto out;
diff -u -p a/hfs/sysdep.c b/hfs/sysdep.c
--- a/hfs/sysdep.c
+++ b/hfs/sysdep.c
@@ -21,7 +21,7 @@ static int hfs_revalidate_dentry(struct
 	if (nd->flags & LOOKUP_RCU)
 		return -ECHILD;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	if(!inode)
 		return 1;
 
diff -u -p a/hfs/inode.c b/hfs/inode.c
--- a/hfs/inode.c
+++ b/hfs/inode.c
@@ -120,7 +120,7 @@ static ssize_t hfs_direct_IO(int rw, str
 		const struct iovec *iov, loff_t offset, unsigned long nr_segs)
 {
 	struct file *file = iocb->ki_filp;
-	struct inode *inode = file->f_path.dentry->d_inode->i_mapping->host;
+	struct inode *inode = d_inode(file->f_path.dentry)->i_mapping->host;
 	ssize_t ret;
 
 	ret = blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev, iov,
@@ -584,7 +584,7 @@ static int hfs_file_release(struct inode
 
 int hfs_inode_setattr(struct dentry *dentry, struct iattr * attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct hfs_sb_info *hsb = HFS_SB(inode->i_sb);
 	int error;
 
diff -u -p a/hfs/dir.c b/hfs/dir.c
--- a/hfs/dir.c
+++ b/hfs/dir.c
@@ -51,7 +51,7 @@ done:
  */
 static int hfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct super_block *sb = inode->i_sb;
 	int len, err;
 	char strbuf[HFS_MAX_NAMELEN];
@@ -250,7 +250,7 @@ static int hfs_mkdir(struct inode *dir,
  */
 static int hfs_remove(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int res;
 
 	if (S_ISDIR(inode->i_mode) && inode->i_size != 2)
@@ -282,18 +282,18 @@ static int hfs_rename(struct inode *old_
 	int res;
 
 	/* Unlink destination if it already exists */
-	if (new_dentry->d_inode) {
+	if (d_inode(new_dentry)) {
 		res = hfs_remove(new_dir, new_dentry);
 		if (res)
 			return res;
 	}
 
-	res = hfs_cat_move(old_dentry->d_inode->i_ino,
+	res = hfs_cat_move(d_inode(old_dentry)->i_ino,
 			   old_dir, &old_dentry->d_name,
 			   new_dir, &new_dentry->d_name);
 	if (!res)
 		hfs_cat_build_key(old_dir->i_sb,
-				  (btree_key *)&HFS_I(old_dentry->d_inode)->cat_key,
+				  (btree_key *)&HFS_I(d_inode(old_dentry))->cat_key,
 				  new_dir->i_ino, &new_dentry->d_name);
 	return res;
 }
diff -u -p a/hfs/attr.c b/hfs/attr.c
--- a/hfs/attr.c
+++ b/hfs/attr.c
@@ -16,7 +16,7 @@
 int hfs_setxattr(struct dentry *dentry, const char *name,
 		 const void *value, size_t size, int flags)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct hfs_find_data fd;
 	hfs_cat_rec rec;
 	struct hfs_cat_file *file;
@@ -59,7 +59,7 @@ out:
 ssize_t hfs_getxattr(struct dentry *dentry, const char *name,
 			 void *value, size_t size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct hfs_find_data fd;
 	hfs_cat_rec rec;
 	struct hfs_cat_file *file;
@@ -105,7 +105,7 @@ out:
 
 ssize_t hfs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	if (!S_ISREG(inode->i_mode) || HFS_IS_RSRC(inode))
 		return -EOPNOTSUPP;
diff -u -p a/binfmt_elf_fdpic.c b/binfmt_elf_fdpic.c
--- a/binfmt_elf_fdpic.c
+++ b/binfmt_elf_fdpic.c
@@ -916,7 +916,7 @@ static int elf_fdpic_map_file(struct elf
 
 dynamic_error:
 	printk("ELF FDPIC %s with invalid DYNAMIC section (inode=%lu)\n",
-	       what, file->f_path.dentry->d_inode->i_ino);
+	       what, d_inode(file->f_path.dentry)->i_ino);
 	return -ELIBBAD;
 }
 
@@ -1232,7 +1232,7 @@ static int maydump(struct vm_area_struct
 
 	/* By default, dump shared memory if mapped from an anonymous file. */
 	if (vma->vm_flags & VM_SHARED) {
-		if (vma->vm_file->f_path.dentry->d_inode->i_nlink == 0) {
+		if (d_inode(vma->vm_file->f_path.dentry)->i_nlink == 0) {
 			dump_ok = test_bit(MMF_DUMP_ANON_SHARED, &mm_flags);
 			kdcore("%08lx: %08lx: %s (share)", vma->vm_start,
 			       vma->vm_flags, dump_ok ? "yes" : "no");
diff -u -p a/locks.c b/locks.c
--- a/locks.c
+++ b/locks.c
@@ -345,7 +345,7 @@ static int flock_to_posix_lock(struct fi
 		start = filp->f_pos;
 		break;
 	case SEEK_END:
-		start = i_size_read(filp->f_path.dentry->d_inode);
+		start = i_size_read(d_inode(filp->f_path.dentry));
 		break;
 	default:
 		return -EINVAL;
@@ -395,7 +395,7 @@ static int flock64_to_posix_lock(struct
 		start = filp->f_pos;
 		break;
 	case SEEK_END:
-		start = i_size_read(filp->f_path.dentry->d_inode);
+		start = i_size_read(d_inode(filp->f_path.dentry));
 		break;
 	default:
 		return -EINVAL;
@@ -653,7 +653,7 @@ posix_test_lock(struct file *filp, struc
 	struct file_lock *cfl;
 
 	lock_flocks();
-	for (cfl = filp->f_path.dentry->d_inode->i_flock; cfl; cfl = cfl->fl_next) {
+	for (cfl = d_inode(filp->f_path.dentry)->i_flock; cfl; cfl = cfl->fl_next) {
 		if (!IS_POSIX(cfl))
 			continue;
 		if (posix_locks_conflict(fl, cfl))
@@ -734,7 +734,7 @@ static int flock_lock_file(struct file *
 {
 	struct file_lock *new_fl = NULL;
 	struct file_lock **before;
-	struct inode * inode = filp->f_path.dentry->d_inode;
+	struct inode * inode = d_inode(filp->f_path.dentry);
 	int error = 0;
 	int found = 0;
 
@@ -1028,7 +1028,7 @@ static int __posix_lock_file(struct inod
 int posix_lock_file(struct file *filp, struct file_lock *fl,
 			struct file_lock *conflock)
 {
-	return __posix_lock_file(filp->f_path.dentry->d_inode, fl, conflock);
+	return __posix_lock_file(d_inode(filp->f_path.dentry), fl, conflock);
 }
 EXPORT_SYMBOL(posix_lock_file);
 
@@ -1331,8 +1331,8 @@ int fcntl_getlease(struct file *filp)
 	int type = F_UNLCK;
 
 	lock_flocks();
-	time_out_leases(filp->f_path.dentry->d_inode);
-	for (fl = filp->f_path.dentry->d_inode->i_flock; fl && IS_LEASE(fl);
+	time_out_leases(d_inode(filp->f_path.dentry));
+	for (fl = d_inode(filp->f_path.dentry)->i_flock; fl && IS_LEASE(fl);
 			fl = fl->fl_next) {
 		if (fl->fl_file == filp) {
 			type = fl->fl_type & ~F_INPROGRESS;
@@ -1358,7 +1358,7 @@ int generic_setlease(struct file *filp,
 {
 	struct file_lock *fl, **before, **my_before = NULL, *lease;
 	struct dentry *dentry = filp->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error, rdlease_count = 0, wrlease_count = 0;
 
 	lease = *flp;
@@ -1822,7 +1822,7 @@ int fcntl_setlk(unsigned int fd, struct
 	if (copy_from_user(&flock, l, sizeof(flock)))
 		goto out;
 
-	inode = filp->f_path.dentry->d_inode;
+	inode = d_inode(filp->f_path.dentry);
 
 	/* Don't allow mandatory locks on files that may be memory mapped
 	 * and shared.
@@ -1940,7 +1940,7 @@ int fcntl_setlk64(unsigned int fd, struc
 	if (copy_from_user(&flock, l, sizeof(flock)))
 		goto out;
 
-	inode = filp->f_path.dentry->d_inode;
+	inode = d_inode(filp->f_path.dentry);
 
 	/* Don't allow mandatory locks on files that may be memory mapped
 	 * and shared.
@@ -2009,7 +2009,7 @@ void locks_remove_posix(struct file *fil
 	 * posix_lock_file().  Another process could be setting a lock on this
 	 * file at the same time, but we wouldn't remove that lock anyway.
 	 */
-	if (!filp->f_path.dentry->d_inode->i_flock)
+	if (!d_inode(filp->f_path.dentry)->i_flock)
 		return;
 
 	lock.fl_type = F_UNLCK;
@@ -2035,7 +2035,7 @@ EXPORT_SYMBOL(locks_remove_posix);
  */
 void locks_remove_flock(struct file *filp)
 {
-	struct inode * inode = filp->f_path.dentry->d_inode;
+	struct inode * inode = d_inode(filp->f_path.dentry);
 	struct file_lock *fl;
 	struct file_lock **before;
 
@@ -2131,7 +2131,7 @@ static void lock_get_status(struct seq_f
 		fl_pid = fl->fl_pid;
 
 	if (fl->fl_file != NULL)
-		inode = fl->fl_file->f_path.dentry->d_inode;
+		inode = d_inode(fl->fl_file->f_path.dentry);
 
 	seq_printf(f, "%lld:%s ", id, pfx);
 	if (IS_POSIX(fl)) {
diff -u -p a/sysfs/bin.c b/sysfs/bin.c
--- a/sysfs/bin.c
+++ b/sysfs/bin.c
@@ -70,7 +70,7 @@ static ssize_t
 read(struct file *file, char __user *userbuf, size_t bytes, loff_t *off)
 {
 	struct bin_buffer *bb = file->private_data;
-	int size = file->f_path.dentry->d_inode->i_size;
+	int size = d_inode(file->f_path.dentry)->i_size;
 	loff_t offs = *off;
 	int count = min_t(size_t, bytes, PAGE_SIZE);
 	char *temp;
@@ -140,7 +140,7 @@ static ssize_t write(struct file *file,
 		     size_t bytes, loff_t *off)
 {
 	struct bin_buffer *bb = file->private_data;
-	int size = file->f_path.dentry->d_inode->i_size;
+	int size = d_inode(file->f_path.dentry)->i_size;
 	loff_t offs = *off;
 	int count = min_t(size_t, bytes, PAGE_SIZE);
 	char *temp;
@@ -467,7 +467,7 @@ void unmap_bin_file(struct sysfs_dirent
 	mutex_lock(&sysfs_bin_lock);
 
 	hlist_for_each_entry(bb, tmp, &attr_sd->s_bin_attr.buffers, list) {
-		struct inode *inode = bb->file->f_path.dentry->d_inode;
+		struct inode *inode = d_inode(bb->file->f_path.dentry);
 
 		unmap_mapping_range(inode->i_mapping, 0, 0, 1);
 	}
diff -u -p a/sysfs/inode.c b/sysfs/inode.c
--- a/sysfs/inode.c
+++ b/sysfs/inode.c
@@ -106,7 +106,7 @@ int sysfs_sd_setattr(struct sysfs_dirent
 
 int sysfs_setattr(struct dentry *dentry, struct iattr *iattr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct sysfs_dirent *sd = dentry->d_fsdata;
 	int error;
 
@@ -166,12 +166,12 @@ int sysfs_setxattr(struct dentry *dentry
 
 	if (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN)) {
 		const char *suffix = name + XATTR_SECURITY_PREFIX_LEN;
-		error = security_inode_setsecurity(dentry->d_inode, suffix,
-						value, size, flags);
+		error = security_inode_setsecurity(d_inode(dentry), suffix,
+						   value, size, flags);
 		if (error)
 			goto out;
-		error = security_inode_getsecctx(dentry->d_inode,
-						&secdata, &secdata_len);
+		error = security_inode_getsecctx(d_inode(dentry),
+						 &secdata, &secdata_len);
 		if (error)
 			goto out;
 
@@ -236,7 +236,7 @@ static void sysfs_refresh_inode(struct s
 int sysfs_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
 	struct sysfs_dirent *sd = dentry->d_fsdata;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	mutex_lock(&sysfs_mutex);
 	sysfs_refresh_inode(sd, inode);
diff -u -p a/hostfs/hostfs_kern.c b/hostfs/hostfs_kern.c
--- a/hostfs/hostfs_kern.c
+++ b/hostfs/hostfs_kern.c
@@ -30,7 +30,7 @@ static inline struct hostfs_inode_info *
 	return list_entry(inode, struct hostfs_inode_info, vfs_inode);
 }
 
-#define FILE_HOSTFS_I(file) HOSTFS_I((file)->f_path.dentry->d_inode)
+#define FILE_HOSTFS_I(file) HOSTFS_I(d_inode((file)->f_path.dentry))
 
 static int hostfs_d_delete(const struct dentry *dentry)
 {
@@ -776,7 +776,7 @@ int hostfs_permission(struct inode *ino,
 
 int hostfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct hostfs_iattr attrs;
 	char *name;
 	int err;
diff -u -p a/romfs/super.c b/romfs/super.c
--- a/romfs/super.c
+++ b/romfs/super.c
@@ -147,7 +147,7 @@ static const struct address_space_operat
  */
 static int romfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode *i = filp->f_dentry->d_inode;
+	struct inode *i = d_inode(filp->f_dentry);
 	struct romfs_inode ri;
 	unsigned long offset, maxoff;
 	int j, ino, nextfh;
diff -u -p a/qnx4/dir.c b/qnx4/dir.c
--- a/qnx4/dir.c
+++ b/qnx4/dir.c
@@ -16,7 +16,7 @@
 
 static int qnx4_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	unsigned int offset;
 	struct buffer_head *bh;
 	struct qnx4_inode_entry *de;
diff -u -p a/inode.c b/inode.c
--- a/inode.c
+++ b/inode.c
@@ -1445,7 +1445,7 @@ static int relatime_need_update(struct v
  */
 void touch_atime(struct vfsmount *mnt, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct timespec now;
 
 	if (inode->i_flags & S_NOATIME)
@@ -1491,7 +1491,7 @@ EXPORT_SYMBOL(touch_atime);
 
 void file_update_time(struct file *file)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct timespec now;
 	enum { S_MTIME = 1, S_CTIME = 2, S_VERSION = 4 } sync_it = 0;
 
diff -u -p a/udf/file.c b/udf/file.c
--- a/udf/file.c
+++ b/udf/file.c
@@ -107,7 +107,7 @@ static ssize_t udf_file_aio_write(struct
 {
 	ssize_t retval;
 	struct file *file = iocb->ki_filp;
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	int err, pos;
 	size_t count = iocb->ki_left;
 	struct udf_inode_info *iinfo = UDF_I(inode);
@@ -146,7 +146,7 @@ static ssize_t udf_file_aio_write(struct
 
 long udf_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = filp->f_dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_dentry);
 	long old_block, new_block;
 	int result = -EINVAL;
 
@@ -227,7 +227,7 @@ const struct file_operations udf_file_op
 
 static int udf_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	error = inode_change_ok(inode, attr);
diff -u -p a/udf/namei.c b/udf/namei.c
--- a/udf/namei.c
+++ b/udf/namei.c
@@ -778,7 +778,7 @@ static int empty_dir(struct inode *dir)
 static int udf_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int retval;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct udf_fileident_bh fibh;
 	struct fileIdentDesc *fi, cfi;
 	struct kernel_lb_addr tloc;
@@ -821,7 +821,7 @@ out:
 static int udf_unlink(struct inode *dir, struct dentry *dentry)
 {
 	int retval;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct udf_fileident_bh fibh;
 	struct fileIdentDesc *fi;
 	struct fileIdentDesc cfi;
@@ -1031,7 +1031,7 @@ out_no_entry:
 static int udf_link(struct dentry *old_dentry, struct inode *dir,
 		    struct dentry *dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	struct udf_fileident_bh fibh;
 	struct fileIdentDesc cfi, *fi;
 	int err;
@@ -1071,8 +1071,8 @@ static int udf_link(struct dentry *old_d
 static int udf_rename(struct inode *old_dir, struct dentry *old_dentry,
 		      struct inode *new_dir, struct dentry *new_dentry)
 {
-	struct inode *old_inode = old_dentry->d_inode;
-	struct inode *new_inode = new_dentry->d_inode;
+	struct inode *old_inode = d_inode(old_dentry);
+	struct inode *new_inode = d_inode(new_dentry);
 	struct udf_fileident_bh ofibh, nfibh;
 	struct fileIdentDesc *ofi = NULL, *nfi = NULL, *dir_fi = NULL;
 	struct fileIdentDesc ocfi, ncfi;
@@ -1214,7 +1214,7 @@ static struct dentry *udf_get_parent(str
 	struct fileIdentDesc cfi;
 	struct udf_fileident_bh fibh;
 
-	if (!udf_find_entry(child->d_inode, &dotdot, &fibh, &cfi))
+	if (!udf_find_entry(d_inode(child), &dotdot, &fibh, &cfi))
 		goto out_unlock;
 
 	if (fibh.sbh != fibh.ebh)
@@ -1222,7 +1222,7 @@ static struct dentry *udf_get_parent(str
 	brelse(fibh.sbh);
 
 	tloc = lelb_to_cpu(cfi.icb.extLocation);
-	inode = udf_iget(child->d_inode->i_sb, &tloc);
+	inode = udf_iget(d_inode(child)->i_sb, &tloc);
 	if (!inode)
 		goto out_unlock;
 
@@ -1281,7 +1281,7 @@ static int udf_encode_fh(struct dentry *
 			 int connectable)
 {
 	int len = *lenp;
-	struct inode *inode =  de->d_inode;
+	struct inode *inode =  d_inode(de);
 	struct kernel_lb_addr location = UDF_I(inode)->i_location;
 	struct fid *fid = (struct fid *)fh;
 	int type = FILEID_UDF_WITHOUT_PARENT;
@@ -1301,7 +1301,7 @@ static int udf_encode_fh(struct dentry *
 
 	if (connectable && !S_ISDIR(inode->i_mode)) {
 		spin_lock(&de->d_lock);
-		inode = de->d_parent->d_inode;
+		inode = d_inode(de->d_parent);
 		location = UDF_I(inode)->i_location;
 		fid->udf.parent_block = location.logicalBlockNum;
 		fid->udf.parent_partref = location.partitionReferenceNum;
diff -u -p a/udf/dir.c b/udf/dir.c
--- a/udf/dir.c
+++ b/udf/dir.c
@@ -186,7 +186,7 @@ out:
 
 static int udf_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode *dir = filp->f_path.dentry->d_inode;
+	struct inode *dir = d_inode(filp->f_path.dentry);
 	int result;
 
 	if (filp->f_pos == 0) {
diff -u -p a/efs/namei.c b/efs/namei.c
--- a/efs/namei.c
+++ b/efs/namei.c
@@ -110,9 +110,9 @@ struct dentry *efs_get_parent(struct den
 	struct dentry *parent = ERR_PTR(-ENOENT);
 	efs_ino_t ino;
 
-	ino = efs_find_entry(child->d_inode, "..", 2);
+	ino = efs_find_entry(d_inode(child), "..", 2);
 	if (ino)
-		parent = d_obtain_alias(efs_iget(child->d_inode->i_sb, ino));
+		parent = d_obtain_alias(efs_iget(d_inode(child)->i_sb, ino));
 
 	return parent;
 }
diff -u -p a/efs/dir.c b/efs/dir.c
--- a/efs/dir.c
+++ b/efs/dir.c
@@ -20,7 +20,7 @@ const struct inode_operations efs_dir_in
 };
 
 static int efs_readdir(struct file *filp, void *dirent, filldir_t filldir) {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct buffer_head *bh;
 
 	struct efs_dir		*dirblock;
diff -u -p a/afs/super.c b/afs/super.c
--- a/afs/super.c
+++ b/afs/super.c
@@ -522,7 +522,7 @@ static void afs_destroy_inode(struct ino
 static int afs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	struct afs_volume_status vs;
-	struct afs_vnode *vnode = AFS_FS_I(dentry->d_inode);
+	struct afs_vnode *vnode = AFS_FS_I(d_inode(dentry));
 	struct key *key;
 	int ret;
 
diff -u -p a/afs/mntpt.c b/afs/mntpt.c
--- a/afs/mntpt.c
+++ b/afs/mntpt.c
@@ -148,7 +148,7 @@ static struct vfsmount *afs_mntpt_do_aut
 
 	_enter("{%s}", mntpt->d_name.name);
 
-	BUG_ON(!mntpt->d_inode);
+	BUG_ON(!d_inode(mntpt));
 
 	ret = -ENOMEM;
 	devname = (char *) get_zeroed_page(GFP_KERNEL);
@@ -159,7 +159,7 @@ static struct vfsmount *afs_mntpt_do_aut
 	if (!options)
 		goto error_no_options;
 
-	vnode = AFS_FS_I(mntpt->d_inode);
+	vnode = AFS_FS_I(d_inode(mntpt));
 	if (test_bit(AFS_VNODE_PSEUDODIR, &vnode->flags)) {
 		/* if the directory is a pseudo directory, use the d_name */
 		static const char afs_root_cell[] = ":root.cell.";
@@ -183,14 +183,14 @@ static struct vfsmount *afs_mntpt_do_aut
 		}
 	} else {
 		/* read the contents of the AFS special symlink */
-		loff_t size = i_size_read(mntpt->d_inode);
+		loff_t size = i_size_read(d_inode(mntpt));
 		char *buf;
 
 		ret = -EINVAL;
 		if (size > PAGE_SIZE - 1)
 			goto error_no_page;
 
-		page = read_mapping_page(mntpt->d_inode->i_mapping, 0, NULL);
+		page = read_mapping_page(d_inode(mntpt)->i_mapping, 0, NULL);
 		if (IS_ERR(page)) {
 			ret = PTR_ERR(page);
 			goto error_no_page;
diff -u -p a/afs/inode.c b/afs/inode.c
--- a/afs/inode.c
+++ b/afs/inode.c
@@ -379,7 +379,7 @@ int afs_getattr(struct vfsmount *mnt, st
 {
 	struct inode *inode;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	_enter("{ ino=%lu v=%u }", inode->i_ino, inode->i_generation);
 
@@ -458,7 +458,7 @@ void afs_evict_inode(struct inode *inode
  */
 int afs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct afs_vnode *vnode = AFS_FS_I(dentry->d_inode);
+	struct afs_vnode *vnode = AFS_FS_I(d_inode(dentry));
 	struct key *key;
 	int ret;
 
diff -u -p a/afs/flock.c b/afs/flock.c
--- a/afs/flock.c
+++ b/afs/flock.c
@@ -514,7 +514,7 @@ error:
  */
 int afs_lock(struct file *file, int cmd, struct file_lock *fl)
 {
-	struct afs_vnode *vnode = AFS_FS_I(file->f_dentry->d_inode);
+	struct afs_vnode *vnode = AFS_FS_I(d_inode(file->f_dentry));
 
 	_enter("{%x:%u},%d,{t=%x,fl=%x,r=%Ld:%Ld}",
 	       vnode->fid.vid, vnode->fid.vnode, cmd,
@@ -537,7 +537,7 @@ int afs_lock(struct file *file, int cmd,
  */
 int afs_flock(struct file *file, int cmd, struct file_lock *fl)
 {
-	struct afs_vnode *vnode = AFS_FS_I(file->f_dentry->d_inode);
+	struct afs_vnode *vnode = AFS_FS_I(d_inode(file->f_dentry));
 
 	_enter("{%x:%u},%d,{t=%x,fl=%x}",
 	       vnode->fid.vid, vnode->fid.vnode, cmd,
diff -u -p a/afs/write.c b/afs/write.c
--- a/afs/write.c
+++ b/afs/write.c
@@ -120,7 +120,7 @@ int afs_write_begin(struct file *file, s
 		    struct page **pagep, void **fsdata)
 {
 	struct afs_writeback *candidate, *wb;
-	struct afs_vnode *vnode = AFS_FS_I(file->f_dentry->d_inode);
+	struct afs_vnode *vnode = AFS_FS_I(d_inode(file->f_dentry));
 	struct page *page;
 	struct key *key = file->private_data;
 	unsigned from = pos & (PAGE_CACHE_SIZE - 1);
@@ -245,7 +245,7 @@ int afs_write_end(struct file *file, str
 		  loff_t pos, unsigned len, unsigned copied,
 		  struct page *page, void *fsdata)
 {
-	struct afs_vnode *vnode = AFS_FS_I(file->f_dentry->d_inode);
+	struct afs_vnode *vnode = AFS_FS_I(d_inode(file->f_dentry));
 	loff_t i_size, maybe_i_size;
 
 	_enter("{%x:%u},{%lx}",
@@ -628,7 +628,7 @@ ssize_t afs_file_write(struct kiocb *ioc
 		       unsigned long nr_segs, loff_t pos)
 {
 	struct dentry *dentry = iocb->ki_filp->f_path.dentry;
-	struct afs_vnode *vnode = AFS_FS_I(dentry->d_inode);
+	struct afs_vnode *vnode = AFS_FS_I(d_inode(dentry));
 	ssize_t result;
 	size_t count = iov_length(iov, nr_segs);
 
@@ -685,7 +685,7 @@ int afs_fsync(struct file *file, int dat
 {
 	struct dentry *dentry = file->f_path.dentry;
 	struct afs_writeback *wb, *xwb;
-	struct afs_vnode *vnode = AFS_FS_I(dentry->d_inode);
+	struct afs_vnode *vnode = AFS_FS_I(d_inode(dentry));
 	int ret;
 
 	_enter("{%x:%u},{n=%s},%d",
diff -u -p a/ceph/super.c b/ceph/super.c
--- a/ceph/super.c
+++ b/ceph/super.c
@@ -53,7 +53,7 @@ static void ceph_put_super(struct super_
 
 static int ceph_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
-	struct ceph_fs_client *fsc = ceph_inode_to_client(dentry->d_inode);
+	struct ceph_fs_client *fsc = ceph_inode_to_client(d_inode(dentry));
 	struct ceph_monmap *monmap = fsc->client->monc.monmap;
 	struct ceph_statfs st;
 	u64 fsid;
@@ -847,7 +847,7 @@ static struct dentry *ceph_mount(struct
 	if (IS_ERR(res))
 		goto out_splat;
 	dout("root %p inode %p ino %llx.%llx\n", res,
-	     res->d_inode, ceph_vinop(res->d_inode));
+	     d_inode(res), ceph_vinop(d_inode(res)));
 	return res;
 
 out_splat:
diff -u -p a/ceph/caps.c b/ceph/caps.c
--- a/ceph/caps.c
+++ b/ceph/caps.c
@@ -3053,7 +3053,7 @@ int ceph_encode_inode_release(void **p,
 int ceph_encode_dentry_release(void **p, struct dentry *dentry,
 			       int mds, int drop, int unless)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	struct ceph_mds_request_release *rel = *p;
 	struct ceph_dentry_info *di = ceph_dentry(dentry);
 	int force = 0;
diff -u -p a/ceph/locks.c b/ceph/locks.c
--- a/ceph/locks.c
+++ b/ceph/locks.c
@@ -13,7 +13,7 @@
 static int ceph_lock_message(u8 lock_type, u16 operation, struct file *file,
 			     int cmd, u8 wait, struct file_lock *fl)
 {
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	struct ceph_mds_client *mdsc =
 		ceph_sb_to_client(inode->i_sb)->mdsc;
 	struct ceph_mds_request *req;
diff -u -p a/ceph/inode.c b/ceph/inode.c
--- a/ceph/inode.c
+++ b/ceph/inode.c
@@ -809,7 +809,7 @@ static void update_dentry_lease(struct d
 	     dentry, le16_to_cpu(lease->mask), duration, ttl);
 
 	/* make lease_rdcache_gen match directory */
-	dir = dentry->d_parent->d_inode;
+	dir = d_inode(dentry->d_parent);
 	di->lease_shared_gen = ceph_inode(dir)->i_shared_gen;
 
 	if (lease->mask == 0)
@@ -843,7 +843,7 @@ out_unlock:
 static void ceph_set_dentry_offset(struct dentry *dn)
 {
 	struct dentry *dir = dn->d_parent;
-	struct inode *inode = dn->d_parent->d_inode;
+	struct inode *inode = d_inode(dn->d_parent);
 	struct ceph_dentry_info *di;
 
 	BUG_ON(!inode);
@@ -880,7 +880,7 @@ static struct dentry *splice_dentry(stru
 {
 	struct dentry *realdn;
 
-	BUG_ON(dn->d_inode);
+	BUG_ON(d_inode(dn));
 
 	/* dn must be unhashed */
 	if (!d_unhashed(dn))
@@ -898,13 +898,13 @@ static struct dentry *splice_dentry(stru
 		     "inode %p ino %llx.%llx\n",
 		     dn, dn->d_count,
 		     realdn, realdn->d_count,
-		     realdn->d_inode, ceph_vinop(realdn->d_inode));
+		     d_inode(realdn), ceph_vinop(d_inode(realdn)));
 		dput(dn);
 		dn = realdn;
 	} else {
 		BUG_ON(!ceph_dentry(dn));
 		dout("dn %p attached to %p ino %llx.%llx\n",
-		     dn, dn->d_inode, ceph_vinop(dn->d_inode));
+		     dn, d_inode(dn), ceph_vinop(d_inode(dn)));
 	}
 	if ((!prehash || *prehash) && d_unhashed(dn))
 		d_rehash(dn);
@@ -1009,7 +1009,7 @@ int ceph_fill_trace(struct super_block *
 
 		BUG_ON(!dn);
 		BUG_ON(!dir);
-		BUG_ON(dn->d_parent->d_inode != dir);
+		BUG_ON(d_inode(dn->d_parent) != dir);
 		BUG_ON(ceph_ino(dir) !=
 		       le64_to_cpu(rinfo->diri.in->ino));
 		BUG_ON(ceph_snap(dir) !=
@@ -1060,13 +1060,13 @@ int ceph_fill_trace(struct super_block *
 			     ceph_dentry(req->r_old_dentry)->offset);
 
 			dn = req->r_old_dentry;  /* use old_dentry */
-			in = dn->d_inode;
+			in = d_inode(dn);
 		}
 
 		/* null dentry? */
 		if (!rinfo->head->is_target) {
 			dout("fill_trace null dentry\n");
-			if (dn->d_inode) {
+			if (d_inode(dn)) {
 				dout("d_delete %p\n", dn);
 				d_delete(dn);
 			} else {
@@ -1085,7 +1085,7 @@ int ceph_fill_trace(struct super_block *
 		ininfo = rinfo->targeti.in;
 		vino.ino = le64_to_cpu(ininfo->ino);
 		vino.snap = le64_to_cpu(ininfo->snapid);
-		in = dn->d_inode;
+		in = d_inode(dn);
 		if (!in) {
 			in = ceph_get_inode(sb, vino);
 			if (IS_ERR(in)) {
@@ -1198,7 +1198,7 @@ int ceph_readdir_prepopulate(struct ceph
 	struct ceph_dentry_info *di;
 
 	if (le32_to_cpu(rinfo->head->op) == CEPH_MDS_OP_LSSNAP) {
-		snapdir = ceph_get_snapdir(parent->d_inode);
+		snapdir = ceph_get_snapdir(d_inode(parent));
 		parent = d_find_alias(snapdir);
 		dout("readdir_prepopulate %d items under SNAPDIR dn %p\n",
 		     rinfo->dir_nr, parent);
@@ -1206,7 +1206,7 @@ int ceph_readdir_prepopulate(struct ceph
 		dout("readdir_prepopulate %d items under dn %p\n",
 		     rinfo->dir_nr, parent);
 		if (rinfo->dir_dir)
-			ceph_fill_dirfrag(parent->d_inode, rinfo->dir_dir);
+			ceph_fill_dirfrag(d_inode(parent), rinfo->dir_dir);
 	}
 
 	for (i = 0; i < rinfo->dir_nr; i++) {
@@ -1238,11 +1238,11 @@ retry_lookup:
 				dput(dn);
 				goto out;
 			}
-		} else if (dn->d_inode &&
-			   (ceph_ino(dn->d_inode) != vino.ino ||
-			    ceph_snap(dn->d_inode) != vino.snap)) {
+		} else if (d_inode(dn) &&
+			   (ceph_ino(d_inode(dn)) != vino.ino ||
+			    ceph_snap(d_inode(dn)) != vino.snap)) {
 			dout(" dn %p points to wrong inode %p\n",
-			     dn, dn->d_inode);
+			     dn, d_inode(dn));
 			d_delete(dn);
 			dput(dn);
 			goto retry_lookup;
@@ -1259,8 +1259,8 @@ retry_lookup:
 		di->offset = ceph_make_fpos(frag, i + req->r_readdir_offset);
 
 		/* inode */
-		if (dn->d_inode) {
-			in = dn->d_inode;
+		if (d_inode(dn)) {
+			in = d_inode(dn);
 		} else {
 			in = ceph_get_inode(parent->d_sb, vino);
 			if (IS_ERR(in)) {
@@ -1543,7 +1543,7 @@ retry:
  */
 static void *ceph_sym_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct ceph_inode_info *ci = ceph_inode(dentry->d_inode);
+	struct ceph_inode_info *ci = ceph_inode(d_inode(dentry));
 	nd_set_link(nd, ci->i_symlink);
 	return NULL;
 }
@@ -1558,9 +1558,9 @@ static const struct inode_operations cep
  */
 int ceph_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
-	struct inode *parent_inode = dentry->d_parent->d_inode;
+	struct inode *parent_inode = d_inode(dentry->d_parent);
 	const unsigned int ia_valid = attr->ia_valid;
 	struct ceph_mds_request *req;
 	struct ceph_mds_client *mdsc = ceph_sb_to_client(dentry->d_sb)->mdsc;
@@ -1816,7 +1816,7 @@ int ceph_permission(struct inode *inode,
 int ceph_getattr(struct vfsmount *mnt, struct dentry *dentry,
 		 struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	int err;
 
diff -u -p a/ceph/file.c b/ceph/file.c
--- a/ceph/file.c
+++ b/ceph/file.c
@@ -122,7 +122,7 @@ int ceph_open(struct inode *inode, struc
 	struct ceph_mds_client *mdsc = fsc->mdsc;
 	struct ceph_mds_request *req;
 	struct ceph_file_info *cf = file->private_data;
-	struct inode *parent_inode = file->f_dentry->d_parent->d_inode;
+	struct inode *parent_inode = d_inode(file->f_dentry->d_parent);
 	int err;
 	int flags, fmode, wanted;
 
@@ -247,7 +247,7 @@ struct dentry *ceph_lookup_open(struct i
 	if (!err && (flags & O_CREAT) && !req->r_reply_info.head->is_dentry)
 		err = ceph_handle_notrace_create(dir, dentry);
 	if (!err)
-		err = ceph_init_file(req->r_dentry->d_inode, file,
+		err = ceph_init_file(d_inode(req->r_dentry), file,
 				     req->r_fmode);
 	ceph_mdsc_put_request(req);
 	dout("ceph_lookup_open result=%p\n", dentry);
@@ -375,7 +375,7 @@ more:
 static ssize_t ceph_sync_read(struct file *file, char __user *data,
 			      unsigned len, loff_t *poff, int *checkeof)
 {
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	struct page **pages;
 	u64 off = *poff;
 	int num_pages, ret;
@@ -448,7 +448,7 @@ static void sync_write_commit(struct cep
 static ssize_t ceph_sync_write(struct file *file, const char __user *data,
 			       size_t left, loff_t *offset)
 {
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	struct ceph_fs_client *fsc = ceph_inode_to_client(inode);
 	struct ceph_osd_request *req;
@@ -465,7 +465,7 @@ static ssize_t ceph_sync_write(struct fi
 	int ret;
 	struct timespec mtime = CURRENT_TIME;
 
-	if (ceph_snap(file->f_dentry->d_inode) != CEPH_NOSNAP)
+	if (ceph_snap(d_inode(file->f_dentry)) != CEPH_NOSNAP)
 		return -EROFS;
 
 	dout("sync_write on file %p %lld~%u %s\n", file, *offset,
@@ -619,7 +619,7 @@ static ssize_t ceph_aio_read(struct kioc
 	struct ceph_file_info *fi = filp->private_data;
 	loff_t *ppos = &iocb->ki_pos;
 	size_t len = iov->iov_len;
-	struct inode *inode = filp->f_dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	void __user *base = iov->iov_base;
 	ssize_t ret;
@@ -688,7 +688,7 @@ static ssize_t ceph_aio_write(struct kio
 {
 	struct file *file = iocb->ki_filp;
 	struct ceph_file_info *fi = file->private_data;
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	struct ceph_osd_client *osdc =
 		&ceph_sb_to_client(inode->i_sb)->client->osdc;
diff -u -p a/ceph/debugfs.c b/ceph/debugfs.c
--- a/ceph/debugfs.c
+++ b/ceph/debugfs.c
@@ -84,7 +84,7 @@ static int mdsc_show(struct seq_file *s,
 				path = NULL;
 			spin_lock(&req->r_dentry->d_lock);
 			seq_printf(s, " #%llx/%.*s (%s)",
-				   ceph_ino(req->r_dentry->d_parent->d_inode),
+				   ceph_ino(d_inode(req->r_dentry->d_parent)),
 				   req->r_dentry->d_name.len,
 				   req->r_dentry->d_name.name,
 				   path ? path : "");
@@ -102,10 +102,10 @@ static int mdsc_show(struct seq_file *s,
 				path = NULL;
 			spin_lock(&req->r_old_dentry->d_lock);
 			seq_printf(s, " #%llx/%.*s (%s)",
-			   ceph_ino(req->r_old_dentry->d_parent->d_inode),
-				   req->r_old_dentry->d_name.len,
-				   req->r_old_dentry->d_name.name,
-				   path ? path : "");
+			   ceph_ino(d_inode(req->r_old_dentry->d_parent)),
+			   req->r_old_dentry->d_name.len,
+			   req->r_old_dentry->d_name.name,
+			   path ? path : "");
 			spin_unlock(&req->r_old_dentry->d_lock);
 			kfree(path);
 		} else if (req->r_path2) {
diff -u -p a/ceph/dir.c b/ceph/dir.c
--- a/ceph/dir.c
+++ b/ceph/dir.c
@@ -41,9 +41,9 @@ int ceph_init_dentry(struct dentry *dent
 		return 0;
 
 	if (dentry->d_parent == NULL ||   /* nfs fh_to_dentry */
-	    ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP)
+	    ceph_snap(d_inode(dentry->d_parent)) == CEPH_NOSNAP)
 		d_set_d_op(dentry, &ceph_dentry_ops);
-	else if (ceph_snap(dentry->d_parent->d_inode) == CEPH_SNAPDIR)
+	else if (ceph_snap(d_inode(dentry->d_parent)) == CEPH_SNAPDIR)
 		d_set_d_op(dentry, &ceph_snapdir_dentry_ops);
 	else
 		d_set_d_op(dentry, &ceph_snap_dentry_ops);
@@ -99,7 +99,7 @@ static int __dcache_readdir(struct file
 {
 	struct ceph_file_info *fi = filp->private_data;
 	struct dentry *parent = filp->f_dentry;
-	struct inode *dir = parent->d_inode;
+	struct inode *dir = d_inode(parent);
 	struct list_head *p;
 	struct dentry *dentry, *last;
 	struct ceph_dentry_info *di;
@@ -137,15 +137,15 @@ more:
 			goto out_unlock;
 		}
 		spin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);
-		if (!d_unhashed(dentry) && dentry->d_inode &&
-		    ceph_snap(dentry->d_inode) != CEPH_SNAPDIR &&
-		    ceph_ino(dentry->d_inode) != CEPH_INO_CEPH &&
+		if (!d_unhashed(dentry) && d_inode(dentry) &&
+		    ceph_snap(d_inode(dentry)) != CEPH_SNAPDIR &&
+		    ceph_ino(d_inode(dentry)) != CEPH_INO_CEPH &&
 		    filp->f_pos <= di->offset)
 			break;
 		dout(" skipping %p %.*s at %llu (%llu)%s%s\n", dentry,
 		     dentry->d_name.len, dentry->d_name.name, di->offset,
 		     filp->f_pos, d_unhashed(dentry) ? " unhashed" : "",
-		     !dentry->d_inode ? " null" : "");
+		     !d_inode(dentry) ? " null" : "");
 		spin_unlock(&dentry->d_lock);
 		p = p->prev;
 		dentry = list_entry(p, struct dentry, d_u.d_child);
@@ -157,12 +157,12 @@ more:
 	spin_unlock(&parent->d_lock);
 
 	dout(" %llu (%llu) dentry %p %.*s %p\n", di->offset, filp->f_pos,
-	     dentry, dentry->d_name.len, dentry->d_name.name, dentry->d_inode);
+	     dentry, dentry->d_name.len, dentry->d_name.name, d_inode(dentry));
 	filp->f_pos = di->offset;
 	err = filldir(dirent, dentry->d_name.name,
 		      dentry->d_name.len, di->offset,
-		      ceph_translate_ino(dentry->d_sb, dentry->d_inode->i_ino),
-		      dentry->d_inode->i_mode >> 12);
+		      ceph_translate_ino(dentry->d_sb, d_inode(dentry)->i_ino),
+		      d_inode(dentry)->i_mode >> 12);
 
 	if (last) {
 		if (err < 0) {
@@ -221,7 +221,7 @@ static int note_last_dentry(struct ceph_
 static int ceph_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
 	struct ceph_file_info *fi = filp->private_data;
-	struct inode *inode = filp->f_dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	struct ceph_fs_client *fsc = ceph_inode_to_client(inode);
 	struct ceph_mds_client *mdsc = fsc->mdsc;
@@ -252,7 +252,7 @@ static int ceph_readdir(struct file *fil
 		off = 1;
 	}
 	if (filp->f_pos == 1) {
-		ino_t ino = filp->f_dentry->d_parent->d_inode->i_ino;
+		ino_t ino = d_inode(filp->f_dentry->d_parent)->i_ino;
 		dout("readdir off 1 -> '..'\n");
 		if (filldir(dirent, "..", 2, ceph_make_fpos(0, 1),
 			    ceph_translate_ino(inode->i_sb, ino),
@@ -496,7 +496,7 @@ struct dentry *ceph_finish_lookup(struct
 				  struct dentry *dentry, int err)
 {
 	struct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);
-	struct inode *parent = dentry->d_parent->d_inode;
+	struct inode *parent = d_inode(dentry->d_parent);
 
 	/* .snap dir? */
 	if (err == -ENOENT &&
@@ -516,8 +516,8 @@ struct dentry *ceph_finish_lookup(struct
 		err = 0;
 		if (!req->r_reply_info.head->is_dentry) {
 			dout("ENOENT and no trace, dentry %p inode %p\n",
-			     dentry, dentry->d_inode);
-			if (dentry->d_inode) {
+			     dentry, d_inode(dentry));
+			if (d_inode(dentry)) {
 				d_drop(dentry);
 				err = -ENOENT;
 			} else {
@@ -573,7 +573,7 @@ static struct dentry *ceph_lookup(struct
 	}
 
 	/* can we conclude ENOENT locally? */
-	if (dentry->d_inode == NULL) {
+	if (d_inode(dentry) == NULL) {
 		struct ceph_inode_info *ci = ceph_inode(dir);
 		struct ceph_dentry_info *di = ceph_dentry(dentry);
 
@@ -627,8 +627,8 @@ int ceph_handle_notrace_create(struct in
 		 * dentry to that inode, but don't hash it, just in
 		 * case the VFS wants to dereference it.
 		 */
-		BUG_ON(!result->d_inode);
-		d_instantiate(dentry, result->d_inode);
+		BUG_ON(!d_inode(result));
+		d_instantiate(dentry, d_inode(result));
 		return 0;
 	}
 	return PTR_ERR(result);
@@ -791,8 +791,8 @@ static int ceph_link(struct dentry *old_
 	if (err) {
 		d_drop(dentry);
 	} else if (!req->r_reply_info.head->is_dentry) {
-		ihold(old_dentry->d_inode);
-		d_instantiate(dentry, old_dentry->d_inode);
+		ihold(d_inode(old_dentry));
+		d_instantiate(dentry, d_inode(old_dentry));
 	}
 	ceph_mdsc_put_request(req);
 	return err;
@@ -825,7 +825,7 @@ static int ceph_unlink(struct inode *dir
 {
 	struct ceph_fs_client *fsc = ceph_sb_to_client(dir->i_sb);
 	struct ceph_mds_client *mdsc = fsc->mdsc;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ceph_mds_request *req;
 	int err = -EROFS;
 	int op;
@@ -838,7 +838,7 @@ static int ceph_unlink(struct inode *dir
 	} else if (ceph_snap(dir) == CEPH_NOSNAP) {
 		dout("unlink/rmdir dir %p dn %p inode %p\n",
 		     dir, dentry, inode);
-		op = ((dentry->d_inode->i_mode & S_IFMT) == S_IFDIR) ?
+		op = ((d_inode(dentry)->i_mode & S_IFMT) == S_IFDIR) ?
 			CEPH_MDS_OP_RMDIR : CEPH_MDS_OP_UNLINK;
 	} else
 		goto out;
@@ -889,8 +889,8 @@ static int ceph_rename(struct inode *old
 	req->r_dentry_unless = CEPH_CAP_FILE_EXCL;
 	/* release LINK_RDCACHE on source inode (mds will lock it) */
 	req->r_old_inode_drop = CEPH_CAP_LINK_SHARED;
-	if (new_dentry->d_inode)
-		req->r_inode_drop = drop_caps_for_unlink(new_dentry->d_inode);
+	if (d_inode(new_dentry))
+		req->r_inode_drop = drop_caps_for_unlink(d_inode(new_dentry));
 	err = ceph_mdsc_do_request(mdsc, old_dir, req);
 	if (!err && !req->r_reply_info.head->is_dentry) {
 		/*
@@ -954,7 +954,7 @@ static int dentry_lease_is_valid(struct
 			if (di->lease_renew_after &&
 			    time_after(jiffies, di->lease_renew_after)) {
 				/* we should renew */
-				dir = dentry->d_parent->d_inode;
+				dir = d_inode(dentry->d_parent);
 				session = ceph_get_mds_session(s);
 				seq = di->lease_seq;
 				di->lease_renew_after = 0;
@@ -1002,19 +1002,19 @@ static int ceph_d_revalidate(struct dent
 	if (nd && nd->flags & LOOKUP_RCU)
 		return -ECHILD;
 
-	dir = dentry->d_parent->d_inode;
+	dir = d_inode(dentry->d_parent);
 
 	dout("d_revalidate %p '%.*s' inode %p offset %lld\n", dentry,
-	     dentry->d_name.len, dentry->d_name.name, dentry->d_inode,
+	     dentry->d_name.len, dentry->d_name.name, d_inode(dentry),
 	     ceph_dentry(dentry)->offset);
 
 	/* always trust cached snapped dentries, snapdir dentry */
 	if (ceph_snap(dir) != CEPH_NOSNAP) {
 		dout("d_revalidate %p '%.*s' inode %p is SNAPPED\n", dentry,
-		     dentry->d_name.len, dentry->d_name.name, dentry->d_inode);
+		     dentry->d_name.len, dentry->d_name.name, d_inode(dentry));
 		goto out_touch;
 	}
-	if (dentry->d_inode && ceph_snap(dentry->d_inode) == CEPH_SNAPDIR)
+	if (d_inode(dentry) && ceph_snap(d_inode(dentry)) == CEPH_SNAPDIR)
 		goto out_touch;
 
 	if (dentry_lease_is_valid(dentry) ||
@@ -1066,7 +1066,7 @@ static ssize_t ceph_read_dir(struct file
 			     loff_t *ppos)
 {
 	struct ceph_file_info *cf = file->private_data;
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	int left;
 	const int bufsize = 1024;
@@ -1115,7 +1115,7 @@ static ssize_t ceph_read_dir(struct file
  */
 static int ceph_dir_fsync(struct file *file, int datasync)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	struct list_head *head = &ci->i_unsafe_dirops;
 	struct ceph_mds_request *req;
@@ -1217,7 +1217,7 @@ void ceph_dentry_lru_del(struct dentry *
  */
 unsigned ceph_dentry_hash(struct dentry *dn)
 {
-	struct inode *dir = dn->d_parent->d_inode;
+	struct inode *dir = d_inode(dn->d_parent);
 	struct ceph_inode_info *dci = ceph_inode(dir);
 
 	switch (dci->i_dir_layout.dl_dir_hash) {
diff -u -p a/ceph/export.c b/ceph/export.c
--- a/ceph/export.c
+++ b/ceph/export.c
@@ -47,7 +47,7 @@ static int ceph_encode_fh(struct dentry
 	struct ceph_nfs_fh *fh = (void *)rawfh;
 	struct ceph_nfs_confh *cfh = (void *)rawfh;
 	struct dentry *parent = dentry->d_parent;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int connected_handle_length = sizeof(*cfh)/4;
 	int handle_length = sizeof(*fh)/4;
 
@@ -57,8 +57,8 @@ static int ceph_encode_fh(struct dentry
 
 	if (*max_len >= connected_handle_length) {
 		dout("encode_fh %p connectable\n", dentry);
-		cfh->ino = ceph_ino(dentry->d_inode);
-		cfh->parent_ino = ceph_ino(parent->d_inode);
+		cfh->ino = ceph_ino(d_inode(dentry));
+		cfh->parent_ino = ceph_ino(d_inode(parent));
 		cfh->parent_name_hash = ceph_dentry_hash(parent);
 		*max_len = connected_handle_length;
 		type = 2;
@@ -68,7 +68,7 @@ static int ceph_encode_fh(struct dentry
 			return 255;
 		}
 		dout("encode_fh %p\n", dentry);
-		fh->ino = ceph_ino(dentry->d_inode);
+		fh->ino = ceph_ino(d_inode(dentry));
 		*max_len = handle_length;
 		type = 1;
 	} else {
diff -u -p a/ceph/ioctl.c b/ceph/ioctl.c
--- a/ceph/ioctl.c
+++ b/ceph/ioctl.c
@@ -16,11 +16,11 @@
  */
 static long ceph_ioctl_get_layout(struct file *file, void __user *arg)
 {
-	struct ceph_inode_info *ci = ceph_inode(file->f_dentry->d_inode);
+	struct ceph_inode_info *ci = ceph_inode(d_inode(file->f_dentry));
 	struct ceph_ioctl_layout l;
 	int err;
 
-	err = ceph_do_getattr(file->f_dentry->d_inode, CEPH_STAT_CAP_LAYOUT);
+	err = ceph_do_getattr(d_inode(file->f_dentry), CEPH_STAT_CAP_LAYOUT);
 	if (!err) {
 		l.stripe_unit = ceph_file_layout_su(ci->i_layout);
 		l.stripe_count = ceph_file_layout_stripe_count(ci->i_layout);
@@ -37,8 +37,8 @@ static long ceph_ioctl_get_layout(struct
 
 static long ceph_ioctl_set_layout(struct file *file, void __user *arg)
 {
-	struct inode *inode = file->f_dentry->d_inode;
-	struct inode *parent_inode = file->f_dentry->d_parent->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
+	struct inode *parent_inode = d_inode(file->f_dentry->d_parent);
 	struct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;
 	struct ceph_mds_request *req;
 	struct ceph_ioctl_layout l;
@@ -100,7 +100,7 @@ static long ceph_ioctl_set_layout(struct
  */
 static long ceph_ioctl_set_layout_policy (struct file *file, void __user *arg)
 {
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	struct ceph_mds_request *req;
 	struct ceph_ioctl_layout l;
 	int err, i;
@@ -162,7 +162,7 @@ static long ceph_ioctl_set_layout_policy
 static long ceph_ioctl_get_dataloc(struct file *file, void __user *arg)
 {
 	struct ceph_ioctl_dataloc dl;
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	struct ceph_osd_client *osdc =
 		&ceph_sb_to_client(inode->i_sb)->client->osdc;
@@ -213,7 +213,7 @@ static long ceph_ioctl_get_dataloc(struc
 static long ceph_ioctl_lazyio(struct file *file)
 {
 	struct ceph_file_info *fi = file->private_data;
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 
 	if ((fi->fmode & CEPH_FILE_MODE_LAZY) == 0) {
diff -u -p a/ceph/addr.c b/ceph/addr.c
--- a/ceph/addr.c
+++ b/ceph/addr.c
@@ -192,7 +192,7 @@ static int ceph_releasepage(struct page
  */
 static int readpage_nounlock(struct file *filp, struct page *page)
 {
-	struct inode *inode = filp->f_dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	struct ceph_osd_client *osdc = 
 		&ceph_inode_to_client(inode)->client->osdc;
@@ -265,7 +265,7 @@ static struct page **page_vector_from_li
 static int ceph_readpages(struct file *file, struct address_space *mapping,
 			  struct list_head *page_list, unsigned nr_pages)
 {
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	struct ceph_osd_client *osdc =
 		&ceph_inode_to_client(inode)->client->osdc;
@@ -913,7 +913,7 @@ static int ceph_update_writeable_page(st
 			    loff_t pos, unsigned len,
 			    struct page *page)
 {
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	struct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;
 	loff_t page_off = pos & PAGE_CACHE_MASK;
@@ -1022,7 +1022,7 @@ static int ceph_write_begin(struct file
 			    loff_t pos, unsigned len, unsigned flags,
 			    struct page **pagep, void **fsdata)
 {
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	struct page *page;
 	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
 	int r;
@@ -1052,7 +1052,7 @@ static int ceph_write_end(struct file *f
 			  loff_t pos, unsigned len, unsigned copied,
 			  struct page *page, void *fsdata)
 {
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	struct ceph_fs_client *fsc = ceph_inode_to_client(inode);
 	struct ceph_mds_client *mdsc = fsc->mdsc;
 	unsigned from = pos & (PAGE_CACHE_SIZE - 1);
@@ -1121,7 +1121,7 @@ const struct address_space_operations ce
  */
 static int ceph_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)
 {
-	struct inode *inode = vma->vm_file->f_dentry->d_inode;
+	struct inode *inode = d_inode(vma->vm_file->f_dentry);
 	struct page *page = vmf->page;
 	struct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;
 	loff_t off = page->index << PAGE_CACHE_SHIFT;
diff -u -p a/ceph/mds_client.c b/ceph/mds_client.c
--- a/ceph/mds_client.c
+++ b/ceph/mds_client.c
@@ -496,7 +496,7 @@ void ceph_mdsc_release_request(struct kr
 		dput(req->r_dentry);
 	if (req->r_old_dentry) {
 		ceph_put_cap_refs(
-			ceph_inode(req->r_old_dentry->d_parent->d_inode),
+			ceph_inode(d_inode(req->r_old_dentry->d_parent)),
 			CEPH_CAP_PIN);
 		dput(req->r_old_dentry);
 	}
@@ -617,7 +617,7 @@ static void __unregister_request(struct
  */
 struct dentry *get_nonsnap_parent(struct dentry *dentry)
 {
-	while (!IS_ROOT(dentry) && ceph_snap(dentry->d_inode) != CEPH_NOSNAP)
+	while (!IS_ROOT(dentry) && ceph_snap(d_inode(dentry)) != CEPH_NOSNAP)
 		dentry = dentry->d_parent;
 	return dentry;
 }
@@ -652,21 +652,21 @@ static int __choose_mds(struct ceph_mds_
 	if (req->r_inode) {
 		inode = req->r_inode;
 	} else if (req->r_dentry) {
-		struct inode *dir = req->r_dentry->d_parent->d_inode;
+		struct inode *dir = d_inode(req->r_dentry->d_parent);
 
 		if (dir->i_sb != mdsc->fsc->sb) {
 			/* not this fs! */
-			inode = req->r_dentry->d_inode;
+			inode = d_inode(req->r_dentry);
 		} else if (ceph_snap(dir) != CEPH_NOSNAP) {
 			/* direct snapped/virtual snapdir requests
 			 * based on parent dir inode */
 			struct dentry *dn =
 				get_nonsnap_parent(req->r_dentry->d_parent);
-			inode = dn->d_inode;
+			inode = d_inode(dn);
 			dout("__choose_mds using nonsnap parent %p\n", inode);
-		} else if (req->r_dentry->d_inode) {
+		} else if (d_inode(req->r_dentry)) {
 			/* dentry target */
-			inode = req->r_dentry->d_inode;
+			inode = d_inode(req->r_dentry);
 		} else {
 			/* dir + name */
 			inode = dir;
@@ -1448,7 +1448,7 @@ retry:
 	seq = read_seqbegin(&rename_lock);
 	rcu_read_lock();
 	for (temp = dentry; !IS_ROOT(temp);) {
-		struct inode *inode = temp->d_inode;
+		struct inode *inode = d_inode(temp);
 		if (inode && ceph_snap(inode) == CEPH_SNAPDIR)
 			len++;  /* slash only */
 		else if (stop_on_nosnap && inode &&
@@ -1477,7 +1477,7 @@ retry:
 		struct inode *inode;
 
 		spin_lock(&temp->d_lock);
-		inode = temp->d_inode;
+		inode = d_inode(temp);
 		if (inode && ceph_snap(inode) == CEPH_SNAPDIR) {
 			dout("build_path path+%d: %p SNAPDIR\n",
 			     pos, temp);
@@ -1516,7 +1516,7 @@ retry:
 		goto retry;
 	}
 
-	*base = ceph_ino(temp->d_inode);
+	*base = ceph_ino(d_inode(temp));
 	*plen = len;
 	dout("build_path on %p %d built %llx '%.*s'\n",
 	     dentry, dentry->d_count, *base, len, path);
@@ -1529,8 +1529,8 @@ static int build_dentry_path(struct dent
 {
 	char *path;
 
-	if (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP) {
-		*pino = ceph_ino(dentry->d_parent->d_inode);
+	if (ceph_snap(d_inode(dentry->d_parent)) == CEPH_NOSNAP) {
+		*pino = ceph_ino(d_inode(dentry->d_parent));
 		*ppath = dentry->d_name.name;
 		*ppathlen = dentry->d_name.len;
 		return 0;
@@ -1669,7 +1669,7 @@ static struct ceph_msg *create_request_m
 	releases = 0;
 	if (req->r_inode_drop)
 		releases += ceph_encode_inode_release(&p,
-		      req->r_inode ? req->r_inode : req->r_dentry->d_inode,
+		      req->r_inode ? req->r_inode : d_inode(req->r_dentry),
 		      mds, req->r_inode_drop, req->r_inode_unless, 0);
 	if (req->r_dentry_drop)
 		releases += ceph_encode_dentry_release(&p, req->r_dentry,
@@ -1679,7 +1679,7 @@ static struct ceph_msg *create_request_m
 		       mds, req->r_old_dentry_drop, req->r_old_dentry_unless);
 	if (req->r_old_inode_drop)
 		releases += ceph_encode_inode_release(&p,
-		      req->r_old_dentry->d_inode,
+		      d_inode(req->r_old_dentry),
 		      mds, req->r_old_inode_drop, req->r_old_inode_unless, 0);
 	head->num_releases = cpu_to_le16(releases);
 
@@ -1932,7 +1932,7 @@ int ceph_mdsc_do_request(struct ceph_mds
 		ceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);
 	if (req->r_old_dentry)
 		ceph_get_cap_refs(
-			ceph_inode(req->r_old_dentry->d_parent->d_inode),
+			ceph_inode(d_inode(req->r_old_dentry->d_parent)),
 			CEPH_CAP_PIN);
 
 	/* issue */
diff -u -p a/ceph/xattr.c b/ceph/xattr.c
--- a/ceph/xattr.c
+++ b/ceph/xattr.c
@@ -498,7 +498,7 @@ void __ceph_build_xattrs_blob(struct cep
 ssize_t ceph_getxattr(struct dentry *dentry, const char *name, void *value,
 		      size_t size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	struct ceph_vxattr_cb *vxattrs = ceph_inode_vxattrs(inode);
 	int err;
@@ -564,7 +564,7 @@ out:
 
 ssize_t ceph_listxattr(struct dentry *dentry, char *names, size_t size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	struct ceph_vxattr_cb *vxattrs = ceph_inode_vxattrs(inode);
 	u32 vir_namelen = 0;
@@ -627,9 +627,9 @@ static int ceph_sync_setxattr(struct den
 			      const char *value, size_t size, int flags)
 {
 	struct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
-	struct inode *parent_inode = dentry->d_parent->d_inode;
+	struct inode *parent_inode = d_inode(dentry->d_parent);
 	struct ceph_mds_request *req;
 	struct ceph_mds_client *mdsc = fsc->mdsc;
 	int err;
@@ -693,7 +693,7 @@ out:
 int ceph_setxattr(struct dentry *dentry, const char *name,
 		  const void *value, size_t size, int flags)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	struct ceph_vxattr_cb *vxattrs = ceph_inode_vxattrs(inode);
 	int err;
@@ -787,8 +787,8 @@ static int ceph_send_removexattr(struct
 {
 	struct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);
 	struct ceph_mds_client *mdsc = fsc->mdsc;
-	struct inode *inode = dentry->d_inode;
-	struct inode *parent_inode = dentry->d_parent->d_inode;
+	struct inode *inode = d_inode(dentry);
+	struct inode *parent_inode = d_inode(dentry->d_parent);
 	struct ceph_mds_request *req;
 	int err;
 
@@ -809,7 +809,7 @@ static int ceph_send_removexattr(struct
 
 int ceph_removexattr(struct dentry *dentry, const char *name)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	struct ceph_vxattr_cb *vxattrs = ceph_inode_vxattrs(inode);
 	int issued;
diff -u -p a/hfsplus/inode.c b/hfsplus/inode.c
--- a/hfsplus/inode.c
+++ b/hfsplus/inode.c
@@ -116,7 +116,7 @@ static ssize_t hfsplus_direct_IO(int rw,
 		const struct iovec *iov, loff_t offset, unsigned long nr_segs)
 {
 	struct file *file = iocb->ki_filp;
-	struct inode *inode = file->f_path.dentry->d_inode->i_mapping->host;
+	struct inode *inode = d_inode(file->f_path.dentry)->i_mapping->host;
 	ssize_t ret;
 
 	ret = blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev, iov,
@@ -287,7 +287,7 @@ static int hfsplus_file_release(struct i
 
 static int hfsplus_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	error = inode_change_ok(inode, attr);
diff -u -p a/hfsplus/dir.c b/hfsplus/dir.c
--- a/hfsplus/dir.c
+++ b/hfsplus/dir.c
@@ -73,8 +73,8 @@ again:
 					HFSPLUS_I(HFSPLUS_SB(sb)->hidden_dir)->
 						create_date ||
 				entry.file.create_date ==
-					HFSPLUS_I(sb->s_root->d_inode)->
-						create_date) &&
+					HFSPLUS_I(d_inode(sb->s_root))->
+					create_date) &&
 				HFSPLUS_SB(sb)->hidden_dir) {
 			struct qstr str;
 			char name[32];
@@ -120,7 +120,7 @@ fail:
 
 static int hfsplus_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct super_block *sb = inode->i_sb;
 	int len, err;
 	char strbuf[HFSPLUS_MAX_STRLEN + 1];
@@ -253,8 +253,8 @@ static int hfsplus_link(struct dentry *s
 			struct dentry *dst_dentry)
 {
 	struct hfsplus_sb_info *sbi = HFSPLUS_SB(dst_dir->i_sb);
-	struct inode *inode = src_dentry->d_inode;
-	struct inode *src_dir = src_dentry->d_parent->d_inode;
+	struct inode *inode = d_inode(src_dentry);
+	struct inode *src_dir = d_inode(src_dentry->d_parent);
 	struct qstr str;
 	char name[32];
 	u32 cnid, id;
@@ -310,7 +310,7 @@ out:
 static int hfsplus_unlink(struct inode *dir, struct dentry *dentry)
 {
 	struct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct qstr str;
 	char name[32];
 	u32 cnid;
@@ -367,7 +367,7 @@ out:
 static int hfsplus_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	struct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int res;
 
 	if (inode->i_size != 2)
@@ -466,8 +466,8 @@ static int hfsplus_rename(struct inode *
 	int res;
 
 	/* Unlink destination if it already exists */
-	if (new_dentry->d_inode) {
-		if (S_ISDIR(new_dentry->d_inode->i_mode))
+	if (d_inode(new_dentry)) {
+		if (S_ISDIR(d_inode(new_dentry)->i_mode))
 			res = hfsplus_rmdir(new_dir, new_dentry);
 		else
 			res = hfsplus_unlink(new_dir, new_dentry);
diff -u -p a/hfsplus/ioctl.c b/hfsplus/ioctl.c
--- a/hfsplus/ioctl.c
+++ b/hfsplus/ioctl.c
@@ -22,7 +22,7 @@
 
 static int hfsplus_ioctl_getflags(struct file *file, int __user *user_flags)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct hfsplus_inode_info *hip = HFSPLUS_I(inode);
 	unsigned int flags = 0;
 
@@ -38,7 +38,7 @@ static int hfsplus_ioctl_getflags(struct
 
 static int hfsplus_ioctl_setflags(struct file *file, int __user *user_flags)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct hfsplus_inode_info *hip = HFSPLUS_I(inode);
 	unsigned int flags;
 	int err = 0;
@@ -116,7 +116,7 @@ long hfsplus_ioctl(struct file *file, un
 int hfsplus_setxattr(struct dentry *dentry, const char *name,
 		     const void *value, size_t size, int flags)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct hfs_find_data fd;
 	hfsplus_cat_entry entry;
 	struct hfsplus_cat_file *file;
@@ -160,7 +160,7 @@ out:
 ssize_t hfsplus_getxattr(struct dentry *dentry, const char *name,
 			 void *value, size_t size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct hfs_find_data fd;
 	hfsplus_cat_entry entry;
 	struct hfsplus_cat_file *file;
@@ -205,7 +205,7 @@ out:
 
 ssize_t hfsplus_listxattr(struct dentry *dentry, char *buffer, size_t size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	if (!S_ISREG(inode->i_mode) || HFSPLUS_IS_RSRC(inode))
 		return -EOPNOTSUPP;
diff -u -p a/xfs/linux-2.6/xfs_file.c b/xfs/linux-2.6/xfs_file.c
--- a/xfs/linux-2.6/xfs_file.c
+++ b/xfs/linux-2.6/xfs_file.c
@@ -902,7 +902,7 @@ xfs_file_fallocate(
 	loff_t		offset,
 	loff_t		len)
 {
-	struct inode	*inode = file->f_path.dentry->d_inode;
+	struct inode	*inode = d_inode(file->f_path.dentry);
 	long		error;
 	loff_t		new_size = 0;
 	xfs_flock64_t	bf;
@@ -1003,7 +1003,7 @@ xfs_file_readdir(
 	void		*dirent,
 	filldir_t	filldir)
 {
-	struct inode	*inode = filp->f_path.dentry->d_inode;
+	struct inode	*inode = d_inode(filp->f_path.dentry);
 	xfs_inode_t	*ip = XFS_I(inode);
 	int		error;
 	size_t		bufsize;
diff -u -p a/xfs/linux-2.6/xfs_ioctl32.c b/xfs/linux-2.6/xfs_ioctl32.c
--- a/xfs/linux-2.6/xfs_ioctl32.c
+++ b/xfs/linux-2.6/xfs_ioctl32.c
@@ -380,7 +380,7 @@ xfs_compat_attrlist_by_handle(
 		goto out_dput;
 
 	cursor = (attrlist_cursor_kern_t *)&al_hreq.pos;
-	error = -xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,
+	error = -xfs_attr_list(XFS_I(d_inode(dentry)), kbuf, al_hreq.buflen,
 					al_hreq.flags, cursor);
 	if (error)
 		goto out_kfree;
@@ -448,28 +448,30 @@ xfs_compat_attrmulti_by_handle(
 
 		switch (ops[i].am_opcode) {
 		case ATTR_OP_GET:
-			ops[i].am_error = xfs_attrmulti_attr_get(
-					dentry->d_inode, attr_name,
-					compat_ptr(ops[i].am_attrvalue),
-					&ops[i].am_length, ops[i].am_flags);
+			ops[i].am_error = xfs_attrmulti_attr_get(d_inode(dentry),
+								 attr_name,
+								 compat_ptr(ops[i].am_attrvalue),
+								 &ops[i].am_length,
+								 ops[i].am_flags);
 			break;
 		case ATTR_OP_SET:
 			ops[i].am_error = mnt_want_write(parfilp->f_path.mnt);
 			if (ops[i].am_error)
 				break;
-			ops[i].am_error = xfs_attrmulti_attr_set(
-					dentry->d_inode, attr_name,
-					compat_ptr(ops[i].am_attrvalue),
-					ops[i].am_length, ops[i].am_flags);
+			ops[i].am_error = xfs_attrmulti_attr_set(d_inode(dentry),
+								 attr_name,
+								 compat_ptr(ops[i].am_attrvalue),
+								 ops[i].am_length,
+								 ops[i].am_flags);
 			mnt_drop_write(parfilp->f_path.mnt);
 			break;
 		case ATTR_OP_REMOVE:
 			ops[i].am_error = mnt_want_write(parfilp->f_path.mnt);
 			if (ops[i].am_error)
 				break;
-			ops[i].am_error = xfs_attrmulti_attr_remove(
-					dentry->d_inode, attr_name,
-					ops[i].am_flags);
+			ops[i].am_error = xfs_attrmulti_attr_remove(d_inode(dentry),
+								    attr_name,
+								    ops[i].am_flags);
 			mnt_drop_write(parfilp->f_path.mnt);
 			break;
 		default:
@@ -508,7 +510,7 @@ xfs_compat_fssetdm_by_handle(
 	if (IS_ERR(dentry))
 		return PTR_ERR(dentry);
 
-	if (IS_IMMUTABLE(dentry->d_inode) || IS_APPEND(dentry->d_inode)) {
+	if (IS_IMMUTABLE(d_inode(dentry)) || IS_APPEND(d_inode(dentry))) {
 		error = -XFS_ERROR(EPERM);
 		goto out;
 	}
@@ -518,7 +520,7 @@ xfs_compat_fssetdm_by_handle(
 		goto out;
 	}
 
-	error = -xfs_set_dmattrs(XFS_I(dentry->d_inode), fsd.fsd_dmevmask,
+	error = -xfs_set_dmattrs(XFS_I(d_inode(dentry)), fsd.fsd_dmevmask,
 				 fsd.fsd_dmstate);
 
 out:
@@ -532,7 +534,7 @@ xfs_file_compat_ioctl(
 	unsigned		cmd,
 	unsigned long		p)
 {
-	struct inode		*inode = filp->f_path.dentry->d_inode;
+	struct inode		*inode = d_inode(filp->f_path.dentry);
 	struct xfs_inode	*ip = XFS_I(inode);
 	struct xfs_mount	*mp = ip->i_mount;
 	void			__user *arg = (void __user *)p;
diff -u -p a/xfs/linux-2.6/xfs_iops.c b/xfs/linux-2.6/xfs_iops.c
--- a/xfs/linux-2.6/xfs_iops.c
+++ b/xfs/linux-2.6/xfs_iops.c
@@ -307,7 +307,7 @@ xfs_vn_link(
 	struct inode	*dir,
 	struct dentry	*dentry)
 {
-	struct inode	*inode = old_dentry->d_inode;
+	struct inode	*inode = d_inode(old_dentry);
 	struct xfs_name	name;
 	int		error;
 
@@ -332,7 +332,7 @@ xfs_vn_unlink(
 
 	xfs_dentry_to_name(&name, dentry);
 
-	error = -xfs_remove(XFS_I(dir), &name, XFS_I(dentry->d_inode));
+	error = -xfs_remove(XFS_I(dir), &name, XFS_I(d_inode(dentry)));
 	if (error)
 		return error;
 
@@ -388,14 +388,14 @@ xfs_vn_rename(
 	struct inode	*ndir,
 	struct dentry	*ndentry)
 {
-	struct inode	*new_inode = ndentry->d_inode;
+	struct inode	*new_inode = d_inode(ndentry);
 	struct xfs_name	oname;
 	struct xfs_name	nname;
 
 	xfs_dentry_to_name(&oname, odentry);
 	xfs_dentry_to_name(&nname, ndentry);
 
-	return -xfs_rename(XFS_I(odir), &oname, XFS_I(odentry->d_inode),
+	return -xfs_rename(XFS_I(odir), &oname, XFS_I(d_inode(odentry)),
 			   XFS_I(ndir), &nname, new_inode ?
 			   			XFS_I(new_inode) : NULL);
 }
@@ -417,7 +417,7 @@ xfs_vn_follow_link(
 	if (!link)
 		goto out_err;
 
-	error = -xfs_readlink(XFS_I(dentry->d_inode), link);
+	error = -xfs_readlink(XFS_I(d_inode(dentry)), link);
 	if (unlikely(error))
 		goto out_kfree;
 
@@ -449,7 +449,7 @@ xfs_vn_getattr(
 	struct dentry		*dentry,
 	struct kstat		*stat)
 {
-	struct inode		*inode = dentry->d_inode;
+	struct inode		*inode = d_inode(dentry);
 	struct xfs_inode	*ip = XFS_I(inode);
 	struct xfs_mount	*mp = ip->i_mount;
 
@@ -502,7 +502,7 @@ xfs_vn_setattr(
 	struct dentry	*dentry,
 	struct iattr	*iattr)
 {
-	return -xfs_setattr(XFS_I(dentry->d_inode), iattr, 0);
+	return -xfs_setattr(XFS_I(d_inode(dentry)), iattr, 0);
 }
 
 #define XFS_FIEMAP_FLAGS	(FIEMAP_FLAG_SYNC|FIEMAP_FLAG_XATTR)
diff -u -p a/xfs/linux-2.6/xfs_xattr.c b/xfs/linux-2.6/xfs_xattr.c
--- a/xfs/linux-2.6/xfs_xattr.c
+++ b/xfs/linux-2.6/xfs_xattr.c
@@ -33,7 +33,7 @@ static int
 xfs_xattr_get(struct dentry *dentry, const char *name,
 		void *value, size_t size, int xflags)
 {
-	struct xfs_inode *ip = XFS_I(dentry->d_inode);
+	struct xfs_inode *ip = XFS_I(d_inode(dentry));
 	int error, asize = size;
 
 	if (strcmp(name, "") == 0)
@@ -55,7 +55,7 @@ static int
 xfs_xattr_set(struct dentry *dentry, const char *name, const void *value,
 		size_t size, int flags, int xflags)
 {
-	struct xfs_inode *ip = XFS_I(dentry->d_inode);
+	struct xfs_inode *ip = XFS_I(d_inode(dentry));
 
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
@@ -195,7 +195,7 @@ xfs_vn_listxattr(struct dentry *dentry,
 {
 	struct xfs_attr_list_context context;
 	struct attrlist_cursor_kern cursor = { 0 };
-	struct inode		*inode = dentry->d_inode;
+	struct inode		*inode = d_inode(dentry);
 	int			error;
 
 	/*
diff -u -p a/xfs/linux-2.6/xfs_super.c b/xfs/linux-2.6/xfs_super.c
--- a/xfs/linux-2.6/xfs_super.c
+++ b/xfs/linux-2.6/xfs_super.c
@@ -1093,7 +1093,7 @@ xfs_fs_statfs(
 {
 	struct xfs_mount	*mp = XFS_M(dentry->d_sb);
 	xfs_sb_t		*sbp = &mp->m_sb;
-	struct xfs_inode	*ip = XFS_I(dentry->d_inode);
+	struct xfs_inode	*ip = XFS_I(d_inode(dentry));
 	__uint64_t		fakeinos, id;
 	xfs_extlen_t		lsize;
 	__int64_t		ffree;
diff -u -p a/xfs/linux-2.6/xfs_ioctl.c b/xfs/linux-2.6/xfs_ioctl.c
--- a/xfs/linux-2.6/xfs_ioctl.c
+++ b/xfs/linux-2.6/xfs_ioctl.c
@@ -81,12 +81,12 @@ xfs_find_handle(
 		file = fget(hreq->fd);
 		if (!file)
 			return -EBADF;
-		inode = file->f_path.dentry->d_inode;
+		inode = d_inode(file->f_path.dentry);
 	} else {
 		error = user_lpath((const char __user *)hreq->path, &path);
 		if (error)
 			return error;
-		inode = path.dentry->d_inode;
+		inode = d_inode(path.dentry);
 	}
 	ip = XFS_I(inode);
 
@@ -169,7 +169,7 @@ xfs_handle_to_dentry(
 	/*
 	 * Only allow handle opens under a directory.
 	 */
-	if (!S_ISDIR(parfilp->f_path.dentry->d_inode->i_mode))
+	if (!S_ISDIR(d_inode(parfilp->f_path.dentry)->i_mode))
 		return ERR_PTR(-ENOTDIR);
 
 	if (hlen != sizeof(xfs_handle_t))
@@ -216,7 +216,7 @@ xfs_open_by_handle(
 	dentry = xfs_handlereq_to_dentry(parfilp, hreq);
 	if (IS_ERR(dentry))
 		return PTR_ERR(dentry);
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	/* Restrict xfs_open_by_handle to directories & regular files. */
 	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))) {
@@ -322,7 +322,7 @@ xfs_readlink_by_handle(
 		return PTR_ERR(dentry);
 
 	/* Restrict this handle operation to symlinks only. */
-	if (!S_ISLNK(dentry->d_inode->i_mode)) {
+	if (!S_ISLNK(d_inode(dentry)->i_mode)) {
 		error = -XFS_ERROR(EINVAL);
 		goto out_dput;
 	}
@@ -338,7 +338,7 @@ xfs_readlink_by_handle(
 		goto out_dput;
 	}
 
-	error = -xfs_readlink(XFS_I(dentry->d_inode), link);
+	error = -xfs_readlink(XFS_I(d_inode(dentry)), link);
 	if (error)
 		goto out_kfree;
 	error = do_readlink(hreq->ohandle, olen, link);
@@ -371,7 +371,7 @@ xfs_fssetdm_by_handle(
 	if (IS_ERR(dentry))
 		return PTR_ERR(dentry);
 
-	if (IS_IMMUTABLE(dentry->d_inode) || IS_APPEND(dentry->d_inode)) {
+	if (IS_IMMUTABLE(d_inode(dentry)) || IS_APPEND(d_inode(dentry))) {
 		error = -XFS_ERROR(EPERM);
 		goto out;
 	}
@@ -381,7 +381,7 @@ xfs_fssetdm_by_handle(
 		goto out;
 	}
 
-	error = -xfs_set_dmattrs(XFS_I(dentry->d_inode), fsd.fsd_dmevmask,
+	error = -xfs_set_dmattrs(XFS_I(d_inode(dentry)), fsd.fsd_dmevmask,
 				 fsd.fsd_dmstate);
 
  out:
@@ -422,7 +422,7 @@ xfs_attrlist_by_handle(
 		goto out_dput;
 
 	cursor = (attrlist_cursor_kern_t *)&al_hreq.pos;
-	error = -xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,
+	error = -xfs_attr_list(XFS_I(d_inode(dentry)), kbuf, al_hreq.buflen,
 					al_hreq.flags, cursor);
 	if (error)
 		goto out_kfree;
@@ -553,28 +553,30 @@ xfs_attrmulti_by_handle(
 
 		switch (ops[i].am_opcode) {
 		case ATTR_OP_GET:
-			ops[i].am_error = xfs_attrmulti_attr_get(
-					dentry->d_inode, attr_name,
-					ops[i].am_attrvalue, &ops[i].am_length,
-					ops[i].am_flags);
+			ops[i].am_error = xfs_attrmulti_attr_get(d_inode(dentry),
+								 attr_name,
+								 ops[i].am_attrvalue,
+								 &ops[i].am_length,
+								 ops[i].am_flags);
 			break;
 		case ATTR_OP_SET:
 			ops[i].am_error = mnt_want_write(parfilp->f_path.mnt);
 			if (ops[i].am_error)
 				break;
-			ops[i].am_error = xfs_attrmulti_attr_set(
-					dentry->d_inode, attr_name,
-					ops[i].am_attrvalue, ops[i].am_length,
-					ops[i].am_flags);
+			ops[i].am_error = xfs_attrmulti_attr_set(d_inode(dentry),
+								 attr_name,
+								 ops[i].am_attrvalue,
+								 ops[i].am_length,
+								 ops[i].am_flags);
 			mnt_drop_write(parfilp->f_path.mnt);
 			break;
 		case ATTR_OP_REMOVE:
 			ops[i].am_error = mnt_want_write(parfilp->f_path.mnt);
 			if (ops[i].am_error)
 				break;
-			ops[i].am_error = xfs_attrmulti_attr_remove(
-					dentry->d_inode, attr_name,
-					ops[i].am_flags);
+			ops[i].am_error = xfs_attrmulti_attr_remove(d_inode(dentry),
+								    attr_name,
+								    ops[i].am_flags);
 			mnt_drop_write(parfilp->f_path.mnt);
 			break;
 		default:
@@ -1307,7 +1309,7 @@ xfs_file_ioctl(
 	unsigned int		cmd,
 	unsigned long		p)
 {
-	struct inode		*inode = filp->f_path.dentry->d_inode;
+	struct inode		*inode = d_inode(filp->f_path.dentry);
 	struct xfs_inode	*ip = XFS_I(inode);
 	struct xfs_mount	*mp = ip->i_mount;
 	void			__user *arg = (void __user *)p;
diff -u -p a/xfs/linux-2.6/xfs_export.c b/xfs/linux-2.6/xfs_export.c
--- a/xfs/linux-2.6/xfs_export.c
+++ b/xfs/linux-2.6/xfs_export.c
@@ -60,7 +60,7 @@ xfs_fs_encode_fh(
 {
 	struct fid		*fid = (struct fid *)fh;
 	struct xfs_fid64	*fid64 = (struct xfs_fid64 *)fh;
-	struct inode		*inode = dentry->d_inode;
+	struct inode		*inode = d_inode(dentry);
 	int			fileid_type;
 	int			len;
 
@@ -98,8 +98,8 @@ xfs_fs_encode_fh(
 	switch (fileid_type) {
 	case FILEID_INO32_GEN_PARENT:
 		spin_lock(&dentry->d_lock);
-		fid->i32.parent_ino = dentry->d_parent->d_inode->i_ino;
-		fid->i32.parent_gen = dentry->d_parent->d_inode->i_generation;
+		fid->i32.parent_ino = d_inode(dentry->d_parent)->i_ino;
+		fid->i32.parent_gen = d_inode(dentry->d_parent)->i_generation;
 		spin_unlock(&dentry->d_lock);
 		/*FALLTHRU*/
 	case FILEID_INO32_GEN:
@@ -108,8 +108,8 @@ xfs_fs_encode_fh(
 		break;
 	case FILEID_INO32_GEN_PARENT | XFS_FILEID_TYPE_64FLAG:
 		spin_lock(&dentry->d_lock);
-		fid64->parent_ino = dentry->d_parent->d_inode->i_ino;
-		fid64->parent_gen = dentry->d_parent->d_inode->i_generation;
+		fid64->parent_ino = d_inode(dentry->d_parent)->i_ino;
+		fid64->parent_gen = d_inode(dentry->d_parent)->i_generation;
 		spin_unlock(&dentry->d_lock);
 		/*FALLTHRU*/
 	case FILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG:
@@ -216,7 +216,8 @@ xfs_fs_get_parent(
 	int			error;
 	struct xfs_inode	*cip;
 
-	error = xfs_lookup(XFS_I(child->d_inode), &xfs_name_dotdot, &cip, NULL);
+	error = xfs_lookup(XFS_I(d_inode(child)), &xfs_name_dotdot, &cip,
+			   NULL);
 	if (unlikely(error))
 		return ERR_PTR(-error);
 
diff -u -p a/xfs/linux-2.6/xfs_acl.c b/xfs/linux-2.6/xfs_acl.c
--- a/xfs/linux-2.6/xfs_acl.c
+++ b/xfs/linux-2.6/xfs_acl.c
@@ -371,7 +371,7 @@ xfs_xattr_acl_get(struct dentry *dentry,
 	struct posix_acl *acl;
 	int error;
 
-	acl = xfs_get_acl(dentry->d_inode, type);
+	acl = xfs_get_acl(d_inode(dentry), type);
 	if (IS_ERR(acl))
 		return PTR_ERR(acl);
 	if (acl == NULL)
@@ -387,7 +387,7 @@ static int
 xfs_xattr_acl_set(struct dentry *dentry, const char *name,
 		const void *value, size_t size, int flags, int type)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct posix_acl *acl = NULL;
 	int error = 0;
 
diff -u -p a/xfs/xfs_dfrag.c b/xfs/xfs_dfrag.c
--- a/xfs/xfs_dfrag.c
+++ b/xfs/xfs_dfrag.c
@@ -80,14 +80,14 @@ xfs_swapext(
 		goto out_put_tmp_file;
 	}
 
-	if (IS_SWAPFILE(file->f_path.dentry->d_inode) ||
-	    IS_SWAPFILE(tmp_file->f_path.dentry->d_inode)) {
+	if (IS_SWAPFILE(d_inode(file->f_path.dentry)) ||
+	    IS_SWAPFILE(d_inode(tmp_file->f_path.dentry))) {
 		error = XFS_ERROR(EINVAL);
 		goto out_put_tmp_file;
 	}
 
-	ip = XFS_I(file->f_path.dentry->d_inode);
-	tip = XFS_I(tmp_file->f_path.dentry->d_inode);
+	ip = XFS_I(d_inode(file->f_path.dentry));
+	tip = XFS_I(d_inode(tmp_file->f_path.dentry));
 
 	if (ip->i_mount != tip->i_mount) {
 		error = XFS_ERROR(EINVAL);
diff -u -p a/generic_acl.c b/generic_acl.c
--- a/generic_acl.c
+++ b/generic_acl.c
@@ -22,7 +22,7 @@ generic_acl_list(struct dentry *dentry,
 	const char *xname;
 	size_t size;
 
-	acl = get_cached_acl(dentry->d_inode, type);
+	acl = get_cached_acl(d_inode(dentry), type);
 	if (!acl)
 		return 0;
 	posix_acl_release(acl);
@@ -53,7 +53,7 @@ generic_acl_get(struct dentry *dentry, c
 	if (strcmp(name, "") != 0)
 		return -EINVAL;
 
-	acl = get_cached_acl(dentry->d_inode, type);
+	acl = get_cached_acl(d_inode(dentry), type);
 	if (!acl)
 		return -ENODATA;
 	error = posix_acl_to_xattr(acl, buffer, size);
@@ -66,7 +66,7 @@ static int
 generic_acl_set(struct dentry *dentry, const char *name, const void *value,
 		     size_t size, int flags, int type)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct posix_acl *acl = NULL;
 	int error;
 
diff -u -p a/cramfs/inode.c b/cramfs/inode.c
--- a/cramfs/inode.c
+++ b/cramfs/inode.c
@@ -354,7 +354,7 @@ static int cramfs_statfs(struct dentry *
  */
 static int cramfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct super_block *sb = inode->i_sb;
 	char *buf;
 	unsigned int offset;
diff -u -p a/read_write.c b/read_write.c
--- a/read_write.c
+++ b/read_write.c
@@ -95,9 +95,9 @@ loff_t generic_file_llseek(struct file *
 {
 	loff_t rval;
 
-	mutex_lock(&file->f_dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(file->f_dentry)->i_mutex);
 	rval = generic_file_llseek_unlocked(file, offset, origin);
-	mutex_unlock(&file->f_dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(file->f_dentry)->i_mutex);
 
 	return rval;
 }
@@ -130,10 +130,10 @@ loff_t default_llseek(struct file *file,
 {
 	loff_t retval;
 
-	mutex_lock(&file->f_dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(file->f_dentry)->i_mutex);
 	switch (origin) {
 		case SEEK_END:
-			offset += i_size_read(file->f_path.dentry->d_inode);
+			offset += i_size_read(d_inode(file->f_path.dentry));
 			break;
 		case SEEK_CUR:
 			if (offset == 0) {
@@ -151,7 +151,7 @@ loff_t default_llseek(struct file *file,
 		retval = offset;
 	}
 out:
-	mutex_unlock(&file->f_dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(file->f_dentry)->i_mutex);
 	return retval;
 }
 EXPORT_SYMBOL(default_llseek);
@@ -239,7 +239,7 @@ int rw_verify_area(int read_write, struc
 	loff_t pos;
 	int retval = -EINVAL;
 
-	inode = file->f_path.dentry->d_inode;
+	inode = d_inode(file->f_path.dentry);
 	if (unlikely((ssize_t) count < 0))
 		return retval;
 	pos = *ppos;
@@ -862,8 +862,8 @@ static ssize_t do_sendfile(int out_fd, i
 	if (!(out_file->f_mode & FMODE_WRITE))
 		goto fput_out;
 	retval = -EINVAL;
-	in_inode = in_file->f_path.dentry->d_inode;
-	out_inode = out_file->f_path.dentry->d_inode;
+	in_inode = d_inode(in_file->f_path.dentry);
+	out_inode = d_inode(out_file->f_path.dentry);
 	retval = rw_verify_area(WRITE, out_file, &out_file->f_pos, count);
 	if (retval < 0)
 		goto fput_out;
diff -u -p a/binfmt_elf.c b/binfmt_elf.c
--- a/binfmt_elf.c
+++ b/binfmt_elf.c
@@ -1112,7 +1112,7 @@ static unsigned long vma_dump_size(struc
 
 	/* By default, dump shared memory if mapped from an anonymous file. */
 	if (vma->vm_flags & VM_SHARED) {
-		if (vma->vm_file->f_path.dentry->d_inode->i_nlink == 0 ?
+		if (d_inode(vma->vm_file->f_path.dentry)->i_nlink == 0 ?
 		    FILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))
 			goto whole;
 		return 0;
diff -u -p a/squashfs/dir.c b/squashfs/dir.c
--- a/squashfs/dir.c
+++ b/squashfs/dir.c
@@ -102,7 +102,7 @@ static int get_dir_index_using_offset(st
 
 static int squashfs_readdir(struct file *file, void *dirent, filldir_t filldir)
 {
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
 	u64 block = squashfs_i(inode)->start + msblk->directory_table;
 	int offset = squashfs_i(inode)->offset, length = 0, dir_count, size,
diff -u -p a/squashfs/export.c b/squashfs/export.c
--- a/squashfs/export.c
+++ b/squashfs/export.c
@@ -110,7 +110,7 @@ static struct dentry *squashfs_fh_to_par
 
 static struct dentry *squashfs_get_parent(struct dentry *child)
 {
-	struct inode *inode = child->d_inode;
+	struct inode *inode = d_inode(child);
 	unsigned int parent_ino = squashfs_i(inode)->parent;
 
 	return squashfs_export_iget(inode->i_sb, parent_ino);
diff -u -p a/squashfs/xattr.c b/squashfs/xattr.c
--- a/squashfs/xattr.c
+++ b/squashfs/xattr.c
@@ -39,7 +39,7 @@ static const struct xattr_handler *squas
 ssize_t squashfs_listxattr(struct dentry *d, char *buffer,
 	size_t buffer_size)
 {
-	struct inode *inode = d->d_inode;
+	struct inode *inode = d_inode(d);
 	struct super_block *sb = inode->i_sb;
 	struct squashfs_sb_info *msblk = sb->s_fs_info;
 	u64 start = SQUASHFS_XATTR_BLK(squashfs_i(inode)->xattr)
@@ -229,8 +229,8 @@ static int squashfs_user_get(struct dent
 	if (name[0] == '\0')
 		return  -EINVAL;
 
-	return squashfs_xattr_get(d->d_inode, SQUASHFS_XATTR_USER, name,
-		buffer, size);
+	return squashfs_xattr_get(d_inode(d), SQUASHFS_XATTR_USER, name,
+				  buffer, size);
 }
 
 static const struct xattr_handler squashfs_xattr_user_handler = {
@@ -259,8 +259,8 @@ static int squashfs_trusted_get(struct d
 	if (name[0] == '\0')
 		return  -EINVAL;
 
-	return squashfs_xattr_get(d->d_inode, SQUASHFS_XATTR_TRUSTED, name,
-		buffer, size);
+	return squashfs_xattr_get(d_inode(d), SQUASHFS_XATTR_TRUSTED, name,
+				  buffer, size);
 }
 
 static const struct xattr_handler squashfs_xattr_trusted_handler = {
@@ -286,8 +286,8 @@ static int squashfs_security_get(struct
 	if (name[0] == '\0')
 		return  -EINVAL;
 
-	return squashfs_xattr_get(d->d_inode, SQUASHFS_XATTR_SECURITY, name,
-		buffer, size);
+	return squashfs_xattr_get(d_inode(d), SQUASHFS_XATTR_SECURITY, name,
+				  buffer, size);
 }
 
 static const struct xattr_handler squashfs_xattr_security_handler = {
diff -u -p a/namei.c b/namei.c
--- a/namei.c
+++ b/namei.c
@@ -317,7 +317,7 @@ int inode_permission(struct inode *inode
  */
 int file_permission(struct file *file, int mask)
 {
-	return inode_permission(file->f_path.dentry->d_inode, mask);
+	return inode_permission(d_inode(file->f_path.dentry), mask);
 }
 
 /*
@@ -353,7 +353,7 @@ int get_write_access(struct inode * inod
 
 int deny_write_access(struct file * file)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 
 	spin_lock(&inode->i_lock);
 	if (atomic_read(&inode->i_writecount) > 0) {
@@ -431,7 +431,7 @@ static int unlazy_walk(struct nameidata
 	if (!dentry) {
 		if (!__d_rcu_to_refcount(parent, nd->seq))
 			goto err_parent;
-		BUG_ON(nd->inode != parent->d_inode);
+		BUG_ON(nd->inode != d_inode(parent));
 	} else {
 		if (dentry->d_parent != parent)
 			goto err_parent;
@@ -540,7 +540,7 @@ static int complete_walk(struct nameidat
 			br_read_unlock(vfsmount_lock);
 			return -ECHILD;
 		}
-		BUG_ON(nd->inode != dentry->d_inode);
+		BUG_ON(nd->inode != d_inode(dentry));
 		spin_unlock(&dentry->d_lock);
 		mntget(nd->path.mnt);
 		rcu_read_unlock();
@@ -638,7 +638,7 @@ static __always_inline int __vfs_follow_
 		path_get(&nd->root);
 		nd->flags |= LOOKUP_JUMPED;
 	}
-	nd->inode = nd->path.dentry->d_inode;
+	nd->inode = d_inode(nd->path.dentry);
 
 	ret = link_path_walk(link, nd);
 	return ret;
@@ -668,7 +668,7 @@ static inline void path_to_nameidata(con
 
 static inline void put_link(struct nameidata *nd, struct path *link, void *cookie)
 {
-	struct inode *inode = link->dentry->d_inode;
+	struct inode *inode = d_inode(link->dentry);
 	if (!IS_ERR(cookie) && inode->i_op->put_link)
 		inode->i_op->put_link(link->dentry, nd, cookie);
 	path_put(link);
@@ -704,7 +704,7 @@ follow_link(struct path *link, struct na
 	}
 
 	nd->last_type = LAST_BIND;
-	*p = dentry->d_inode->i_op->follow_link(dentry, nd);
+	*p = d_inode(dentry)->i_op->follow_link(dentry, nd);
 	error = PTR_ERR(*p);
 	if (!IS_ERR(*p)) {
 		char *s = nd_get_link(nd);
@@ -713,7 +713,7 @@ follow_link(struct path *link, struct na
 			error = __vfs_follow_link(nd, s);
 		else if (nd->last_type == LAST_BIND) {
 			nd->flags |= LOOKUP_JUMPED;
-			nd->inode = nd->path.dentry->d_inode;
+			nd->inode = d_inode(nd->path.dentry);
 			if (nd->inode->i_op->follow_link) {
 				/* stepped on a _really_ weird one */
 				path_put(&nd->path);
@@ -959,7 +959,7 @@ static bool __follow_mount_rcu(struct na
 		 * dentry sequence number here after this d_inode read,
 		 * because a mount-point is always pinned.
 		 */
-		*inode = path->dentry->d_inode;
+		*inode = d_inode(path->dentry);
 	}
 	return true;
 }
@@ -1003,7 +1003,7 @@ static int follow_dotdot_rcu(struct name
 		nd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);
 	}
 	follow_mount_rcu(nd);
-	nd->inode = nd->path.dentry->d_inode;
+	nd->inode = d_inode(nd->path.dentry);
 	return 0;
 
 failed:
@@ -1101,7 +1101,7 @@ static void follow_dotdot(struct nameida
 			break;
 	}
 	follow_mount(&nd->path);
-	nd->inode = nd->path.dentry->d_inode;
+	nd->inode = d_inode(nd->path.dentry);
 }
 
 /*
@@ -1113,7 +1113,7 @@ static void follow_dotdot(struct nameida
 static struct dentry *d_alloc_and_lookup(struct dentry *parent,
 				struct qstr *name, struct nameidata *nd)
 {
-	struct inode *inode = parent->d_inode;
+	struct inode *inode = d_inode(parent);
 	struct dentry *dentry;
 	struct dentry *old;
 
@@ -1188,7 +1188,7 @@ unlazy:
 
 retry:
 	if (unlikely(!dentry)) {
-		struct inode *dir = parent->d_inode;
+		struct inode *dir = d_inode(parent);
 		BUG_ON(nd->inode != dir);
 
 		mutex_lock(&dir->i_mutex);
@@ -1227,7 +1227,7 @@ retry:
 		path_put_conditional(path, nd);
 		return err;
 	}
-	*inode = path->dentry->d_inode;
+	*inode = d_inode(path->dentry);
 	return 0;
 }
 
@@ -1297,7 +1297,7 @@ static inline int walk_component(struct
 				return -ECHILD;
 			}
 		}
-		BUG_ON(inode != path->dentry->d_inode);
+		BUG_ON(inode != d_inode(path->dentry));
 		return 1;
 	}
 	path_to_nameidata(path, nd);
@@ -1452,7 +1452,7 @@ static int path_init(int dfd, const char
 	nd->flags = flags | LOOKUP_JUMPED;
 	nd->depth = 0;
 	if (flags & LOOKUP_ROOT) {
-		struct inode *inode = nd->root.dentry->d_inode;
+		struct inode *inode = d_inode(nd->root.dentry);
 		if (*name) {
 			if (!inode->i_op->lookup)
 				return -ENOTDIR;
@@ -1512,7 +1512,7 @@ static int path_init(int dfd, const char
 
 		if (*name) {
 			retval = -ENOTDIR;
-			if (!S_ISDIR(dentry->d_inode->i_mode))
+			if (!S_ISDIR(d_inode(dentry)->i_mode))
 				goto fput_fail;
 
 			retval = file_permission(file, MAY_EXEC);
@@ -1533,7 +1533,7 @@ static int path_init(int dfd, const char
 		}
 	}
 
-	nd->inode = nd->path.dentry->d_inode;
+	nd->inode = d_inode(nd->path.dentry);
 	return 0;
 
 fput_fail:
@@ -1668,7 +1668,7 @@ int vfs_path_lookup(struct dentry *dentr
 static struct dentry *__lookup_hash(struct qstr *name,
 		struct dentry *base, struct nameidata *nd)
 {
-	struct inode *inode = base->d_inode;
+	struct inode *inode = d_inode(base);
 	struct dentry *dentry;
 	int err;
 
@@ -1719,7 +1719,7 @@ struct dentry *lookup_one_len(const char
 	unsigned long hash;
 	unsigned int c;
 
-	WARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));
+	WARN_ON_ONCE(!mutex_is_locked(&d_inode(base)->i_mutex));
 
 	this.name = name;
 	this.len = len;
@@ -1739,7 +1739,7 @@ struct dentry *lookup_one_len(const char
 	 * to use its own hash..
 	 */
 	if (base->d_flags & DCACHE_OP_HASH) {
-		int err = base->d_op->d_hash(base, base->d_inode, &this);
+		int err = base->d_op->d_hash(base, d_inode(base), &this);
 		if (err < 0)
 			return ERR_PTR(err);
 	}
@@ -1827,10 +1827,10 @@ static int may_delete(struct inode *dir,
 {
 	int error;
 
-	if (!victim->d_inode)
+	if (!d_inode(victim))
 		return -ENOENT;
 
-	BUG_ON(victim->d_parent->d_inode != dir);
+	BUG_ON(d_inode(victim->d_parent) != dir);
 	audit_inode_child(victim, dir);
 
 	error = inode_permission(dir, MAY_WRITE | MAY_EXEC);
@@ -1838,15 +1838,15 @@ static int may_delete(struct inode *dir,
 		return error;
 	if (IS_APPEND(dir))
 		return -EPERM;
-	if (check_sticky(dir, victim->d_inode)||IS_APPEND(victim->d_inode)||
-	    IS_IMMUTABLE(victim->d_inode) || IS_SWAPFILE(victim->d_inode))
+	if (check_sticky(dir, d_inode(victim))||IS_APPEND(d_inode(victim))||
+	    IS_IMMUTABLE(d_inode(victim)) || IS_SWAPFILE(d_inode(victim)))
 		return -EPERM;
 	if (isdir) {
-		if (!S_ISDIR(victim->d_inode->i_mode))
+		if (!S_ISDIR(d_inode(victim)->i_mode))
 			return -ENOTDIR;
 		if (IS_ROOT(victim))
 			return -EBUSY;
-	} else if (S_ISDIR(victim->d_inode->i_mode))
+	} else if (S_ISDIR(d_inode(victim)->i_mode))
 		return -EISDIR;
 	if (IS_DEADDIR(dir))
 		return -ENOENT;
@@ -1865,7 +1865,7 @@ static int may_delete(struct inode *dir,
  */
 static inline int may_create(struct inode *dir, struct dentry *child)
 {
-	if (child->d_inode)
+	if (d_inode(child))
 		return -EEXIST;
 	if (IS_DEADDIR(dir))
 		return -ENOENT;
@@ -1880,37 +1880,37 @@ struct dentry *lock_rename(struct dentry
 	struct dentry *p;
 
 	if (p1 == p2) {
-		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
+		mutex_lock_nested(&d_inode(p1)->i_mutex, I_MUTEX_PARENT);
 		return NULL;
 	}
 
-	mutex_lock(&p1->d_inode->i_sb->s_vfs_rename_mutex);
+	mutex_lock(&d_inode(p1)->i_sb->s_vfs_rename_mutex);
 
 	p = d_ancestor(p2, p1);
 	if (p) {
-		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);
-		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);
+		mutex_lock_nested(&d_inode(p2)->i_mutex, I_MUTEX_PARENT);
+		mutex_lock_nested(&d_inode(p1)->i_mutex, I_MUTEX_CHILD);
 		return p;
 	}
 
 	p = d_ancestor(p1, p2);
 	if (p) {
-		mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
-		mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
+		mutex_lock_nested(&d_inode(p1)->i_mutex, I_MUTEX_PARENT);
+		mutex_lock_nested(&d_inode(p2)->i_mutex, I_MUTEX_CHILD);
 		return p;
 	}
 
-	mutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);
-	mutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);
+	mutex_lock_nested(&d_inode(p1)->i_mutex, I_MUTEX_PARENT);
+	mutex_lock_nested(&d_inode(p2)->i_mutex, I_MUTEX_CHILD);
 	return NULL;
 }
 
 void unlock_rename(struct dentry *p1, struct dentry *p2)
 {
-	mutex_unlock(&p1->d_inode->i_mutex);
+	mutex_unlock(&d_inode(p1)->i_mutex);
 	if (p1 != p2) {
-		mutex_unlock(&p2->d_inode->i_mutex);
-		mutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);
+		mutex_unlock(&d_inode(p2)->i_mutex);
+		mutex_unlock(&d_inode(p1)->i_sb->s_vfs_rename_mutex);
 	}
 }
 
@@ -1938,7 +1938,7 @@ int vfs_create(struct inode *dir, struct
 static int may_open(struct path *path, int acc_mode, int flag)
 {
 	struct dentry *dentry = path->dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	/* O_PATH? */
@@ -1993,7 +1993,7 @@ static int may_open(struct path *path, i
 static int handle_truncate(struct file *filp)
 {
 	struct path *path = &filp->f_path;
-	struct inode *inode = path->dentry->d_inode;
+	struct inode *inode = d_inode(path->dentry);
 	int error = get_write_access(inode);
 	if (error)
 		return error;
@@ -2117,12 +2117,12 @@ static struct file *do_last(struct namei
 	if (nd->last.name[nd->last.len])
 		goto exit;
 
-	mutex_lock(&dir->d_inode->i_mutex);
+	mutex_lock(&d_inode(dir)->i_mutex);
 
 	dentry = lookup_hash(nd);
 	error = PTR_ERR(dentry);
 	if (IS_ERR(dentry)) {
-		mutex_unlock(&dir->d_inode->i_mutex);
+		mutex_unlock(&d_inode(dir)->i_mutex);
 		goto exit;
 	}
 
@@ -2130,9 +2130,9 @@ static struct file *do_last(struct namei
 	path->mnt = nd->path.mnt;
 
 	/* Negative dentry, just create the file */
-	if (!dentry->d_inode) {
+	if (!d_inode(dentry)) {
 		int mode = op->mode;
-		if (!IS_POSIXACL(dir->d_inode))
+		if (!IS_POSIXACL(d_inode(dir)))
 			mode &= ~current_umask();
 		/*
 		 * This write is needed to ensure that a
@@ -2152,10 +2152,10 @@ static struct file *do_last(struct namei
 		error = security_path_mknod(&nd->path, dentry, mode, 0);
 		if (error)
 			goto exit_mutex_unlock;
-		error = vfs_create(dir->d_inode, dentry, mode, nd);
+		error = vfs_create(d_inode(dir), dentry, mode, nd);
 		if (error)
 			goto exit_mutex_unlock;
-		mutex_unlock(&dir->d_inode->i_mutex);
+		mutex_unlock(&d_inode(dir)->i_mutex);
 		dput(nd->path.dentry);
 		nd->path.dentry = dentry;
 		goto common;
@@ -2164,7 +2164,7 @@ static struct file *do_last(struct namei
 	/*
 	 * It already exists.
 	 */
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 	audit_inode(pathname, path->dentry);
 
 	error = -EEXIST;
@@ -2176,14 +2176,14 @@ static struct file *do_last(struct namei
 		goto exit_dput;
 
 	error = -ENOENT;
-	if (!path->dentry->d_inode)
+	if (!d_inode(path->dentry))
 		goto exit_dput;
 
-	if (path->dentry->d_inode->i_op->follow_link)
+	if (d_inode(path->dentry)->i_op->follow_link)
 		return NULL;
 
 	path_to_nameidata(path, nd);
-	nd->inode = path->dentry->d_inode;
+	nd->inode = d_inode(path->dentry);
 	error = -EISDIR;
 	if (S_ISDIR(nd->inode->i_mode))
 		goto exit;
@@ -2225,7 +2225,7 @@ out:
 	return filp;
 
 exit_mutex_unlock:
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 exit_dput:
 	path_put_conditional(path, nd);
 exit:
@@ -2316,7 +2316,7 @@ struct file *do_file_open_root(struct de
 
 	flags |= LOOKUP_ROOT;
 
-	if (dentry->d_inode->i_op->follow_link && op->intent & LOOKUP_OPEN)
+	if (d_inode(dentry)->i_op->follow_link && op->intent & LOOKUP_OPEN)
 		return ERR_PTR(-ELOOP);
 
 	file = path_openat(-1, name, &nd, op, flags | LOOKUP_RCU);
@@ -2341,7 +2341,7 @@ struct dentry *lookup_create(struct name
 {
 	struct dentry *dentry = ERR_PTR(-EEXIST);
 
-	mutex_lock_nested(&nd->path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
+	mutex_lock_nested(&d_inode(nd->path.dentry)->i_mutex, I_MUTEX_PARENT);
 	/*
 	 * Yucky last component or no last component at all?
 	 * (foo/., foo/.., /////)
@@ -2359,7 +2359,7 @@ struct dentry *lookup_create(struct name
 	if (IS_ERR(dentry))
 		goto fail;
 
-	if (dentry->d_inode)
+	if (d_inode(dentry))
 		goto eexist;
 	/*
 	 * Special case - lookup gave negative, but... we had foo/bar/
@@ -2445,7 +2445,7 @@ SYSCALL_DEFINE4(mknodat, int, dfd, const
 		error = PTR_ERR(dentry);
 		goto out_unlock;
 	}
-	if (!IS_POSIXACL(nd.path.dentry->d_inode))
+	if (!IS_POSIXACL(d_inode(nd.path.dentry)))
 		mode &= ~current_umask();
 	error = may_mknod(mode);
 	if (error)
@@ -2458,14 +2458,16 @@ SYSCALL_DEFINE4(mknodat, int, dfd, const
 		goto out_drop_write;
 	switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
-			error = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);
+			error = vfs_create(d_inode(nd.path.dentry),dentry,
+					   mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,
-					new_decode_dev(dev));
+			error = vfs_mknod(d_inode(nd.path.dentry),dentry,mode,
+					  new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,0);
+			error = vfs_mknod(d_inode(nd.path.dentry),dentry,mode,
+					  0);
 			break;
 	}
 out_drop_write:
@@ -2473,7 +2475,7 @@ out_drop_write:
 out_dput:
 	dput(dentry);
 out_unlock:
-	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(nd.path.dentry)->i_mutex);
 	path_put(&nd.path);
 	putname(tmp);
 
@@ -2522,7 +2524,7 @@ SYSCALL_DEFINE3(mkdirat, int, dfd, const
 	if (IS_ERR(dentry))
 		goto out_unlock;
 
-	if (!IS_POSIXACL(nd.path.dentry->d_inode))
+	if (!IS_POSIXACL(d_inode(nd.path.dentry)))
 		mode &= ~current_umask();
 	error = mnt_want_write(nd.path.mnt);
 	if (error)
@@ -2530,13 +2532,13 @@ SYSCALL_DEFINE3(mkdirat, int, dfd, const
 	error = security_path_mkdir(&nd.path, dentry, mode);
 	if (error)
 		goto out_drop_write;
-	error = vfs_mkdir(nd.path.dentry->d_inode, dentry, mode);
+	error = vfs_mkdir(d_inode(nd.path.dentry), dentry, mode);
 out_drop_write:
 	mnt_drop_write(nd.path.mnt);
 out_dput:
 	dput(dentry);
 out_unlock:
-	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(nd.path.dentry)->i_mutex);
 	path_put(&nd.path);
 	putname(tmp);
 out_err:
@@ -2582,7 +2584,7 @@ int vfs_rmdir(struct inode *dir, struct
 	if (!dir->i_op->rmdir)
 		return -EPERM;
 
-	mutex_lock(&dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(dentry)->i_mutex);
 
 	error = -EBUSY;
 	if (d_mountpoint(dentry))
@@ -2597,11 +2599,11 @@ int vfs_rmdir(struct inode *dir, struct
 	if (error)
 		goto out;
 
-	dentry->d_inode->i_flags |= S_DEAD;
+	d_inode(dentry)->i_flags |= S_DEAD;
 	dont_mount(dentry);
 
 out:
-	mutex_unlock(&dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dentry)->i_mutex);
 	if (!error)
 		d_delete(dentry);
 	return error;
@@ -2632,12 +2634,12 @@ static long do_rmdir(int dfd, const char
 
 	nd.flags &= ~LOOKUP_PARENT;
 
-	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
+	mutex_lock_nested(&d_inode(nd.path.dentry)->i_mutex, I_MUTEX_PARENT);
 	dentry = lookup_hash(&nd);
 	error = PTR_ERR(dentry);
 	if (IS_ERR(dentry))
 		goto exit2;
-	if (!dentry->d_inode) {
+	if (!d_inode(dentry)) {
 		error = -ENOENT;
 		goto exit3;
 	}
@@ -2647,13 +2649,13 @@ static long do_rmdir(int dfd, const char
 	error = security_path_rmdir(&nd.path, dentry);
 	if (error)
 		goto exit4;
-	error = vfs_rmdir(nd.path.dentry->d_inode, dentry);
+	error = vfs_rmdir(d_inode(nd.path.dentry), dentry);
 exit4:
 	mnt_drop_write(nd.path.mnt);
 exit3:
 	dput(dentry);
 exit2:
-	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(nd.path.dentry)->i_mutex);
 exit1:
 	path_put(&nd.path);
 	putname(name);
@@ -2675,7 +2677,7 @@ int vfs_unlink(struct inode *dir, struct
 	if (!dir->i_op->unlink)
 		return -EPERM;
 
-	mutex_lock(&dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(dentry)->i_mutex);
 	if (d_mountpoint(dentry))
 		error = -EBUSY;
 	else {
@@ -2686,11 +2688,11 @@ int vfs_unlink(struct inode *dir, struct
 				dont_mount(dentry);
 		}
 	}
-	mutex_unlock(&dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dentry)->i_mutex);
 
 	/* We don't d_delete() NFS sillyrenamed files--they still exist. */
 	if (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {
-		fsnotify_link_count(dentry->d_inode);
+		fsnotify_link_count(d_inode(dentry));
 		d_delete(dentry);
 	}
 
@@ -2721,14 +2723,14 @@ static long do_unlinkat(int dfd, const c
 
 	nd.flags &= ~LOOKUP_PARENT;
 
-	mutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);
+	mutex_lock_nested(&d_inode(nd.path.dentry)->i_mutex, I_MUTEX_PARENT);
 	dentry = lookup_hash(&nd);
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/* Why not before? Because we want correct error value */
 		if (nd.last.name[nd.last.len])
 			goto slashes;
-		inode = dentry->d_inode;
+		inode = d_inode(dentry);
 		if (!inode)
 			goto slashes;
 		ihold(inode);
@@ -2738,13 +2740,13 @@ static long do_unlinkat(int dfd, const c
 		error = security_path_unlink(&nd.path, dentry);
 		if (error)
 			goto exit3;
-		error = vfs_unlink(nd.path.dentry->d_inode, dentry);
+		error = vfs_unlink(d_inode(nd.path.dentry), dentry);
 exit3:
 		mnt_drop_write(nd.path.mnt);
 	exit2:
 		dput(dentry);
 	}
-	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(nd.path.dentry)->i_mutex);
 	if (inode)
 		iput(inode);	/* truncate the inode here */
 exit1:
@@ -2753,8 +2755,8 @@ exit1:
 	return error;
 
 slashes:
-	error = !dentry->d_inode ? -ENOENT :
-		S_ISDIR(dentry->d_inode->i_mode) ? -EISDIR : -ENOTDIR;
+	error = !d_inode(dentry) ? -ENOENT :
+		S_ISDIR(d_inode(dentry)->i_mode) ? -EISDIR : -ENOTDIR;
 	goto exit2;
 }
 
@@ -2822,13 +2824,13 @@ SYSCALL_DEFINE3(symlinkat, const char __
 	error = security_path_symlink(&nd.path, dentry, from);
 	if (error)
 		goto out_drop_write;
-	error = vfs_symlink(nd.path.dentry->d_inode, dentry, from);
+	error = vfs_symlink(d_inode(nd.path.dentry), dentry, from);
 out_drop_write:
 	mnt_drop_write(nd.path.mnt);
 out_dput:
 	dput(dentry);
 out_unlock:
-	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(nd.path.dentry)->i_mutex);
 	path_put(&nd.path);
 	putname(to);
 out_putname:
@@ -2843,7 +2845,7 @@ SYSCALL_DEFINE2(symlink, const char __us
 
 int vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	int error;
 
 	if (!inode)
@@ -2937,13 +2939,13 @@ SYSCALL_DEFINE5(linkat, int, olddfd, con
 	error = security_path_link(old_path.dentry, &nd.path, new_dentry);
 	if (error)
 		goto out_drop_write;
-	error = vfs_link(old_path.dentry, nd.path.dentry->d_inode, new_dentry);
+	error = vfs_link(old_path.dentry, d_inode(nd.path.dentry), new_dentry);
 out_drop_write:
 	mnt_drop_write(nd.path.mnt);
 out_dput:
 	dput(new_dentry);
 out_unlock:
-	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(nd.path.dentry)->i_mutex);
 out_release:
 	path_put(&nd.path);
 	putname(to);
@@ -2989,14 +2991,14 @@ static int vfs_rename_dir(struct inode *
 			  struct inode *new_dir, struct dentry *new_dentry)
 {
 	int error = 0;
-	struct inode *target = new_dentry->d_inode;
+	struct inode *target = d_inode(new_dentry);
 
 	/*
 	 * If we are going to change the parent - check write permissions,
 	 * we'll need to flip '..'.
 	 */
 	if (new_dir != old_dir) {
-		error = inode_permission(old_dentry->d_inode, MAY_WRITE);
+		error = inode_permission(d_inode(old_dentry), MAY_WRITE);
 		if (error)
 			return error;
 	}
@@ -3034,7 +3036,7 @@ out:
 static int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,
 			    struct inode *new_dir, struct dentry *new_dentry)
 {
-	struct inode *target = new_dentry->d_inode;
+	struct inode *target = d_inode(new_dentry);
 	int error;
 
 	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);
@@ -3068,17 +3070,17 @@ int vfs_rename(struct inode *old_dir, st
 	       struct inode *new_dir, struct dentry *new_dentry)
 {
 	int error;
-	int is_dir = S_ISDIR(old_dentry->d_inode->i_mode);
+	int is_dir = S_ISDIR(d_inode(old_dentry)->i_mode);
 	const unsigned char *old_name;
 
-	if (old_dentry->d_inode == new_dentry->d_inode)
+	if (d_inode(old_dentry) == d_inode(new_dentry))
  		return 0;
  
 	error = may_delete(old_dir, old_dentry, is_dir);
 	if (error)
 		return error;
 
-	if (!new_dentry->d_inode)
+	if (!d_inode(new_dentry))
 		error = may_create(new_dir, new_dentry);
 	else
 		error = may_delete(new_dir, new_dentry, is_dir);
@@ -3096,7 +3098,7 @@ int vfs_rename(struct inode *old_dir, st
 		error = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry);
 	if (!error)
 		fsnotify_move(old_dir, new_dir, old_name, is_dir,
-			      new_dentry->d_inode, old_dentry);
+			      d_inode(new_dentry), old_dentry);
 	fsnotify_oldname_free(old_name);
 
 	return error;
@@ -3146,10 +3148,10 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
 		goto exit3;
 	/* source must exist */
 	error = -ENOENT;
-	if (!old_dentry->d_inode)
+	if (!d_inode(old_dentry))
 		goto exit4;
 	/* unless the source is a directory trailing slashes give -ENOTDIR */
-	if (!S_ISDIR(old_dentry->d_inode->i_mode)) {
+	if (!S_ISDIR(d_inode(old_dentry)->i_mode)) {
 		error = -ENOTDIR;
 		if (oldnd.last.name[oldnd.last.len])
 			goto exit4;
@@ -3176,8 +3178,8 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
 				     &newnd.path, new_dentry);
 	if (error)
 		goto exit6;
-	error = vfs_rename(old_dir->d_inode, old_dentry,
-				   new_dir->d_inode, new_dentry);
+	error = vfs_rename(d_inode(old_dir), old_dentry,
+				   d_inode(new_dir), new_dentry);
 exit6:
 	mnt_drop_write(oldnd.path.mnt);
 exit5:
@@ -3230,13 +3232,13 @@ int generic_readlink(struct dentry *dent
 	int res;
 
 	nd.depth = 0;
-	cookie = dentry->d_inode->i_op->follow_link(dentry, &nd);
+	cookie = d_inode(dentry)->i_op->follow_link(dentry, &nd);
 	if (IS_ERR(cookie))
 		return PTR_ERR(cookie);
 
 	res = vfs_readlink(dentry, buffer, buflen, nd_get_link(&nd));
-	if (dentry->d_inode->i_op->put_link)
-		dentry->d_inode->i_op->put_link(dentry, &nd, cookie);
+	if (d_inode(dentry)->i_op->put_link)
+		d_inode(dentry)->i_op->put_link(dentry, &nd, cookie);
 	return res;
 }
 
@@ -3250,13 +3252,13 @@ static char *page_getlink(struct dentry
 {
 	char *kaddr;
 	struct page *page;
-	struct address_space *mapping = dentry->d_inode->i_mapping;
+	struct address_space *mapping = d_inode(dentry)->i_mapping;
 	page = read_mapping_page(mapping, 0, NULL);
 	if (IS_ERR(page))
 		return (char*)page;
 	*ppage = page;
 	kaddr = kmap(page);
-	nd_terminate_link(kaddr, dentry->d_inode->i_size, PAGE_SIZE - 1);
+	nd_terminate_link(kaddr, d_inode(dentry)->i_size, PAGE_SIZE - 1);
 	return kaddr;
 }
 
diff -u -p a/ncpfs/symlink.c b/ncpfs/symlink.c
--- a/ncpfs/symlink.c
+++ b/ncpfs/symlink.c
@@ -156,7 +156,7 @@ int ncp_symlink(struct inode *dir, struc
 		goto failfree;
 	}
 
-	inode=dentry->d_inode;
+	inode=d_inode(dentry);
 
 	if (ncp_make_open(inode, O_WRONLY))
 		goto failfree;
diff -u -p a/ncpfs/inode.c b/ncpfs/inode.c
--- a/ncpfs/inode.c
+++ b/ncpfs/inode.c
@@ -522,7 +522,7 @@ static int ncp_fill_super(struct super_b
 	if (!ncp_filp)
 		goto out;
 	error = -ENOTSOCK;
-	sock_inode = ncp_filp->f_path.dentry->d_inode;
+	sock_inode = d_inode(ncp_filp->f_path.dentry);
 	if (!S_ISSOCK(sock_inode->i_mode))
 		goto out_fput;
 	sock = SOCKET_I(sock_inode);
@@ -561,7 +561,7 @@ static int ncp_fill_super(struct super_b
 		if (!server->info_filp)
 			goto out_fput;
 		error = -ENOTSOCK;
-		sock_inode = server->info_filp->f_path.dentry->d_inode;
+		sock_inode = d_inode(server->info_filp->f_path.dentry);
 		if (!S_ISSOCK(sock_inode->i_mode))
 			goto out_fput2;
 		info_sock = SOCKET_I(sock_inode);
@@ -812,7 +812,7 @@ static int ncp_statfs(struct dentry *den
 	if (!d) {
 		goto dflt;
 	}
-	i = d->d_inode;
+	i = d_inode(d);
 	if (!i) {
 		goto dflt;
 	}
@@ -865,7 +865,7 @@ dflt:;
 
 int ncp_notify_change(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int result = 0;
 	__le32 info_mask;
 	struct nw_modify_dos_info info;
diff -u -p a/ncpfs/ncplib_kernel.c b/ncpfs/ncplib_kernel.c
--- a/ncpfs/ncplib_kernel.c
+++ b/ncpfs/ncplib_kernel.c
@@ -729,7 +729,7 @@ int
 ncp_del_file_or_subdir2(struct ncp_server *server,
 			struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	__u8  volnum;
 	__le32 dirent;
 
diff -u -p a/ncpfs/file.c b/ncpfs/file.c
--- a/ncpfs/file.c
+++ b/ncpfs/file.c
@@ -100,7 +100,7 @@ static ssize_t
 ncp_file_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 {
 	struct dentry *dentry = file->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	size_t already_read = 0;
 	off_t pos;
 	size_t bufsize;
@@ -178,7 +178,7 @@ static ssize_t
 ncp_file_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
 {
 	struct dentry *dentry = file->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	size_t already_written = 0;
 	off_t pos;
 	size_t bufsize;
diff -u -p a/ncpfs/mmap.c b/ncpfs/mmap.c
--- a/ncpfs/mmap.c
+++ b/ncpfs/mmap.c
@@ -33,7 +33,7 @@ static int ncp_file_mmap_fault(struct vm
 {
 	struct file *file = area->vm_file;
 	struct dentry *dentry = file->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	char *pg_addr;
 	unsigned int already_read;
 	unsigned int count;
@@ -106,7 +106,7 @@ static const struct vm_operations_struct
 /* This is used for a general mmap of a ncp file */
 int ncp_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	
 	DPRINTK("ncp_mmap: called\n");
 
diff -u -p a/ncpfs/dir.c b/ncpfs/dir.c
--- a/ncpfs/dir.c
+++ b/ncpfs/dir.c
@@ -162,7 +162,7 @@ ncp_compare_dentry(const struct dentry *
 static int
 ncp_delete_dentry(const struct dentry * dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	if (inode) {
 		if (is_bad_inode(inode))
@@ -183,7 +183,7 @@ ncp_single_volume(struct ncp_server *ser
 static inline int ncp_is_server_root(struct inode *inode)
 {
 	return (!ncp_single_volume(NCP_SERVER(inode)) &&
-		inode == inode->i_sb->s_root->d_inode);
+		inode == d_inode(inode->i_sb->s_root));
 }
 
 
@@ -206,7 +206,7 @@ ncp_force_unlink(struct inode *dir, stru
 	memset(&info, 0, sizeof(info));
 	
         /* remove the Read-Only flag on the NW server */
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	old_nwattr = NCP_FINFO(inode)->nwattr;
 	info.attributes = old_nwattr & ~(aRONLY|aDELETEINHIBIT|aRENAMEINHIBIT);
@@ -236,7 +236,7 @@ ncp_force_rename(struct inode *old_dir,
 {
 	struct nw_modify_dos_info info;
         int res=0x90,res2;
-	struct inode *old_inode = old_dentry->d_inode;
+	struct inode *old_inode = d_inode(old_dentry);
 	__le32 old_nwattr = NCP_FINFO(old_inode)->nwattr;
 	__le32 new_nwattr = 0; /* shut compiler warning */
 	int old_nwattr_changed = 0;
@@ -250,8 +250,8 @@ ncp_force_rename(struct inode *old_dir,
 	res2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(old_inode), old_inode, NULL, DM_ATTRIBUTES, &info);
 	if (!res2)
 		old_nwattr_changed = 1;
-	if (new_dentry && new_dentry->d_inode) {
-		new_nwattr = NCP_FINFO(new_dentry->d_inode)->nwattr;
+	if (new_dentry && d_inode(new_dentry)) {
+		new_nwattr = NCP_FINFO(d_inode(new_dentry))->nwattr;
 		info.attributes = new_nwattr & ~(aRONLY|aRENAMEINHIBIT|aDELETEINHIBIT);
 		res2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(new_dir), new_dir, _new_name, DM_ATTRIBUTES, &info);
 		if (!res2)
@@ -306,9 +306,9 @@ ncp_lookup_validate(struct dentry *dentr
 		return -ECHILD;
 
 	parent = dget_parent(dentry);
-	dir = parent->d_inode;
+	dir = d_inode(parent);
 
-	if (!dentry->d_inode)
+	if (!d_inode(dentry))
 		goto finished;
 
 	server = NCP_SERVER(dir);
@@ -350,7 +350,7 @@ ncp_lookup_validate(struct dentry *dentr
 	 * what we remember, it's not valid any more.
 	 */
 	if (!res) {
-		struct inode *inode = dentry->d_inode;
+		struct inode *inode = d_inode(dentry);
 
 		mutex_lock(&inode->i_mutex);
 		if (finfo.i.dirEntNum == NCP_FINFO(inode)->dirEntNum) {
@@ -378,7 +378,7 @@ ncp_dget_fpos(struct dentry *dentry, str
 	if (d_validate(dent, parent)) {
 		if (dent->d_name.len <= NCP_MAXPATHLEN &&
 		    (unsigned long)dent->d_fsdata == fpos) {
-			if (!dent->d_inode) {
+			if (!d_inode(dent)) {
 				dput(dent);
 				dent = NULL;
 			}
@@ -393,7 +393,7 @@ ncp_dget_fpos(struct dentry *dentry, str
 	while (next != &parent->d_subdirs) {
 		dent = list_entry(next, struct dentry, d_u.d_child);
 		if ((unsigned long)dent->d_fsdata == fpos) {
-			if (dent->d_inode)
+			if (d_inode(dent))
 				dget(dent);
 			else
 				dent = NULL;
@@ -411,7 +411,7 @@ out:
 
 static time_t ncp_obtain_mtime(struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ncp_server *server = NCP_SERVER(inode);
 	struct nw_info_struct i;
 
@@ -427,7 +427,7 @@ static time_t ncp_obtain_mtime(struct de
 static int ncp_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
 	struct dentry *dentry = filp->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct page *page = NULL;
 	struct ncp_server *server = NCP_SERVER(inode);
 	union  ncp_dir_cache *cache = NULL;
@@ -505,7 +505,7 @@ static int ncp_readdir(struct file *filp
 				goto invalid_cache;
 			res = filldir(dirent, dent->d_name.name,
 					dent->d_name.len, filp->f_pos,
-					dent->d_inode->i_ino, DT_UNKNOWN);
+					d_inode(dent)->i_ino, DT_UNKNOWN);
 			dput(dent);
 			if (res)
 				goto finished;
@@ -578,7 +578,7 @@ ncp_fill_cache(struct file *filp, void *
 		int inval_childs)
 {
 	struct dentry *newdent, *dentry = filp->f_path.dentry;
-	struct inode *dir = dentry->d_inode;
+	struct inode *dir = d_inode(dentry);
 	struct ncp_cache_control ctl = *ctrl;
 	struct qstr qname;
 	int valid = 0;
@@ -596,7 +596,7 @@ ncp_fill_cache(struct file *filp, void *
 	qname.hash = full_name_hash(qname.name, qname.len);
 
 	if (dentry->d_op && dentry->d_op->d_hash)
-		if (dentry->d_op->d_hash(dentry, dentry->d_inode, &qname) != 0)
+		if (dentry->d_op->d_hash(dentry, d_inode(dentry), &qname) != 0)
 			goto end_advance;
 
 	newdent = d_lookup(dentry, &qname);
@@ -623,7 +623,7 @@ ncp_fill_cache(struct file *filp, void *
 		dentry_update_name_case(newdent, &qname);
 	}
 
-	if (!newdent->d_inode) {
+	if (!d_inode(newdent)) {
 		struct inode *inode;
 
 		entry->opened = 0;
@@ -635,15 +635,15 @@ ncp_fill_cache(struct file *filp, void *
 				d_rehash(newdent);
 		}
 	} else {
-		struct inode *inode = newdent->d_inode;
+		struct inode *inode = d_inode(newdent);
 
 		mutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);
 		ncp_update_inode2(inode, entry);
 		mutex_unlock(&inode->i_mutex);
 	}
 
-	if (newdent->d_inode) {
-		ino = newdent->d_inode->i_ino;
+	if (d_inode(newdent)) {
+		ino = d_inode(newdent)->i_ino;
 		newdent->d_fsdata = (void *) ctl.fpos;
 		ncp_new_dentry(newdent);
 	}
@@ -691,7 +691,7 @@ ncp_read_volume_list(struct file *filp,
 			struct ncp_cache_control *ctl)
 {
 	struct dentry *dentry = filp->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ncp_server *server = NCP_SERVER(inode);
 	struct ncp_volume_info info;
 	struct ncp_entry_info entry;
@@ -729,7 +729,7 @@ ncp_do_readdir(struct file *filp, void *
 						struct ncp_cache_control *ctl)
 {
 	struct dentry *dentry = filp->f_path.dentry;
-	struct inode *dir = dentry->d_inode;
+	struct inode *dir = d_inode(dentry);
 	struct ncp_server *server = NCP_SERVER(dir);
 	struct nw_search_sequence seq;
 	struct ncp_entry_info entry;
@@ -816,7 +816,7 @@ int ncp_conn_logged_in(struct super_bloc
 		}
 		dent = sb->s_root;
 		if (dent) {
-			struct inode* ino = dent->d_inode;
+			struct inode* ino = d_inode(dent);
 			if (ino) {
 				ncp_update_known_namespace(server, volNumber, NULL);
 				NCP_FINFO(ino)->volNumber = volNumber;
@@ -1080,7 +1080,7 @@ out:
 
 static int ncp_unlink(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ncp_server *server;
 	int error;
 
@@ -1144,7 +1144,7 @@ static int ncp_rename(struct inode *old_
 		old_dentry->d_parent->d_name.name, old_dentry->d_name.name,
 		new_dentry->d_parent->d_name.name, new_dentry->d_name.name);
 
-	if (new_dentry->d_inode && S_ISDIR(new_dentry->d_inode->i_mode)) {
+	if (d_inode(new_dentry) && S_ISDIR(d_inode(new_dentry)->i_mode)) {
 		/*
 		 * fail with EBUSY if there are still references to this
 		 * directory.
diff -u -p a/ncpfs/ioctl.c b/ncpfs/ioctl.c
--- a/ncpfs/ioctl.c
+++ b/ncpfs/ioctl.c
@@ -374,7 +374,7 @@ static long __ncp_ioctl(struct inode *in
 				struct dentry* dentry = inode->i_sb->s_root;
 
 				if (dentry) {
-					struct inode* s_inode = dentry->d_inode;
+					struct inode* s_inode = d_inode(dentry);
 
 					if (s_inode) {
 						sr.volNumber = NCP_FINFO(s_inode)->volNumber;
@@ -429,7 +429,7 @@ static long __ncp_ioctl(struct inode *in
 				if (result == 0) {
 					dentry = inode->i_sb->s_root;
 					if (dentry) {
-						struct inode* s_inode = dentry->d_inode;
+						struct inode* s_inode = d_inode(dentry);
 
 						if (s_inode) {
 							NCP_FINFO(s_inode)->volNumber = vnum;
@@ -808,7 +808,7 @@ outrel:
 
 long ncp_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = filp->f_dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_dentry);
 	struct ncp_server *server = NCP_SERVER(inode);
 	uid_t uid = current_uid();
 	int need_drop_write = 0;
diff -u -p a/dcache.c b/dcache.c
--- a/dcache.c
+++ b/dcache.c
@@ -185,9 +185,9 @@ static void dentry_iput(struct dentry *
 	__releases(dentry->d_lock)
 	__releases(dentry->d_inode->i_lock)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	if (inode) {
-		dentry->d_inode = NULL;
+		d_inode(dentry) = NULL;
 		list_del_init(&dentry->d_alias);
 		spin_unlock(&dentry->d_lock);
 		spin_unlock(&inode->i_lock);
@@ -210,8 +210,8 @@ static void dentry_unlink_inode(struct d
 	__releases(dentry->d_lock)
 	__releases(dentry->d_inode->i_lock)
 {
-	struct inode *inode = dentry->d_inode;
-	dentry->d_inode = NULL;
+	struct inode *inode = d_inode(dentry);
+	d_inode(dentry) = NULL;
 	list_del_init(&dentry->d_alias);
 	dentry_rcuwalk_barrier(dentry);
 	spin_unlock(&dentry->d_lock);
@@ -355,7 +355,7 @@ static inline struct dentry *dentry_kill
 	struct inode *inode;
 	struct dentry *parent;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	if (inode && !spin_trylock(&inode->i_lock)) {
 relock:
 		spin_unlock(&dentry->d_lock);
@@ -490,7 +490,7 @@ int d_invalidate(struct dentry * dentry)
 	 * working directory or similar).
 	 */
 	if (dentry->d_count > 1) {
-		if (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode)) {
+		if (d_inode(dentry) && S_ISDIR(d_inode(dentry)->i_mode)) {
 			spin_unlock(&dentry->d_lock);
 			return -EBUSY;
 		}
@@ -917,8 +917,8 @@ static void shrink_dcache_for_umount_sub
 				       " still in use (%d)"
 				       " [unmount of %s %s]\n",
 				       dentry,
-				       dentry->d_inode ?
-				       dentry->d_inode->i_ino : 0UL,
+				       d_inode(dentry) ?
+				       d_inode(dentry)->i_ino : 0UL,
 				       dentry->d_name.name,
 				       dentry->d_count,
 				       dentry->d_sb->s_type->name,
@@ -939,9 +939,9 @@ static void shrink_dcache_for_umount_sub
 
 			detached++;
 
-			inode = dentry->d_inode;
+			inode = d_inode(dentry);
 			if (inode) {
-				dentry->d_inode = NULL;
+				d_inode(dentry) = NULL;
 				list_del_init(&dentry->d_alias);
 				if (dentry->d_op && dentry->d_op->d_iput)
 					dentry->d_op->d_iput(dentry, inode);
@@ -1290,7 +1290,7 @@ struct dentry *d_alloc(struct dentry * p
 	dentry->d_flags = 0;
 	spin_lock_init(&dentry->d_lock);
 	seqcount_init(&dentry->d_seq);
-	dentry->d_inode = NULL;
+	d_inode(dentry) = NULL;
 	dentry->d_parent = NULL;
 	dentry->d_sb = NULL;
 	dentry->d_op = NULL;
@@ -1375,7 +1375,7 @@ static void __d_instantiate(struct dentr
 			dentry->d_flags |= DCACHE_NEED_AUTOMOUNT;
 		list_add(&dentry->d_alias, &inode->i_dentry);
 	}
-	dentry->d_inode = inode;
+	d_inode(dentry) = inode;
 	dentry_rcuwalk_barrier(dentry);
 	spin_unlock(&dentry->d_lock);
 	fsnotify_d_instantiate(dentry, inode);
@@ -1586,7 +1586,7 @@ struct dentry *d_obtain_alias(struct ino
 	spin_lock(&tmp->d_lock);
 	tmp->d_sb = inode->i_sb;
 	d_set_d_op(tmp, tmp->d_sb->s_d_op);
-	tmp->d_inode = inode;
+	d_inode(tmp) = inode;
 	tmp->d_flags |= DCACHE_DISCONNECTED;
 	list_add(&tmp->d_alias, &inode->i_dentry);
 	hlist_bl_lock(&tmp->d_sb->s_anon);
@@ -1697,11 +1697,11 @@ struct dentry *d_add_ci(struct dentry *d
 	 * Decrement the reference count to balance the iget() done
 	 * earlier on.
 	 */
-	if (found->d_inode) {
-		if (unlikely(found->d_inode != inode)) {
+	if (d_inode(found)) {
+		if (unlikely(d_inode(found) != inode)) {
 			/* This can't happen because bad inodes are unhashed. */
 			BUG_ON(!is_bad_inode(inode));
-			BUG_ON(!is_bad_inode(found->d_inode));
+			BUG_ON(!is_bad_inode(d_inode(found)));
 		}
 		iput(inode);
 		return found;
@@ -1811,7 +1811,7 @@ seqretry:
 			continue;
 		tlen = dentry->d_name.len;
 		tname = dentry->d_name.name;
-		i = dentry->d_inode;
+		i = d_inode(dentry);
 		prefetch(tname);
 		/*
 		 * This seqcount check is required to ensure name and
@@ -1935,9 +1935,9 @@ struct dentry *__d_lookup(struct dentry
 		tlen = dentry->d_name.len;
 		tname = dentry->d_name.name;
 		if (parent->d_flags & DCACHE_OP_COMPARE) {
-			if (parent->d_op->d_compare(parent, parent->d_inode,
-						dentry, dentry->d_inode,
-						tlen, tname, name))
+			if (parent->d_op->d_compare(parent, d_inode(parent),
+ 	 	 	 	 	       dentry, d_inode(dentry),
+ 	 	 	 	 	       tlen, tname, name))
 				goto next;
 		} else {
 			if (dentry_cmp(tname, tlen, str, len))
@@ -1974,7 +1974,7 @@ struct dentry *d_hash_and_lookup(struct
 	 */
 	name->hash = full_name_hash(name->name, name->len);
 	if (dir->d_flags & DCACHE_OP_HASH) {
-		if (dir->d_op->d_hash(dir, dir->d_inode, name) < 0)
+		if (dir->d_op->d_hash(dir, d_inode(dir), name) < 0)
 			goto out;
 	}
 	dentry = d_lookup(dir, name);
@@ -2043,7 +2043,7 @@ void d_delete(struct dentry * dentry)
 	 */
 again:
 	spin_lock(&dentry->d_lock);
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	isdir = S_ISDIR(inode->i_mode);
 	if (dentry->d_count == 1) {
 		if (inode && !spin_trylock(&inode->i_lock)) {
@@ -2111,7 +2111,7 @@ EXPORT_SYMBOL(d_rehash);
  */
 void dentry_update_name_case(struct dentry *dentry, struct qstr *name)
 {
-	BUG_ON(!mutex_is_locked(&dentry->d_parent->d_inode->i_mutex));
+	BUG_ON(!mutex_is_locked(&d_inode(dentry->d_parent)->i_mutex));
 	BUG_ON(dentry->d_name.len != name->len); /* d_lookup gives this */
 
 	spin_lock(&dentry->d_lock);
@@ -2221,7 +2221,7 @@ static void dentry_unlock_parents_for_mo
  */
 static void __d_move(struct dentry * dentry, struct dentry * target)
 {
-	if (!dentry->d_inode)
+	if (!d_inode(dentry))
 		printk(KERN_WARNING "VFS: moving negative dcache entry\n");
 
 	BUG_ON(d_ancestor(dentry, target));
@@ -2333,9 +2333,9 @@ static struct dentry *__d_unalias(struct
 	if (!mutex_trylock(&dentry->d_sb->s_vfs_rename_mutex))
 		goto out_err;
 	m1 = &dentry->d_sb->s_vfs_rename_mutex;
-	if (!mutex_trylock(&alias->d_parent->d_inode->i_mutex))
+	if (!mutex_trylock(&d_inode(alias->d_parent)->i_mutex))
 		goto out_err;
-	m2 = &alias->d_parent->d_inode->i_mutex;
+	m2 = &d_inode(alias->d_parent)->i_mutex;
 out_unalias:
 	__d_move(alias, dentry);
 	ret = alias;
@@ -2929,7 +2929,7 @@ resume:
 		next = tmp->next;
 
 		spin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);
-		if (d_unhashed(dentry) || !dentry->d_inode) {
+		if (d_unhashed(dentry) || !d_inode(dentry)) {
 			spin_unlock(&dentry->d_lock);
 			continue;
 		}
@@ -2992,8 +2992,8 @@ ino_t find_inode_number(struct dentry *d
 
 	dentry = d_hash_and_lookup(dir, name);
 	if (dentry) {
-		if (dentry->d_inode)
-			ino = dentry->d_inode->i_ino;
+		if (d_inode(dentry))
+			ino = d_inode(dentry)->i_ino;
 		dput(dentry);
 	}
 	return ino;
diff -u -p a/pstore/inode.c b/pstore/inode.c
--- a/pstore/inode.c
+++ b/pstore/inode.c
@@ -71,7 +71,7 @@ static const struct file_operations psto
  */
 static int pstore_unlink(struct inode *dir, struct dentry *dentry)
 {
-	struct pstore_private *p = dentry->d_inode->i_private;
+	struct pstore_private *p = d_inode(dentry)->i_private;
 
 	p->erase(p->id);
 
@@ -186,7 +186,7 @@ int pstore_mkfile(enum pstore_type_id ty
 	struct pstore_private	*private;
 
 	rc = -ENOMEM;
-	inode = pstore_get_inode(pstore_sb, root->d_inode, S_IFREG | 0444, 0);
+	inode = pstore_get_inode(pstore_sb, d_inode(root), S_IFREG | 0444, 0);
 	if (!inode)
 		goto fail;
 	private = kmalloc(sizeof *private + size, GFP_KERNEL);
@@ -210,7 +210,7 @@ int pstore_mkfile(enum pstore_type_id ty
 		break;
 	}
 
-	mutex_lock(&root->d_inode->i_mutex);
+	mutex_lock(&d_inode(root)->i_mutex);
 
 	rc = -ENOSPC;
 	dentry = d_alloc_name(root, name);
@@ -227,12 +227,12 @@ int pstore_mkfile(enum pstore_type_id ty
 
 	d_add(dentry, inode);
 
-	mutex_unlock(&root->d_inode->i_mutex);
+	mutex_unlock(&d_inode(root)->i_mutex);
 
 	return 0;
 
 fail_lockedalloc:
-	mutex_unlock(&root->d_inode->i_mutex);
+	mutex_unlock(&d_inode(root)->i_mutex);
 	kfree(private);
 fail_alloc:
 	iput(inode);
diff -u -p a/file_table.c b/file_table.c
--- a/file_table.c
+++ b/file_table.c
@@ -176,7 +176,7 @@ struct file *alloc_file(struct path *pat
 		return NULL;
 
 	file->f_path = *path;
-	file->f_mapping = path->dentry->d_inode->i_mapping;
+	file->f_mapping = d_inode(path->dentry)->i_mapping;
 	file->f_mode = mode;
 	file->f_op = fop;
 
@@ -186,12 +186,12 @@ struct file *alloc_file(struct path *pat
 	 * visible.  We do this for consistency, and so
 	 * that we can do debugging checks at __fput()
 	 */
-	if ((mode & FMODE_WRITE) && !special_file(path->dentry->d_inode->i_mode)) {
+	if ((mode & FMODE_WRITE) && !special_file(d_inode(path->dentry)->i_mode)) {
 		file_take_write(file);
 		WARN_ON(mnt_clone_write(path->mnt));
 	}
 	if ((mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)
-		i_readcount_inc(path->dentry->d_inode);
+		i_readcount_inc(d_inode(path->dentry));
 	return file;
 }
 EXPORT_SYMBOL(alloc_file);
@@ -208,7 +208,7 @@ void drop_file_write_access(struct file
 {
 	struct vfsmount *mnt = file->f_path.mnt;
 	struct dentry *dentry = file->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	put_write_access(inode);
 
@@ -227,7 +227,7 @@ static void __fput(struct file *file)
 {
 	struct dentry *dentry = file->f_path.dentry;
 	struct vfsmount *mnt = file->f_path.mnt;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	might_sleep();
 
@@ -480,7 +480,7 @@ int fs_may_remount_ro(struct super_block
 	/* Check that no files are currently opened for writing. */
 	lg_global_lock(files_lglock);
 	do_file_list_for_each_entry(sb, file) {
-		struct inode *inode = file->f_path.dentry->d_inode;
+		struct inode *inode = d_inode(file->f_path.dentry);
 
 		/* File with pending delete? */
 		if (inode->i_nlink == 0)
@@ -512,7 +512,7 @@ retry:
 	lg_global_lock(files_lglock);
 	do_file_list_for_each_entry(sb, f) {
 		struct vfsmount *mnt;
-		if (!S_ISREG(f->f_path.dentry->d_inode->i_mode))
+		if (!S_ISREG(d_inode(f->f_path.dentry)->i_mode))
 		       continue;
 		if (!file_count(f))
 			continue;
diff -u -p a/lockd/clntproc.c b/lockd/clntproc.c
--- a/lockd/clntproc.c
+++ b/lockd/clntproc.c
@@ -127,7 +127,8 @@ static void nlmclnt_setlockargs(struct n
 	struct nlm_lock	*lock = &argp->lock;
 
 	nlmclnt_next_cookie(&argp->cookie);
-	memcpy(&lock->fh, NFS_FH(fl->fl_file->f_path.dentry->d_inode), sizeof(struct nfs_fh));
+	memcpy(&lock->fh, NFS_FH(d_inode(fl->fl_file->f_path.dentry)),
+	       sizeof(struct nfs_fh));
 	lock->caller  = utsname()->nodename;
 	lock->oh.data = req->a_owner;
 	lock->oh.len  = snprintf(req->a_owner, sizeof(req->a_owner), "%u@%s",
diff -u -p a/lockd/clntlock.c b/lockd/clntlock.c
--- a/lockd/clntlock.c
+++ b/lockd/clntlock.c
@@ -175,7 +175,7 @@ __be32 nlmclnt_grant(const struct sockad
 			continue;
 		if (!rpc_cmp_addr(nlm_addr(block->b_host), addr))
 			continue;
-		if (nfs_compare_fh(NFS_FH(fl_blocked->fl_file->f_path.dentry->d_inode) ,fh) != 0)
+		if (nfs_compare_fh(NFS_FH(d_inode(fl_blocked->fl_file->f_path.dentry)) ,fh) != 0)
 			continue;
 		/* Alright, we found a lock. Set the return status
 		 * and wake up the caller
diff -u -p a/lockd/svcsubs.c b/lockd/svcsubs.c
--- a/lockd/svcsubs.c
+++ b/lockd/svcsubs.c
@@ -45,7 +45,7 @@ static inline void nlm_debug_print_fh(ch
 
 static inline void nlm_debug_print_file(char *msg, struct nlm_file *file)
 {
-	struct inode *inode = file->f_file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_file->f_path.dentry);
 
 	dprintk("lockd: %s %s/%ld\n",
 		msg, inode->i_sb->s_id, inode->i_ino);
diff -u -p a/lockd/svclock.c b/lockd/svclock.c
--- a/lockd/svclock.c
+++ b/lockd/svclock.c
@@ -380,8 +380,8 @@ nlmsvc_lock(struct svc_rqst *rqstp, stru
 	__be32			ret;
 
 	dprintk("lockd: nlmsvc_lock(%s/%ld, ty=%d, pi=%d, %Ld-%Ld, bl=%d)\n",
-				file->f_file->f_path.dentry->d_inode->i_sb->s_id,
-				file->f_file->f_path.dentry->d_inode->i_ino,
+				d_inode(file->f_file->f_path.dentry)->i_sb->s_id,
+				d_inode(file->f_file->f_path.dentry)->i_ino,
 				lock->fl.fl_type, lock->fl.fl_pid,
 				(long long)lock->fl.fl_start,
 				(long long)lock->fl.fl_end,
@@ -487,8 +487,8 @@ nlmsvc_testlock(struct svc_rqst *rqstp,
 	__be32			ret;
 
 	dprintk("lockd: nlmsvc_testlock(%s/%ld, ty=%d, %Ld-%Ld)\n",
-				file->f_file->f_path.dentry->d_inode->i_sb->s_id,
-				file->f_file->f_path.dentry->d_inode->i_ino,
+				d_inode(file->f_file->f_path.dentry)->i_sb->s_id,
+				d_inode(file->f_file->f_path.dentry)->i_ino,
 				lock->fl.fl_type,
 				(long long)lock->fl.fl_start,
 				(long long)lock->fl.fl_end);
@@ -580,8 +580,8 @@ nlmsvc_unlock(struct nlm_file *file, str
 	int	error;
 
 	dprintk("lockd: nlmsvc_unlock(%s/%ld, pi=%d, %Ld-%Ld)\n",
-				file->f_file->f_path.dentry->d_inode->i_sb->s_id,
-				file->f_file->f_path.dentry->d_inode->i_ino,
+				d_inode(file->f_file->f_path.dentry)->i_sb->s_id,
+				d_inode(file->f_file->f_path.dentry)->i_ino,
 				lock->fl.fl_pid,
 				(long long)lock->fl.fl_start,
 				(long long)lock->fl.fl_end);
@@ -609,8 +609,8 @@ nlmsvc_cancel_blocked(struct nlm_file *f
 	int status = 0;
 
 	dprintk("lockd: nlmsvc_cancel(%s/%ld, pi=%d, %Ld-%Ld)\n",
-				file->f_file->f_path.dentry->d_inode->i_sb->s_id,
-				file->f_file->f_path.dentry->d_inode->i_ino,
+				d_inode(file->f_file->f_path.dentry)->i_sb->s_id,
+				d_inode(file->f_file->f_path.dentry)->i_ino,
 				lock->fl.fl_pid,
 				(long long)lock->fl.fl_start,
 				(long long)lock->fl.fl_end);
diff -u -p a/sysv/symlink.c b/sysv/symlink.c
--- a/sysv/symlink.c
+++ b/sysv/symlink.c
@@ -10,7 +10,7 @@
 
 static void *sysv_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	nd_set_link(nd, (char *)SYSV_I(dentry->d_inode)->i_data);
+	nd_set_link(nd, (char *)SYSV_I(d_inode(dentry))->i_data);
 	return NULL;
 }
 
diff -u -p a/sysv/file.c b/sysv/file.c
--- a/sysv/file.c
+++ b/sysv/file.c
@@ -32,7 +32,7 @@ const struct file_operations sysv_file_o
 
 static int sysv_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	error = inode_change_ok(inode, attr);
diff -u -p a/sysv/namei.c b/sysv/namei.c
--- a/sysv/namei.c
+++ b/sysv/namei.c
@@ -119,7 +119,7 @@ out_fail:
 static int sysv_link(struct dentry * old_dentry, struct inode * dir, 
 	struct dentry * dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 
 	if (inode->i_nlink >= SYSV_SB(inode->i_sb)->s_link_max)
 		return -EMLINK;
@@ -172,7 +172,7 @@ out_dir:
 
 static int sysv_unlink(struct inode * dir, struct dentry * dentry)
 {
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	struct page * page;
 	struct sysv_dir_entry * de;
 	int err = -ENOENT;
@@ -193,7 +193,7 @@ out:
 
 static int sysv_rmdir(struct inode * dir, struct dentry * dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int err = -ENOTEMPTY;
 
 	if (sysv_empty_dir(inode)) {
@@ -214,8 +214,8 @@ static int sysv_rmdir(struct inode * dir
 static int sysv_rename(struct inode * old_dir, struct dentry * old_dentry,
 		  struct inode * new_dir, struct dentry * new_dentry)
 {
-	struct inode * old_inode = old_dentry->d_inode;
-	struct inode * new_inode = new_dentry->d_inode;
+	struct inode * old_inode = d_inode(old_dentry);
+	struct inode * new_inode = d_inode(new_dentry);
 	struct page * dir_page = NULL;
 	struct sysv_dir_entry * dir_de = NULL;
 	struct page * old_page;
diff -u -p a/sysv/itree.c b/sysv/itree.c
--- a/sysv/itree.c
+++ b/sysv/itree.c
@@ -443,7 +443,7 @@ static unsigned sysv_nblocks(struct supe
 int sysv_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
 	struct super_block *s = mnt->mnt_sb;
-	generic_fillattr(dentry->d_inode, stat);
+	generic_fillattr(d_inode(dentry), stat);
 	stat->blocks = (s->s_blocksize / 512) * sysv_nblocks(s, stat->size);
 	stat->blksize = s->s_blocksize;
 	return 0;
diff -u -p a/sysv/dir.c b/sysv/dir.c
--- a/sysv/dir.c
+++ b/sysv/dir.c
@@ -68,7 +68,7 @@ static struct page * dir_get_page(struct
 static int sysv_readdir(struct file * filp, void * dirent, filldir_t filldir)
 {
 	unsigned long pos = filp->f_pos;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct super_block *sb = inode->i_sb;
 	unsigned offset = pos & ~PAGE_CACHE_MASK;
 	unsigned long n = pos >> PAGE_CACHE_SHIFT;
@@ -137,7 +137,7 @@ struct sysv_dir_entry *sysv_find_entry(s
 {
 	const char * name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
-	struct inode * dir = dentry->d_parent->d_inode;
+	struct inode * dir = d_inode(dentry->d_parent);
 	unsigned long start, n;
 	unsigned long npages = dir_pages(dir);
 	struct page *page = NULL;
@@ -181,7 +181,7 @@ found:
 
 int sysv_add_link(struct dentry *dentry, struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	const char * name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
 	struct page *page = NULL;
diff -u -p a/ext3/super.c b/ext3/super.c
--- a/ext3/super.c
+++ b/ext3/super.c
@@ -2863,7 +2863,7 @@ static int ext3_write_info(struct super_
 	handle_t *handle;
 
 	/* Data block + inode block */
-	handle = ext3_journal_start(sb->s_root->d_inode, 2);
+	handle = ext3_journal_start(d_inode(sb->s_root), 2);
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
 	ret = dquot_commit_info(sb, type);
@@ -2910,7 +2910,7 @@ static int ext3_quota_on(struct super_bl
 	 * When we journal data on quota file, we have to flush journal to see
 	 * all updates to the file when we bypass pagecache...
 	 */
-	if (ext3_should_journal_data(path->dentry->d_inode)) {
+	if (ext3_should_journal_data(d_inode(path->dentry))) {
 		/*
 		 * We don't need to lock updates but journal_flush() could
 		 * otherwise be livelocked...
diff -u -p a/ext3/symlink.c b/ext3/symlink.c
--- a/ext3/symlink.c
+++ b/ext3/symlink.c
@@ -25,7 +25,7 @@
 
 static void * ext3_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct ext3_inode_info *ei = EXT3_I(dentry->d_inode);
+	struct ext3_inode_info *ei = EXT3_I(d_inode(dentry));
 	nd_set_link(nd, (char*)ei->i_data);
 	return NULL;
 }
diff -u -p a/ext3/xattr_user.c b/ext3/xattr_user.c
--- a/ext3/xattr_user.c
+++ b/ext3/xattr_user.c
@@ -38,7 +38,7 @@ ext3_xattr_user_get(struct dentry *dentr
 		return -EINVAL;
 	if (!test_opt(dentry->d_sb, XATTR_USER))
 		return -EOPNOTSUPP;
-	return ext3_xattr_get(dentry->d_inode, EXT3_XATTR_INDEX_USER,
+	return ext3_xattr_get(d_inode(dentry), EXT3_XATTR_INDEX_USER,
 			      name, buffer, size);
 }
 
@@ -50,7 +50,7 @@ ext3_xattr_user_set(struct dentry *dentr
 		return -EINVAL;
 	if (!test_opt(dentry->d_sb, XATTR_USER))
 		return -EOPNOTSUPP;
-	return ext3_xattr_set(dentry->d_inode, EXT3_XATTR_INDEX_USER,
+	return ext3_xattr_set(d_inode(dentry), EXT3_XATTR_INDEX_USER,
 			      name, value, size, flags);
 }
 
diff -u -p a/ext3/inode.c b/ext3/inode.c
--- a/ext3/inode.c
+++ b/ext3/inode.c
@@ -3179,7 +3179,7 @@ int ext3_write_inode(struct inode *inode
  */
 int ext3_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error, rc = 0;
 	const unsigned int ia_valid = attr->ia_valid;
 
diff -u -p a/ext3/namei.c b/ext3/namei.c
--- a/ext3/namei.c
+++ b/ext3/namei.c
@@ -631,7 +631,7 @@ int ext3_htree_fill_tree(struct file *di
 
 	dxtrace(printk("In htree_fill_tree, start hash: %x:%x\n", start_hash,
 		       start_minor_hash));
-	dir = dir_file->f_path.dentry->d_inode;
+	dir = d_inode(dir_file->f_path.dentry);
 	if (!(EXT3_I(dir)->i_flags & EXT3_INDEX_FL)) {
 		hinfo.hash_version = EXT3_SB(dir->i_sb)->s_def_hash_version;
 		if (hinfo.hash_version <= DX_HASH_TEA)
@@ -645,7 +645,8 @@ int ext3_htree_fill_tree(struct file *di
 	}
 	hinfo.hash = start_hash;
 	hinfo.minor_hash = 0;
-	frame = dx_probe(NULL, dir_file->f_path.dentry->d_inode, &hinfo, frames, &err);
+	frame = dx_probe(NULL, d_inode(dir_file->f_path.dentry), &hinfo,
+			 frames, &err);
 	if (!frame)
 		return err;
 
@@ -1060,19 +1061,19 @@ struct dentry *ext3_get_parent(struct de
 	struct ext3_dir_entry_2 * de;
 	struct buffer_head *bh;
 
-	bh = ext3_find_entry(child->d_inode, &dotdot, &de);
+	bh = ext3_find_entry(d_inode(child), &dotdot, &de);
 	if (!bh)
 		return ERR_PTR(-ENOENT);
 	ino = le32_to_cpu(de->inode);
 	brelse(bh);
 
-	if (!ext3_valid_inum(child->d_inode->i_sb, ino)) {
-		ext3_error(child->d_inode->i_sb, "ext3_get_parent",
+	if (!ext3_valid_inum(d_inode(child)->i_sb, ino)) {
+		ext3_error(d_inode(child)->i_sb, "ext3_get_parent",
 			   "bad inode number: %lu", ino);
 		return ERR_PTR(-EIO);
 	}
 
-	return d_obtain_alias(ext3_iget(child->d_inode->i_sb, ino));
+	return d_obtain_alias(ext3_iget(d_inode(child)->i_sb, ino));
 }
 
 #define S_SHIFT 12
@@ -1254,7 +1255,7 @@ static int add_dirent_to_buf(handle_t *h
 			     struct inode *inode, struct ext3_dir_entry_2 *de,
 			     struct buffer_head * bh)
 {
-	struct inode	*dir = dentry->d_parent->d_inode;
+	struct inode	*dir = d_inode(dentry->d_parent);
 	const char	*name = dentry->d_name.name;
 	int		namelen = dentry->d_name.len;
 	unsigned long	offset = 0;
@@ -1341,7 +1342,7 @@ static int add_dirent_to_buf(handle_t *h
 static int make_indexed_dir(handle_t *handle, struct dentry *dentry,
 			    struct inode *inode, struct buffer_head *bh)
 {
-	struct inode	*dir = dentry->d_parent->d_inode;
+	struct inode	*dir = d_inode(dentry->d_parent);
 	const char	*name = dentry->d_name.name;
 	int		namelen = dentry->d_name.len;
 	struct buffer_head *bh2;
@@ -1446,7 +1447,7 @@ static int make_indexed_dir(handle_t *ha
 static int ext3_add_entry (handle_t *handle, struct dentry *dentry,
 	struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	struct buffer_head * bh;
 	struct ext3_dir_entry_2 *de;
 	struct super_block * sb;
@@ -1500,7 +1501,7 @@ static int ext3_dx_add_entry(handle_t *h
 	struct dx_entry *entries, *at;
 	struct dx_hash_info hinfo;
 	struct buffer_head * bh;
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	struct super_block * sb = dir->i_sb;
 	struct ext3_dir_entry_2 *de;
 	int err;
@@ -2086,7 +2087,7 @@ static int ext3_rmdir (struct inode * di
 	/* Initialize quotas before so that eventual writes go in
 	 * separate transaction */
 	dquot_initialize(dir);
-	dquot_initialize(dentry->d_inode);
+	dquot_initialize(d_inode(dentry));
 
 	handle = ext3_journal_start(dir, EXT3_DELETE_TRANS_BLOCKS(dir->i_sb));
 	if (IS_ERR(handle))
@@ -2100,7 +2101,7 @@ static int ext3_rmdir (struct inode * di
 	if (IS_DIRSYNC(dir))
 		handle->h_sync = 1;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	retval = -EIO;
 	if (le32_to_cpu(de->inode) != inode->i_ino)
@@ -2147,7 +2148,7 @@ static int ext3_unlink(struct inode * di
 	/* Initialize quotas before so that eventual writes go
 	 * in separate transaction */
 	dquot_initialize(dir);
-	dquot_initialize(dentry->d_inode);
+	dquot_initialize(d_inode(dentry));
 
 	handle = ext3_journal_start(dir, EXT3_DELETE_TRANS_BLOCKS(dir->i_sb));
 	if (IS_ERR(handle))
@@ -2161,7 +2162,7 @@ static int ext3_unlink(struct inode * di
 	if (!bh)
 		goto end_unlink;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	retval = -EIO;
 	if (le32_to_cpu(de->inode) != inode->i_ino)
@@ -2299,7 +2300,7 @@ static int ext3_link (struct dentry * ol
 		struct inode * dir, struct dentry *dentry)
 {
 	handle_t *handle;
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	int err, retries = 0;
 
 	if (inode->i_nlink >= EXT3_LINK_MAX)
@@ -2357,8 +2358,8 @@ static int ext3_rename (struct inode * o
 
 	/* Initialize quotas before so that eventual writes go
 	 * in separate transaction */
-	if (new_dentry->d_inode)
-		dquot_initialize(new_dentry->d_inode);
+	if (d_inode(new_dentry))
+		dquot_initialize(d_inode(new_dentry));
 	handle = ext3_journal_start(old_dir, 2 *
 					EXT3_DATA_TRANS_BLOCKS(old_dir->i_sb) +
 					EXT3_INDEX_EXTRA_TRANS_BLOCKS + 2);
@@ -2375,12 +2376,12 @@ static int ext3_rename (struct inode * o
 	 *  and merrily kill the link to whatever was created under the
 	 *  same name. Goodbye sticky bit ;-<
 	 */
-	old_inode = old_dentry->d_inode;
+	old_inode = d_inode(old_dentry);
 	retval = -ENOENT;
 	if (!old_bh || le32_to_cpu(old_de->inode) != old_inode->i_ino)
 		goto end_rename;
 
-	new_inode = new_dentry->d_inode;
+	new_inode = d_inode(new_dentry);
 	new_bh = ext3_find_entry(new_dir, &new_dentry->d_name, &new_de);
 	if (new_bh) {
 		if (!new_inode) {
diff -u -p a/ext3/ialloc.c b/ext3/ialloc.c
--- a/ext3/ialloc.c
+++ b/ext3/ialloc.c
@@ -261,7 +261,7 @@ static int find_group_orlov(struct super
 	avefreeb = freeb / ngroups;
 	ndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);
 
-	if ((parent == sb->s_root->d_inode) ||
+	if ((parent == d_inode(sb->s_root)) ||
 	    (EXT3_I(parent)->i_flags & EXT3_TOPDIR_FL)) {
 		int best_ndir = inodes_per_group;
 		int best_group = -1;
diff -u -p a/ext3/dir.c b/ext3/dir.c
--- a/ext3/dir.c
+++ b/ext3/dir.c
@@ -101,7 +101,7 @@ static int ext3_readdir(struct file * fi
 	struct ext3_dir_entry_2 *de;
 	struct super_block *sb;
 	int err;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	int ret = 0;
 	int dir_has_error = 0;
 
@@ -120,7 +120,7 @@ static int ext3_readdir(struct file * fi
 		 * We don't set the inode dirty flag since it's not
 		 * critical that it get flushed back to the disk.
 		 */
-		EXT3_I(filp->f_path.dentry->d_inode)->i_flags &= ~EXT3_INDEX_FL;
+		EXT3_I(d_inode(filp->f_path.dentry))->i_flags &= ~EXT3_INDEX_FL;
 	}
 	stored = 0;
 	offset = filp->f_pos & (sb->s_blocksize - 1);
@@ -396,7 +396,7 @@ static int call_filldir(struct file * fi
 {
 	struct dir_private_info *info = filp->private_data;
 	loff_t	curr_pos;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct super_block * sb;
 	int error;
 
@@ -426,7 +426,7 @@ static int ext3_dx_readdir(struct file *
 			 void * dirent, filldir_t filldir)
 {
 	struct dir_private_info *info = filp->private_data;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct fname *fname;
 	int	ret;
 
diff -u -p a/ext3/ioctl.c b/ext3/ioctl.c
--- a/ext3/ioctl.c
+++ b/ext3/ioctl.c
@@ -19,7 +19,7 @@
 
 long ext3_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = filp->f_dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_dentry);
 	struct ext3_inode_info *ei = EXT3_I(inode);
 	unsigned int flags;
 	unsigned short rsv_window_size;
diff -u -p a/ext3/xattr_trusted.c b/ext3/xattr_trusted.c
--- a/ext3/xattr_trusted.c
+++ b/ext3/xattr_trusted.c
@@ -37,7 +37,7 @@ ext3_xattr_trusted_get(struct dentry *de
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext3_xattr_get(dentry->d_inode, EXT3_XATTR_INDEX_TRUSTED,
+	return ext3_xattr_get(d_inode(dentry), EXT3_XATTR_INDEX_TRUSTED,
 			      name, buffer, size);
 }
 
@@ -47,7 +47,7 @@ ext3_xattr_trusted_set(struct dentry *de
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext3_xattr_set(dentry->d_inode, EXT3_XATTR_INDEX_TRUSTED, name,
+	return ext3_xattr_set(d_inode(dentry), EXT3_XATTR_INDEX_TRUSTED, name,
 			      value, size, flags);
 }
 
diff -u -p a/ext3/acl.c b/ext3/acl.c
--- a/ext3/acl.c
+++ b/ext3/acl.c
@@ -411,7 +411,7 @@ ext3_xattr_get_acl(struct dentry *dentry
 	if (!test_opt(dentry->d_sb, POSIX_ACL))
 		return -EOPNOTSUPP;
 
-	acl = ext3_get_acl(dentry->d_inode, type);
+	acl = ext3_get_acl(d_inode(dentry), type);
 	if (IS_ERR(acl))
 		return PTR_ERR(acl);
 	if (acl == NULL)
@@ -426,7 +426,7 @@ static int
 ext3_xattr_set_acl(struct dentry *dentry, const char *name, const void *value,
 		   size_t size, int flags, int type)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	handle_t *handle;
 	struct posix_acl *acl;
 	int error, retries = 0;
diff -u -p a/ext3/xattr.c b/ext3/xattr.c
--- a/ext3/xattr.c
+++ b/ext3/xattr.c
@@ -360,7 +360,7 @@ ext3_xattr_list_entries(struct dentry *d
 static int
 ext3_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct buffer_head *bh = NULL;
 	int error;
 
@@ -396,7 +396,7 @@ cleanup:
 static int
 ext3_xattr_ibody_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ext3_xattr_ibody_header *header;
 	struct ext3_inode *raw_inode;
 	struct ext3_iloc iloc;
@@ -437,7 +437,7 @@ ext3_xattr_list(struct dentry *dentry, c
 {
 	int i_error, b_error;
 
-	down_read(&EXT3_I(dentry->d_inode)->xattr_sem);
+	down_read(&EXT3_I(d_inode(dentry))->xattr_sem);
 	i_error = ext3_xattr_ibody_list(dentry, buffer, buffer_size);
 	if (i_error < 0) {
 		b_error = 0;
@@ -450,7 +450,7 @@ ext3_xattr_list(struct dentry *dentry, c
 		if (b_error < 0)
 			i_error = 0;
 	}
-	up_read(&EXT3_I(dentry->d_inode)->xattr_sem);
+	up_read(&EXT3_I(d_inode(dentry))->xattr_sem);
 	return i_error + b_error;
 }
 
diff -u -p a/ext3/xattr_security.c b/ext3/xattr_security.c
--- a/ext3/xattr_security.c
+++ b/ext3/xattr_security.c
@@ -34,7 +34,7 @@ ext3_xattr_security_get(struct dentry *d
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext3_xattr_get(dentry->d_inode, EXT3_XATTR_INDEX_SECURITY,
+	return ext3_xattr_get(d_inode(dentry), EXT3_XATTR_INDEX_SECURITY,
 			      name, buffer, size);
 }
 
@@ -44,7 +44,7 @@ ext3_xattr_security_set(struct dentry *d
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext3_xattr_set(dentry->d_inode, EXT3_XATTR_INDEX_SECURITY,
+	return ext3_xattr_set(d_inode(dentry), EXT3_XATTR_INDEX_SECURITY,
 			      name, value, size, flags);
 }
 
diff -u -p a/cifs/misc.c b/cifs/misc.c
--- a/cifs/misc.c
+++ b/cifs/misc.c
@@ -581,7 +581,7 @@ is_valid_oplock_break(struct smb_hdr *bu
 					continue;
 
 				cFYI(1, "file id match, oplock break");
-				pCifsInode = CIFS_I(netfile->dentry->d_inode);
+				pCifsInode = CIFS_I(d_inode(netfile->dentry));
 
 				cifs_set_oplock_level(pCifsInode,
 					pSMB->OplockLevel ? OPLOCK_READ : 0);
diff -u -p a/cifs/cifs_dfs_ref.c b/cifs/cifs_dfs_ref.c
--- a/cifs/cifs_dfs_ref.c
+++ b/cifs/cifs_dfs_ref.c
@@ -293,7 +293,7 @@ static struct vfsmount *cifs_dfs_do_auto
 	if (full_path == NULL)
 		goto cdda_exit;
 
-	cifs_sb = CIFS_SB(mntpt->d_inode->i_sb);
+	cifs_sb = CIFS_SB(d_inode(mntpt)->i_sb);
 	tlink = cifs_sb_tlink(cifs_sb);
 	if (IS_ERR(tlink)) {
 		mnt = ERR_CAST(tlink);
diff -u -p a/cifs/readdir.c b/cifs/readdir.c
--- a/cifs/readdir.c
+++ b/cifs/readdir.c
@@ -74,19 +74,19 @@ cifs_readdir_lookup(struct dentry *paren
 {
 	struct dentry *dentry, *alias;
 	struct inode *inode;
-	struct super_block *sb = parent->d_inode->i_sb;
+	struct super_block *sb = d_inode(parent)->i_sb;
 
 	cFYI(1, "For %s", name->name);
 
 	if (parent->d_op && parent->d_op->d_hash)
-		parent->d_op->d_hash(parent, parent->d_inode, name);
+		parent->d_op->d_hash(parent, d_inode(parent), name);
 	else
 		name->hash = full_name_hash(name->name, name->len);
 
 	dentry = d_lookup(parent, name);
 	if (dentry) {
 		/* FIXME: check for inode number changes? */
-		if (dentry->d_inode != NULL)
+		if (d_inode(dentry) != NULL)
 			return dentry;
 		d_drop(dentry);
 		dput(dentry);
@@ -416,7 +416,7 @@ static int cifs_entry_is_dot(char *curre
    whether we can use the cached search results from the previous search */
 static int is_dir_changed(struct file *file)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct cifsInodeInfo *cifsInfo = CIFS_I(inode);
 
 	if (cifsInfo->time == 0)
@@ -788,7 +788,7 @@ int cifs_readdir(struct file *file, void
 	switch ((int) file->f_pos) {
 	case 0:
 		if (filldir(direntry, ".", 1, file->f_pos,
-		     file->f_path.dentry->d_inode->i_ino, DT_DIR) < 0) {
+		     d_inode(file->f_path.dentry)->i_ino, DT_DIR) < 0) {
 			cERROR(1, "Filldir for current dir failed");
 			rc = -ENOMEM;
 			break;
@@ -796,7 +796,7 @@ int cifs_readdir(struct file *file, void
 		file->f_pos++;
 	case 1:
 		if (filldir(direntry, "..", 2, file->f_pos,
-		     file->f_path.dentry->d_parent->d_inode->i_ino, DT_DIR) < 0) {
+		     d_inode(file->f_path.dentry->d_parent)->i_ino, DT_DIR) < 0) {
 			cERROR(1, "Filldir for parent dir failed");
 			rc = -ENOMEM;
 			break;
diff -u -p a/cifs/cifsfs.c b/cifs/cifsfs.c
--- a/cifs/cifsfs.c
+++ b/cifs/cifsfs.c
@@ -563,7 +563,7 @@ cifs_get_root(struct smb_vol *vol, struc
 	p = s = full_path;
 
 	do {
-		struct inode *dir = dentry->d_inode;
+		struct inode *dir = d_inode(dentry);
 		struct dentry *child;
 
 		/* skip separators */
@@ -686,7 +686,7 @@ out_nls:
 static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 				   unsigned long nr_segs, loff_t pos)
 {
-	struct inode *inode = iocb->ki_filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(iocb->ki_filp->f_path.dentry);
 	ssize_t written;
 	int rc;
 
@@ -707,7 +707,7 @@ static loff_t cifs_llseek(struct file *f
 	/* origin == SEEK_END => we must revalidate the cached file length */
 	if (origin == SEEK_END) {
 		int rc;
-		struct inode *inode = file->f_path.dentry->d_inode;
+		struct inode *inode = d_inode(file->f_path.dentry);
 
 		/*
 		 * We need to be sure that all dirty pages are written and the
@@ -739,7 +739,7 @@ static int cifs_setlease(struct file *fi
 {
 	/* note that this is called by vfs setlease with lock_flocks held
 	   to protect *lease from going away */
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct cifsFileInfo *cfile = file->private_data;
 
 	if (!(S_ISREG(inode->i_mode)))
diff -u -p a/cifs/inode.c b/cifs/inode.c
--- a/cifs/inode.c
+++ b/cifs/inode.c
@@ -292,7 +292,7 @@ int cifs_get_file_info_unix(struct file
 	int xid;
 	FILE_UNIX_BASIC_INFO find_data;
 	struct cifs_fattr fattr;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
 	struct cifsFileInfo *cfile = filp->private_data;
 	struct cifs_tcon *tcon = tlink_tcon(cfile->tlink);
@@ -555,7 +555,7 @@ int cifs_get_file_info(struct file *filp
 	int xid;
 	FILE_ALL_INFO find_data;
 	struct cifs_fattr fattr;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
 	struct cifsFileInfo *cfile = filp->private_data;
 	struct cifs_tcon *tcon = tlink_tcon(cfile->tlink);
@@ -1055,7 +1055,7 @@ cifs_rename_pending_delete(char *full_pa
 	int oplock = 0;
 	int rc;
 	__u16 netfid;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct cifsInodeInfo *cifsInode = CIFS_I(inode);
 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
 	struct tcon_link *tlink;
@@ -1172,7 +1172,7 @@ int cifs_unlink(struct inode *dir, struc
 	int rc = 0;
 	int xid;
 	char *full_path = NULL;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct cifsInodeInfo *cifs_inode;
 	struct super_block *sb = dir->i_sb;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
@@ -1371,8 +1371,8 @@ mkdir_get_info:
 		d_instantiate(direntry, newinode);
 		 /* setting nlink not necessary except in cases where we
 		  * failed to get it from the server or was set bogus */
-		if ((direntry->d_inode) && (direntry->d_inode->i_nlink < 2))
-				direntry->d_inode->i_nlink = 2;
+		if ((d_inode(direntry)) && (d_inode(direntry)->i_nlink < 2))
+				d_inode(direntry)->i_nlink = 2;
 
 		mode &= ~current_umask();
 		/* must turn on setgid bit if parent dir has it */
@@ -1420,22 +1420,22 @@ mkdir_get_info:
 				if (tmprc == 0)
 					cifsInode->cifsAttrs = dosattrs;
 			}
-			if (direntry->d_inode) {
+			if (d_inode(direntry)) {
 				if (cifs_sb->mnt_cifs_flags &
 				     CIFS_MOUNT_DYNPERM)
-					direntry->d_inode->i_mode =
-						(mode | S_IFDIR);
+					d_inode(direntry)->i_mode =
+							(mode | S_IFDIR);
 
 				if (cifs_sb->mnt_cifs_flags &
 				     CIFS_MOUNT_SET_UID) {
-					direntry->d_inode->i_uid =
-						current_fsuid();
+					d_inode(direntry)->i_uid =
+							current_fsuid();
 					if (inode->i_mode & S_ISGID)
-						direntry->d_inode->i_gid =
-							inode->i_gid;
-					else
-						direntry->d_inode->i_gid =
-							current_fsgid();
+						d_inode(direntry)->i_gid =
+								inode->i_gid;
+						else
+							d_inode(direntry)->i_gid =
+									current_fsgid();
 				}
 			}
 		}
@@ -1481,13 +1481,13 @@ int cifs_rmdir(struct inode *inode, stru
 
 	if (!rc) {
 		drop_nlink(inode);
-		spin_lock(&direntry->d_inode->i_lock);
-		i_size_write(direntry->d_inode, 0);
-		clear_nlink(direntry->d_inode);
-		spin_unlock(&direntry->d_inode->i_lock);
+		spin_lock(&d_inode(direntry)->i_lock);
+		i_size_write(d_inode(direntry), 0);
+		clear_nlink(d_inode(direntry));
+		spin_unlock(&d_inode(direntry)->i_lock);
 	}
 
-	cifsInode = CIFS_I(direntry->d_inode);
+	cifsInode = CIFS_I(d_inode(direntry));
 	cifsInode->time = 0;	/* force revalidate to go get info when
 				   needed */
 
@@ -1495,8 +1495,8 @@ int cifs_rmdir(struct inode *inode, stru
 	cifsInode->time = 0;	/* force revalidate to get parent dir info
 				   since cached search results now invalid */
 
-	direntry->d_inode->i_ctime = inode->i_ctime = inode->i_mtime =
-		current_fs_time(inode->i_sb);
+	d_inode(direntry)->i_ctime = inode->i_ctime = inode->i_mtime =
+			current_fs_time(inode->i_sb);
 
 rmdir_exit:
 	kfree(full_path);
@@ -1633,7 +1633,7 @@ int cifs_rename(struct inode *source_dir
 
 unlink_target:
 	/* Try unlinking the target dentry if it's not negative */
-	if (target_dentry->d_inode && (rc == -EACCES || rc == -EEXIST)) {
+	if (d_inode(target_dentry) && (rc == -EACCES || rc == -EEXIST)) {
 		tmprc = cifs_unlink(target_dir, target_dentry);
 		if (tmprc)
 			goto cifs_rename_exit;
@@ -1705,7 +1705,7 @@ cifs_invalidate_mapping(struct inode *in
 int cifs_revalidate_file_attr(struct file *filp)
 {
 	int rc = 0;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct cifsFileInfo *cfile = (struct cifsFileInfo *) filp->private_data;
 
 	if (!cifs_inode_needs_reval(inode))
@@ -1723,7 +1723,7 @@ int cifs_revalidate_dentry_attr(struct d
 {
 	int xid;
 	int rc = 0;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct super_block *sb = dentry->d_sb;
 	char *full_path = NULL;
 
@@ -1762,7 +1762,7 @@ out:
 int cifs_revalidate_file(struct file *filp)
 {
 	int rc;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 
 	rc = cifs_revalidate_file_attr(filp);
 	if (rc)
@@ -1777,7 +1777,7 @@ int cifs_revalidate_file(struct file *fi
 int cifs_revalidate_dentry(struct dentry *dentry)
 {
 	int rc;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	rc = cifs_revalidate_dentry_attr(dentry);
 	if (rc)
@@ -1793,7 +1793,7 @@ int cifs_getattr(struct vfsmount *mnt, s
 {
 	struct cifs_sb_info *cifs_sb = CIFS_SB(dentry->d_sb);
 	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int rc;
 
 	/*
@@ -1967,7 +1967,7 @@ cifs_setattr_unix(struct dentry *direntr
 	int rc;
 	int xid;
 	char *full_path = NULL;
-	struct inode *inode = direntry->d_inode;
+	struct inode *inode = d_inode(direntry);
 	struct cifsInodeInfo *cifsInode = CIFS_I(inode);
 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
 	struct tcon_link *tlink;
@@ -2106,7 +2106,7 @@ static int
 cifs_setattr_nounix(struct dentry *direntry, struct iattr *attrs)
 {
 	int xid;
-	struct inode *inode = direntry->d_inode;
+	struct inode *inode = d_inode(direntry);
 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
 	struct cifsInodeInfo *cifsInode = CIFS_I(inode);
 	char *full_path = NULL;
@@ -2255,7 +2255,7 @@ cifs_setattr_exit:
 int
 cifs_setattr(struct dentry *direntry, struct iattr *attrs)
 {
-	struct inode *inode = direntry->d_inode;
+	struct inode *inode = d_inode(direntry);
 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
 	struct cifs_tcon *pTcon = cifs_sb_master_tcon(cifs_sb);
 
diff -u -p a/cifs/file.c b/cifs/file.c
--- a/cifs/file.c
+++ b/cifs/file.c
@@ -241,7 +241,7 @@ cifs_new_fileinfo(__u16 fileHandle, stru
 		  struct tcon_link *tlink, __u32 oplock)
 {
 	struct dentry *dentry = file->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct cifsInodeInfo *pCifsInode = CIFS_I(inode);
 	struct cifsFileInfo *pCifsFile;
 
@@ -284,7 +284,7 @@ cifs_new_fileinfo(__u16 fileHandle, stru
  */
 void cifsFileInfo_put(struct cifsFileInfo *cifs_file)
 {
-	struct inode *inode = cifs_file->dentry->d_inode;
+	struct inode *inode = d_inode(cifs_file->dentry);
 	struct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);
 	struct cifsInodeInfo *cifsi = CIFS_I(inode);
 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
@@ -302,7 +302,7 @@ void cifsFileInfo_put(struct cifsFileInf
 
 	if (list_empty(&cifsi->openFileList)) {
 		cFYI(1, "closing last open instance for inode %p",
-			cifs_file->dentry->d_inode);
+			d_inode(cifs_file->dentry));
 
 		/* in strict cache mode we need invalidate mapping on the last
 		   close  because it may cause a error when we open this file
@@ -474,7 +474,7 @@ static int cifs_reopen_file(struct cifsF
 		return rc;
 	}
 
-	inode = pCifsFile->dentry->d_inode;
+	inode = d_inode(pCifsFile->dentry);
 	cifs_sb = CIFS_SB(inode->i_sb);
 	tcon = tlink_tcon(pCifsFile->tlink);
 
@@ -868,7 +868,7 @@ static ssize_t cifs_write(struct cifsFil
 	struct cifs_tcon *pTcon;
 	int xid;
 	struct dentry *dentry = open_file->dentry;
-	struct cifsInodeInfo *cifsi = CIFS_I(dentry->d_inode);
+	struct cifsInodeInfo *cifsi = CIFS_I(d_inode(dentry));
 	struct cifs_io_parms io_parms;
 
 	cifs_sb = CIFS_SB(dentry->d_sb);
@@ -926,12 +926,12 @@ static ssize_t cifs_write(struct cifsFil
 	cifs_stats_bytes_written(pTcon, total_written);
 
 	if (total_written > 0) {
-		spin_lock(&dentry->d_inode->i_lock);
-		if (*poffset > dentry->d_inode->i_size)
-			i_size_write(dentry->d_inode, *poffset);
-		spin_unlock(&dentry->d_inode->i_lock);
+		spin_lock(&d_inode(dentry)->i_lock);
+		if (*poffset > d_inode(dentry)->i_size)
+			i_size_write(d_inode(dentry), *poffset);
+		spin_unlock(&d_inode(dentry)->i_lock);
 	}
-	mark_inode_dirty_sync(dentry->d_inode);
+	mark_inode_dirty_sync(d_inode(dentry));
 	FreeXid(xid);
 	return total_written;
 }
@@ -1407,7 +1407,7 @@ int cifs_strict_fsync(struct file *file,
 	int rc = 0;
 	struct cifs_tcon *tcon;
 	struct cifsFileInfo *smbfile = file->private_data;
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
 
 	xid = GetXid();
@@ -1458,7 +1458,7 @@ int cifs_fsync(struct file *file, int da
  */
 int cifs_flush(struct file *file, fl_owner_t id)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	int rc = 0;
 
 	if (file->f_mode & FMODE_WRITE)
@@ -1569,7 +1569,7 @@ cifs_iovec_write(struct file *file, cons
 		pid = current->tgid;
 
 	pTcon = tlink_tcon(open_file->tlink);
-	inode = file->f_path.dentry->d_inode;
+	inode = d_inode(file->f_path.dentry);
 
 	iov_iter_init(&it, iov, nr_segs, len, 0);
 	npages = num_pages;
@@ -1645,7 +1645,7 @@ ssize_t cifs_user_writev(struct kiocb *i
 	ssize_t written;
 	struct inode *inode;
 
-	inode = iocb->ki_filp->f_path.dentry->d_inode;
+	inode = d_inode(iocb->ki_filp->f_path.dentry);
 
 	/*
 	 * BB - optimize the way when signing is disabled. We can drop this
@@ -1667,7 +1667,7 @@ ssize_t cifs_strict_writev(struct kiocb
 {
 	struct inode *inode;
 
-	inode = iocb->ki_filp->f_path.dentry->d_inode;
+	inode = d_inode(iocb->ki_filp->f_path.dentry);
 
 	if (CIFS_I(inode)->clientCanCacheAll)
 		return generic_file_aio_write(iocb, iov, nr_segs, pos);
@@ -1790,7 +1790,7 @@ ssize_t cifs_strict_readv(struct kiocb *
 {
 	struct inode *inode;
 
-	inode = iocb->ki_filp->f_path.dentry->d_inode;
+	inode = d_inode(iocb->ki_filp->f_path.dentry);
 
 	if (CIFS_I(inode)->clientCanCacheRead)
 		return generic_file_aio_read(iocb, iov, nr_segs, pos);
@@ -1906,7 +1906,7 @@ static struct vm_operations_struct cifs_
 int cifs_file_strict_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	int rc, xid;
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 
 	xid = GetXid();
 
@@ -2154,7 +2154,7 @@ static int cifs_readpage_worker(struct f
 	int rc;
 
 	/* Is the page cached? */
-	rc = cifs_readpage_from_fscache(file->f_path.dentry->d_inode, page);
+	rc = cifs_readpage_from_fscache(d_inode(file->f_path.dentry), page);
 	if (rc == 0)
 		goto read_complete;
 
@@ -2169,8 +2169,8 @@ static int cifs_readpage_worker(struct f
 	else
 		cFYI(1, "Bytes read %d", rc);
 
-	file->f_path.dentry->d_inode->i_atime =
-		current_fs_time(file->f_path.dentry->d_inode->i_sb);
+	d_inode(file->f_path.dentry)->i_atime =
+			current_fs_time(d_inode(file->f_path.dentry)->i_sb);
 
 	if (PAGE_CACHE_SIZE > rc)
 		memset(read_data + rc, 0, PAGE_CACHE_SIZE - rc);
@@ -2179,7 +2179,7 @@ static int cifs_readpage_worker(struct f
 	SetPageUptodate(page);
 
 	/* send this page to the cache */
-	cifs_readpage_to_fscache(file->f_path.dentry->d_inode, page);
+	cifs_readpage_to_fscache(d_inode(file->f_path.dentry), page);
 
 	rc = 0;
 
@@ -2374,7 +2374,7 @@ void cifs_oplock_break(struct work_struc
 {
 	struct cifsFileInfo *cfile = container_of(work, struct cifsFileInfo,
 						  oplock_break);
-	struct inode *inode = cfile->dentry->d_inode;
+	struct inode *inode = d_inode(cfile->dentry);
 	struct cifsInodeInfo *cinode = CIFS_I(inode);
 	int rc = 0;
 
diff -u -p a/cifs/link.c b/cifs/link.c
--- a/cifs/link.c
+++ b/cifs/link.c
@@ -415,10 +415,10 @@ cifs_hardlink(struct dentry *old_file, s
 
 	/* if source file is cached (oplocked) revalidate will not go to server
 	   until the file is closed or oplock broken so update nlinks locally */
-	if (old_file->d_inode) {
-		cifsInode = CIFS_I(old_file->d_inode);
+	if (d_inode(old_file)) {
+		cifsInode = CIFS_I(d_inode(old_file));
 		if (rc == 0) {
-			old_file->d_inode->i_nlink++;
+			d_inode(old_file)->i_nlink++;
 /* BB should we make this contingent on superblock flag NOATIME? */
 /*			old_file->d_inode->i_ctime = CURRENT_TIME;*/
 			/* parent dir timestamps will update from srv
@@ -448,7 +448,7 @@ cifs_hl_exit:
 void *
 cifs_follow_link(struct dentry *direntry, struct nameidata *nd)
 {
-	struct inode *inode = direntry->d_inode;
+	struct inode *inode = d_inode(direntry);
 	int rc = -ENOMEM;
 	int xid;
 	char *full_path = NULL;
diff -u -p a/cifs/dir.c b/cifs/dir.c
--- a/cifs/dir.c
+++ b/cifs/dir.c
@@ -550,12 +550,12 @@ cifs_lookup(struct inode *parent_dir_ino
 		goto lookup_out;
 	}
 
-	if (direntry->d_inode != NULL) {
+	if (d_inode(direntry) != NULL) {
 		cFYI(1, "non-NULL inode in lookup");
 	} else {
 		cFYI(1, "NULL inode in lookup");
 	}
-	cFYI(1, "Full path: %s inode = 0x%p", full_path, direntry->d_inode);
+	cFYI(1, "Full path: %s inode = 0x%p", full_path, d_inode(direntry));
 
 	/* Posix open is only called (at lookup time) for file create now.
 	 * For opens (rather than creates), because we do not know if it
@@ -644,7 +644,7 @@ cifs_d_revalidate(struct dentry *direntr
 	if (nd->flags & LOOKUP_RCU)
 		return -ECHILD;
 
-	if (direntry->d_inode) {
+	if (d_inode(direntry)) {
 		if (cifs_revalidate_dentry(direntry))
 			return 0;
 		else
diff -u -p a/cifs/cifssmb.c b/cifs/cifssmb.c
--- a/cifs/cifssmb.c
+++ b/cifs/cifssmb.c
@@ -1635,7 +1635,7 @@ static void
 cifs_writev_requeue(struct cifs_writedata *wdata)
 {
 	int i, rc;
-	struct inode *inode = wdata->cfile->dentry->d_inode;
+	struct inode *inode = d_inode(wdata->cfile->dentry);
 
 	for (i = 0; i < wdata->nr_pages; i++) {
 		lock_page(wdata->pages[i]);
@@ -1661,7 +1661,7 @@ cifs_writev_complete(struct work_struct
 {
 	struct cifs_writedata *wdata = container_of(work,
 						struct cifs_writedata, work);
-	struct inode *inode = wdata->cfile->dentry->d_inode;
+	struct inode *inode = d_inode(wdata->cfile->dentry);
 	int i = 0;
 
 	if (wdata->result == 0) {
@@ -1764,7 +1764,7 @@ cifs_async_writev(struct cifs_writedata
 	WRITE_REQ *smb = NULL;
 	int wct;
 	struct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);
-	struct inode *inode = wdata->cfile->dentry->d_inode;
+	struct inode *inode = d_inode(wdata->cfile->dentry);
 	struct kvec *iov = NULL;
 
 	if (tcon->ses->capabilities & CAP_LARGE_FILES) {
diff -u -p a/cifs/ioctl.c b/cifs/ioctl.c
--- a/cifs/ioctl.c
+++ b/cifs/ioctl.c
@@ -32,7 +32,7 @@
 
 long cifs_ioctl(struct file *filep, unsigned int command, unsigned long arg)
 {
-	struct inode *inode = filep->f_dentry->d_inode;
+	struct inode *inode = d_inode(filep->f_dentry);
 	int rc = -ENOTTY; /* strange error - but the precedent */
 	int xid;
 	struct cifs_sb_info *cifs_sb;
diff -u -p a/cifs/xattr.c b/cifs/xattr.c
--- a/cifs/xattr.c
+++ b/cifs/xattr.c
@@ -55,9 +55,9 @@ int cifs_removexattr(struct dentry *dire
 
 	if (direntry == NULL)
 		return -EIO;
-	if (direntry->d_inode == NULL)
+	if (d_inode(direntry) == NULL)
 		return -EIO;
-	sb = direntry->d_inode->i_sb;
+	sb = d_inode(direntry)->i_sb;
 	if (sb == NULL)
 		return -EIO;
 
@@ -116,9 +116,9 @@ int cifs_setxattr(struct dentry *direntr
 
 	if (direntry == NULL)
 		return -EIO;
-	if (direntry->d_inode == NULL)
+	if (d_inode(direntry) == NULL)
 		return -EIO;
-	sb = direntry->d_inode->i_sb;
+	sb = d_inode(direntry)->i_sb;
 	if (sb == NULL)
 		return -EIO;
 
@@ -178,9 +178,9 @@ int cifs_setxattr(struct dentry *direntr
 #ifdef CONFIG_CIFS_ACL
 			memcpy(pacl, ea_value, value_size);
 			rc = set_cifs_acl(pacl, value_size,
-				direntry->d_inode, full_path);
+				d_inode(direntry), full_path);
 			if (rc == 0) /* force revalidate of the inode */
-				CIFS_I(direntry->d_inode)->time = 0;
+				CIFS_I(d_inode(direntry))->time = 0;
 			kfree(pacl);
 #else
 			cFYI(1, "Set CIFS ACL not supported yet");
@@ -246,9 +246,9 @@ ssize_t cifs_getxattr(struct dentry *dir
 
 	if (direntry == NULL)
 		return -EIO;
-	if (direntry->d_inode == NULL)
+	if (d_inode(direntry) == NULL)
 		return -EIO;
-	sb = direntry->d_inode->i_sb;
+	sb = d_inode(direntry)->i_sb;
 	if (sb == NULL)
 		return -EIO;
 
@@ -319,7 +319,7 @@ ssize_t cifs_getxattr(struct dentry *dir
 			u32 acllen;
 			struct cifs_ntsd *pacl;
 
-			pacl = get_cifs_acl(cifs_sb, direntry->d_inode,
+			pacl = get_cifs_acl(cifs_sb, d_inode(direntry),
 						full_path, &acllen);
 			if (IS_ERR(pacl)) {
 				rc = PTR_ERR(pacl);
@@ -378,9 +378,9 @@ ssize_t cifs_listxattr(struct dentry *di
 
 	if (direntry == NULL)
 		return -EIO;
-	if (direntry->d_inode == NULL)
+	if (d_inode(direntry) == NULL)
 		return -EIO;
-	sb = direntry->d_inode->i_sb;
+	sb = d_inode(direntry)->i_sb;
 	if (sb == NULL)
 		return -EIO;
 
diff -u -p a/fuse/control.c b/fuse/control.c
--- a/fuse/control.c
+++ b/fuse/control.c
@@ -23,7 +23,7 @@ static struct fuse_conn *fuse_ctl_file_c
 {
 	struct fuse_conn *fc;
 	mutex_lock(&fuse_mutex);
-	fc = file->f_path.dentry->d_inode->i_private;
+	fc = d_inode(file->f_path.dentry)->i_private;
 	if (fc)
 		fc = fuse_conn_get(fc);
 	mutex_unlock(&fuse_mutex);
@@ -250,7 +250,7 @@ int fuse_ctl_add_conn(struct fuse_conn *
 		return 0;
 
 	parent = fuse_control_sb->s_root;
-	inc_nlink(parent->d_inode);
+	inc_nlink(d_inode(parent));
 	sprintf(name, "%u", fc->dev);
 	parent = fuse_ctl_add_dentry(parent, fc, name, S_IFDIR | 0500, 2,
 				     &simple_dir_inode_operations,
@@ -289,11 +289,11 @@ void fuse_ctl_remove_conn(struct fuse_co
 
 	for (i = fc->ctl_ndents - 1; i >= 0; i--) {
 		struct dentry *dentry = fc->ctl_dentry[i];
-		dentry->d_inode->i_private = NULL;
+		d_inode(dentry)->i_private = NULL;
 		d_drop(dentry);
 		dput(dentry);
 	}
-	drop_nlink(fuse_control_sb->s_root->d_inode);
+	drop_nlink(d_inode(fuse_control_sb->s_root));
 }
 
 static int fuse_ctl_fill_super(struct super_block *sb, void *data, int silent)
diff -u -p a/fuse/inode.c b/fuse/inode.c
--- a/fuse/inode.c
+++ b/fuse/inode.c
@@ -383,7 +383,7 @@ static int fuse_statfs(struct dentry *de
 	memset(&outarg, 0, sizeof(outarg));
 	req->in.numargs = 0;
 	req->in.h.opcode = FUSE_STATFS;
-	req->in.h.nodeid = get_node_id(dentry->d_inode);
+	req->in.h.nodeid = get_node_id(d_inode(dentry));
 	req->out.numargs = 1;
 	req->out.args[0].size =
 		fc->minor < 4 ? FUSE_COMPAT_STATFS_SIZE : sizeof(outarg);
@@ -631,7 +631,7 @@ static struct dentry *fuse_get_dentry(st
 static int fuse_encode_fh(struct dentry *dentry, u32 *fh, int *max_len,
 			   int connectable)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	bool encode_parent = connectable && !S_ISDIR(inode->i_mode);
 	int len = encode_parent ? 6 : 3;
 	u64 nodeid;
@@ -653,7 +653,7 @@ static int fuse_encode_fh(struct dentry
 		struct inode *parent;
 
 		spin_lock(&dentry->d_lock);
-		parent = dentry->d_parent->d_inode;
+		parent = d_inode(dentry->d_parent);
 		nodeid = get_fuse_inode(parent)->nodeid;
 		generation = parent->i_generation;
 		spin_unlock(&dentry->d_lock);
@@ -697,7 +697,7 @@ static struct dentry *fuse_fh_to_parent(
 
 static struct dentry *fuse_get_parent(struct dentry *child)
 {
-	struct inode *child_inode = child->d_inode;
+	struct inode *child_inode = d_inode(child);
 	struct fuse_conn *fc = get_fuse_conn(child_inode);
 	struct inode *inode;
 	struct dentry *parent;
diff -u -p a/fuse/file.c b/fuse/file.c
--- a/fuse/file.c
+++ b/fuse/file.c
@@ -94,7 +94,7 @@ static void fuse_release_async(struct wo
 
 	req = container_of(work, struct fuse_req, misc.release.work);
 	path = req->misc.release.path;
-	fc = get_fuse_conn(path.dentry->d_inode);
+	fc = get_fuse_conn(d_inode(path.dentry));
 
 	fuse_put_request(fc, req);
 	path_put(&path);
@@ -352,7 +352,7 @@ static int fuse_wait_on_page_writeback(s
 
 static int fuse_flush(struct file *file, fl_owner_t id)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_file *ff = file->private_data;
 	struct fuse_req *req;
@@ -1136,7 +1136,7 @@ static ssize_t fuse_direct_read(struct f
 				     size_t count, loff_t *ppos)
 {
 	ssize_t res;
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 
 	if (is_bad_inode(inode))
 		return -EIO;
@@ -1151,7 +1151,7 @@ static ssize_t fuse_direct_read(struct f
 static ssize_t fuse_direct_write(struct file *file, const char __user *buf,
 				 size_t count, loff_t *ppos)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	ssize_t res;
 
 	if (is_bad_inode(inode))
@@ -1383,7 +1383,7 @@ static const struct vm_operations_struct
 static int fuse_file_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	if ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE)) {
-		struct inode *inode = file->f_dentry->d_inode;
+		struct inode *inode = d_inode(file->f_dentry);
 		struct fuse_conn *fc = get_fuse_conn(inode);
 		struct fuse_inode *fi = get_fuse_inode(inode);
 		struct fuse_file *ff = file->private_data;
@@ -1441,7 +1441,7 @@ static void fuse_lk_fill(struct fuse_req
 			 const struct file_lock *fl, int opcode, pid_t pid,
 			 int flock)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_file *ff = file->private_data;
 	struct fuse_lk_in *arg = &req->misc.lk_in;
@@ -1463,7 +1463,7 @@ static void fuse_lk_fill(struct fuse_req
 
 static int fuse_getlk(struct file *file, struct file_lock *fl)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_req *req;
 	struct fuse_lk_out outarg;
@@ -1488,7 +1488,7 @@ static int fuse_getlk(struct file *file,
 
 static int fuse_setlk(struct file *file, struct file_lock *fl, int flock)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_req *req;
 	int opcode = (fl->fl_flags & FL_SLEEP) ? FUSE_SETLKW : FUSE_SETLK;
@@ -1520,7 +1520,7 @@ static int fuse_setlk(struct file *file,
 
 static int fuse_file_lock(struct file *file, int cmd, struct file_lock *fl)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	int err;
 
@@ -1543,7 +1543,7 @@ static int fuse_file_lock(struct file *f
 
 static int fuse_file_flock(struct file *file, int cmd, struct file_lock *fl)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	int err;
 
@@ -1597,7 +1597,7 @@ static sector_t fuse_bmap(struct address
 static loff_t fuse_file_llseek(struct file *file, loff_t offset, int origin)
 {
 	loff_t retval;
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 
 	mutex_lock(&inode->i_mutex);
 	switch (origin) {
@@ -1984,7 +1984,7 @@ EXPORT_SYMBOL_GPL(fuse_do_ioctl);
 static long fuse_file_ioctl_common(struct file *file, unsigned int cmd,
 				   unsigned long arg, unsigned int flags)
 {
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 
 	if (!fuse_allow_task(fc, current))
diff -u -p a/fuse/dir.c b/fuse/dir.c
--- a/fuse/dir.c
+++ b/fuse/dir.c
@@ -158,7 +158,7 @@ static int fuse_dentry_revalidate(struct
 {
 	struct inode *inode;
 
-	inode = ACCESS_ONCE(entry->d_inode);
+	inode = ACCESS_ONCE(d_inode(entry));
 	if (inode && is_bad_inode(inode))
 		return 0;
 	else if (fuse_dentry_time(entry) < get_jiffies_64()) {
@@ -191,7 +191,7 @@ static int fuse_dentry_revalidate(struct
 		attr_version = fuse_get_attr_version(fc);
 
 		parent = dget_parent(entry);
-		fuse_lookup_init(fc, req, get_node_id(parent->d_inode),
+		fuse_lookup_init(fc, req, get_node_id(d_inode(parent)),
 				 &entry->d_name, &outarg);
 		fuse_request_send(fc, req);
 		dput(parent);
@@ -643,7 +643,7 @@ static int fuse_unlink(struct inode *dir
 	err = req->out.h.error;
 	fuse_put_request(fc, req);
 	if (!err) {
-		struct inode *inode = entry->d_inode;
+		struct inode *inode = d_inode(entry);
 
 		/*
 		 * Set nlink to zero so the inode can be cleared, if the inode
@@ -676,7 +676,7 @@ static int fuse_rmdir(struct inode *dir,
 	err = req->out.h.error;
 	fuse_put_request(fc, req);
 	if (!err) {
-		clear_nlink(entry->d_inode);
+		clear_nlink(d_inode(entry));
 		fuse_invalidate_attr(dir);
 		fuse_invalidate_entry_cache(entry);
 	} else if (err == -EINTR)
@@ -711,15 +711,15 @@ static int fuse_rename(struct inode *old
 	fuse_put_request(fc, req);
 	if (!err) {
 		/* ctime changes */
-		fuse_invalidate_attr(oldent->d_inode);
+		fuse_invalidate_attr(d_inode(oldent));
 
 		fuse_invalidate_attr(olddir);
 		if (olddir != newdir)
 			fuse_invalidate_attr(newdir);
 
 		/* newent will end up negative */
-		if (newent->d_inode) {
-			fuse_invalidate_attr(newent->d_inode);
+		if (d_inode(newent)) {
+			fuse_invalidate_attr(d_inode(newent));
 			fuse_invalidate_entry_cache(newent);
 		}
 	} else if (err == -EINTR) {
@@ -729,7 +729,7 @@ static int fuse_rename(struct inode *old
 		   directory), then there can be inconsistency between
 		   the dcache and the real filesystem.  Tough luck. */
 		fuse_invalidate_entry(oldent);
-		if (newent->d_inode)
+		if (d_inode(newent))
 			fuse_invalidate_entry(newent);
 	}
 
@@ -741,7 +741,7 @@ static int fuse_link(struct dentry *entr
 {
 	int err;
 	struct fuse_link_in inarg;
-	struct inode *inode = entry->d_inode;
+	struct inode *inode = d_inode(entry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_req *req = fuse_get_req(fc);
 	if (IS_ERR(req))
@@ -1082,7 +1082,7 @@ static int fuse_readdir(struct file *fil
 	int err;
 	size_t nbytes;
 	struct page *page;
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_req *req;
 
@@ -1117,7 +1117,7 @@ static int fuse_readdir(struct file *fil
 
 static char *read_link(struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_req *req = fuse_get_req(fc);
 	char *link;
@@ -1279,7 +1279,7 @@ void fuse_release_nowrite(struct inode *
 static int fuse_do_setattr(struct dentry *entry, struct iattr *attr,
 			   struct file *file)
 {
-	struct inode *inode = entry->d_inode;
+	struct inode *inode = d_inode(entry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_req *req;
 	struct fuse_setattr_in inarg;
@@ -1394,7 +1394,7 @@ static int fuse_setattr(struct dentry *e
 static int fuse_getattr(struct vfsmount *mnt, struct dentry *entry,
 			struct kstat *stat)
 {
-	struct inode *inode = entry->d_inode;
+	struct inode *inode = d_inode(entry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 
 	if (!fuse_allow_task(fc, current))
@@ -1406,7 +1406,7 @@ static int fuse_getattr(struct vfsmount
 static int fuse_setxattr(struct dentry *entry, const char *name,
 			 const void *value, size_t size, int flags)
 {
-	struct inode *inode = entry->d_inode;
+	struct inode *inode = d_inode(entry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_req *req;
 	struct fuse_setxattr_in inarg;
@@ -1444,7 +1444,7 @@ static int fuse_setxattr(struct dentry *
 static ssize_t fuse_getxattr(struct dentry *entry, const char *name,
 			     void *value, size_t size)
 {
-	struct inode *inode = entry->d_inode;
+	struct inode *inode = d_inode(entry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_req *req;
 	struct fuse_getxattr_in inarg;
@@ -1493,7 +1493,7 @@ static ssize_t fuse_getxattr(struct dent
 
 static ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size)
 {
-	struct inode *inode = entry->d_inode;
+	struct inode *inode = d_inode(entry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_req *req;
 	struct fuse_getxattr_in inarg;
@@ -1543,7 +1543,7 @@ static ssize_t fuse_listxattr(struct den
 
 static int fuse_removexattr(struct dentry *entry, const char *name)
 {
-	struct inode *inode = entry->d_inode;
+	struct inode *inode = d_inode(entry);
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_req *req;
 	int err;
diff -u -p a/ramfs/file-nommu.c b/ramfs/file-nommu.c
--- a/ramfs/file-nommu.c
+++ b/ramfs/file-nommu.c
@@ -158,7 +158,7 @@ static int ramfs_nommu_resize(struct ino
  */
 static int ramfs_nommu_setattr(struct dentry *dentry, struct iattr *ia)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	unsigned int old_ia_valid = ia->ia_valid;
 	int ret = 0;
 
@@ -201,7 +201,7 @@ unsigned long ramfs_nommu_get_unmapped_a
 					    unsigned long pgoff, unsigned long flags)
 {
 	unsigned long maxpages, lpages, nr, loop, ret;
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct page **pages = NULL, **ptr, *page;
 	loff_t isize;
 
diff -u -p a/exec.c b/exec.c
--- a/exec.c
+++ b/exec.c
@@ -131,7 +131,7 @@ SYSCALL_DEFINE1(uselib, const char __use
 		goto out;
 
 	error = -EINVAL;
-	if (!S_ISREG(file->f_path.dentry->d_inode->i_mode))
+	if (!S_ISREG(d_inode(file->f_path.dentry)->i_mode))
 		goto exit;
 
 	error = -EACCES;
@@ -781,7 +781,7 @@ struct file *open_exec(const char *name)
 		goto out;
 
 	err = -EACCES;
-	if (!S_ISREG(file->f_path.dentry->d_inode->i_mode))
+	if (!S_ISREG(d_inode(file->f_path.dentry)->i_mode))
 		goto exit;
 
 	if (file->f_path.mnt->mnt_flags & MNT_NOEXEC)
@@ -1259,7 +1259,7 @@ int check_unsafe_exec(struct linux_binpr
 int prepare_binprm(struct linux_binprm *bprm)
 {
 	umode_t mode;
-	struct inode * inode = bprm->file->f_path.dentry->d_inode;
+	struct inode * inode = d_inode(bprm->file->f_path.dentry);
 	int retval;
 
 	mode = inode->i_mode;
@@ -1966,7 +1966,7 @@ static void wait_for_dump_helpers(struct
 {
 	struct pipe_inode_info *pipe;
 
-	pipe = file->f_path.dentry->d_inode->i_pipe;
+	pipe = d_inode(file->f_path.dentry)->i_pipe;
 
 	pipe_lock(pipe);
 	pipe->readers++;
@@ -2158,7 +2158,7 @@ void do_coredump(long signr, int exit_co
 		if (IS_ERR(cprm.file))
 			goto fail_unlock;
 
-		inode = cprm.file->f_path.dentry->d_inode;
+		inode = d_inode(cprm.file->f_path.dentry);
 		if (inode->i_nlink > 1)
 			goto close_fail;
 		if (d_unhashed(cprm.file->f_path.dentry))
diff -u -p a/pipe.c b/pipe.c
--- a/pipe.c
+++ b/pipe.c
@@ -350,7 +350,7 @@ pipe_read(struct kiocb *iocb, const stru
 	   unsigned long nr_segs, loff_t pos)
 {
 	struct file *filp = iocb->ki_filp;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct pipe_inode_info *pipe;
 	int do_wakeup;
 	ssize_t ret;
@@ -463,7 +463,7 @@ pipe_write(struct kiocb *iocb, const str
 	    unsigned long nr_segs, loff_t ppos)
 {
 	struct file *filp = iocb->ki_filp;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct pipe_inode_info *pipe;
 	ssize_t ret;
 	int do_wakeup;
@@ -646,7 +646,7 @@ bad_pipe_w(struct file *filp, const char
 
 static long pipe_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct pipe_inode_info *pipe;
 	int count, buf, nrbufs;
 
@@ -674,7 +674,7 @@ static unsigned int
 pipe_poll(struct file *filp, poll_table *wait)
 {
 	unsigned int mask;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct pipe_inode_info *pipe = inode->i_pipe;
 	int nrbufs;
 
@@ -727,7 +727,7 @@ pipe_release(struct inode *inode, int de
 static int
 pipe_read_fasync(int fd, struct file *filp, int on)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	int retval;
 
 	mutex_lock(&inode->i_mutex);
@@ -741,7 +741,7 @@ pipe_read_fasync(int fd, struct file *fi
 static int
 pipe_write_fasync(int fd, struct file *filp, int on)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	int retval;
 
 	mutex_lock(&inode->i_mutex);
@@ -755,7 +755,7 @@ pipe_write_fasync(int fd, struct file *f
 static int
 pipe_rdwr_fasync(int fd, struct file *filp, int on)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct pipe_inode_info *pipe = inode->i_pipe;
 	int retval;
 
@@ -939,7 +939,7 @@ static struct vfsmount *pipe_mnt __read_
 static char *pipefs_dname(struct dentry *dentry, char *buffer, int buflen)
 {
 	return dynamic_dname(dentry, buffer, buflen, "pipe:[%lu]",
-				dentry->d_inode->i_ino);
+				d_inode(dentry)->i_ino);
 }
 
 static const struct dentry_operations pipefs_dentry_operations = {
@@ -1031,7 +1031,7 @@ struct file *create_write_pipe(int flags
 
 void free_write_pipe(struct file *f)
 {
-	free_pipe_info(f->f_dentry->d_inode);
+	free_pipe_info(d_inode(f->f_dentry));
 	path_put(&f->f_path);
 	put_filp(f);
 }
@@ -1205,7 +1205,7 @@ int pipe_proc_fn(struct ctl_table *table
  */
 struct pipe_inode_info *get_pipe_info(struct file *file)
 {
-	struct inode *i = file->f_path.dentry->d_inode;
+	struct inode *i = d_inode(file->f_path.dentry);
 
 	return S_ISFIFO(i->i_mode) ? i->i_pipe : NULL;
 }
diff -u -p a/openpromfs/inode.c b/openpromfs/inode.c
--- a/openpromfs/inode.c
+++ b/openpromfs/inode.c
@@ -262,7 +262,7 @@ found:
 
 static int openpromfs_readdir(struct file * filp, void * dirent, filldir_t filldir)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct op_inode_info *oi = OP_I(inode);
 	struct device_node *dp = oi->u.node;
 	struct device_node *child;
diff -u -p a/coda/inode.c b/coda/inode.c
--- a/coda/inode.c
+++ b/coda/inode.c
@@ -126,7 +126,7 @@ static int get_device_index(struct coda_
 	file = fget(data->fd);
 	inode = NULL;
 	if(file)
-		inode = file->f_path.dentry->d_inode;
+		inode = d_inode(file->f_path.dentry);
 	
 	if(!inode || !S_ISCHR(inode->i_mode) ||
 	   imajor(inode) != CODA_PSDEV_MAJOR) {
@@ -256,13 +256,13 @@ int coda_getattr(struct vfsmount *mnt, s
 {
 	int err = coda_revalidate_inode(dentry);
 	if (!err)
-		generic_fillattr(dentry->d_inode, stat);
+		generic_fillattr(d_inode(dentry), stat);
 	return err;
 }
 
 int coda_setattr(struct dentry *de, struct iattr *iattr)
 {
-	struct inode *inode = de->d_inode;
+	struct inode *inode = d_inode(de);
 	struct coda_vattr vattr;
 	int error;
 
diff -u -p a/coda/coda_linux.c b/coda/coda_linux.c
--- a/coda/coda_linux.c
+++ b/coda/coda_linux.c
@@ -43,7 +43,7 @@ int coda_iscontrol(const char *name, siz
 /* recognize /coda inode */
 int coda_isroot(struct inode *i)
 {
-    return ( i->i_sb->s_root->d_inode == i );
+    return (d_inode(i->i_sb->s_root) == i );
 }
 
 unsigned short coda_flags_to_cflags(unsigned short flags)
diff -u -p a/coda/upcall.c b/coda/upcall.c
--- a/coda/upcall.c
+++ b/coda/upcall.c
@@ -821,8 +821,8 @@ int coda_downcall(struct venus_comm *vcp
 	case CODA_FLUSH:
 		coda_cache_clear_all(sb);
 		shrink_dcache_sb(sb);
-		if (sb->s_root->d_inode)
-			coda_flag_inode(sb->s_root->d_inode, C_FLUSH);
+		if (d_inode(sb->s_root))
+			coda_flag_inode(d_inode(sb->s_root), C_FLUSH);
 		break;
 
 	case CODA_PURGEUSER:
diff -u -p a/coda/file.c b/coda/file.c
--- a/coda/file.c
+++ b/coda/file.c
@@ -66,7 +66,7 @@ coda_file_splice_read(struct file *coda_
 static ssize_t
 coda_file_write(struct file *coda_file, const char __user *buf, size_t count, loff_t *ppos)
 {
-	struct inode *host_inode, *coda_inode = coda_file->f_path.dentry->d_inode;
+	struct inode *host_inode, *coda_inode = d_inode(coda_file->f_path.dentry);
 	struct coda_file_info *cfi;
 	struct file *host_file;
 	ssize_t ret;
@@ -78,7 +78,7 @@ coda_file_write(struct file *coda_file,
 	if (!host_file->f_op || !host_file->f_op->write)
 		return -EINVAL;
 
-	host_inode = host_file->f_path.dentry->d_inode;
+	host_inode = d_inode(host_file->f_path.dentry);
 	mutex_lock(&coda_inode->i_mutex);
 
 	ret = host_file->f_op->write(host_file, buf, count, ppos);
@@ -106,8 +106,8 @@ coda_file_mmap(struct file *coda_file, s
 	if (!host_file->f_op || !host_file->f_op->mmap)
 		return -ENODEV;
 
-	coda_inode = coda_file->f_path.dentry->d_inode;
-	host_inode = host_file->f_path.dentry->d_inode;
+	coda_inode = d_inode(coda_file->f_path.dentry);
+	host_inode = d_inode(host_file->f_path.dentry);
 
 	cii = ITOC(coda_inode);
 	spin_lock(&cii->c_lock);
@@ -178,7 +178,7 @@ int coda_release(struct inode *coda_inod
 	err = venus_close(coda_inode->i_sb, coda_i2f(coda_inode),
 			  coda_flags, coda_file->f_cred->fsuid);
 
-	host_inode = cfi->cfi_container->f_path.dentry->d_inode;
+	host_inode = d_inode(cfi->cfi_container->f_path.dentry);
 	cii = ITOC(coda_inode);
 
 	/* did we mmap this file? */
@@ -202,7 +202,7 @@ int coda_release(struct inode *coda_inod
 int coda_fsync(struct file *coda_file, int datasync)
 {
 	struct file *host_file;
-	struct inode *coda_inode = coda_file->f_path.dentry->d_inode;
+	struct inode *coda_inode = d_inode(coda_file->f_path.dentry);
 	struct coda_file_info *cfi;
 	int err;
 
diff -u -p a/coda/dir.c b/coda/dir.c
--- a/coda/dir.c
+++ b/coda/dir.c
@@ -261,7 +261,7 @@ err_out:
 static int coda_link(struct dentry *source_de, struct inode *dir_inode, 
 	  struct dentry *de)
 {
-	struct inode *inode = source_de->d_inode;
+	struct inode *inode = d_inode(source_de);
         const char * name = de->d_name.name;
 	int len = de->d_name.len;
 	int error;
@@ -326,7 +326,7 @@ static int coda_unlink(struct inode *dir
 		return error;
 
 	coda_dir_update_mtime(dir);
-	drop_nlink(de->d_inode);
+	drop_nlink(d_inode(de));
 	return 0;
 }
 
@@ -339,8 +339,8 @@ static int coda_rmdir(struct inode *dir,
 	error = venus_rmdir(dir->i_sb, coda_i2f(dir), name, len);
 	if (!error) {
 		/* VFS may delete the child */
-		if (de->d_inode)
-		    de->d_inode->i_nlink = 0;
+		if (d_inode(de))
+		    d_inode(de)->i_nlink = 0;
 
 		/* fix the link count of the parent */
 		coda_dir_drop_nlink(dir);
@@ -363,14 +363,14 @@ static int coda_rename(struct inode *old
 			     coda_i2f(new_dir), old_length, new_length,
 			     (const char *) old_name, (const char *)new_name);
 	if (!error) {
-		if (new_dentry->d_inode) {
-			if (S_ISDIR(new_dentry->d_inode->i_mode)) {
+		if (d_inode(new_dentry)) {
+			if (S_ISDIR(d_inode(new_dentry)->i_mode)) {
 				coda_dir_drop_nlink(old_dir);
 				coda_dir_inc_nlink(new_dir);
 			}
 			coda_dir_update_mtime(old_dir);
 			coda_dir_update_mtime(new_dir);
-			coda_flag_inode(new_dentry->d_inode, C_VATTR);
+			coda_flag_inode(d_inode(new_dentry), C_VATTR);
 		} else {
 			coda_flag_inode(old_dir, C_VATTR);
 			coda_flag_inode(new_dir, C_VATTR);
@@ -400,7 +400,7 @@ static int coda_readdir(struct file *cod
 		 * We can't use vfs_readdir because we have to keep the file
 		 * position in sync between the coda_file and the host_file.
 		 * and as such we need grab the inode mutex. */
-		struct inode *host_inode = host_file->f_path.dentry->d_inode;
+		struct inode *host_inode = d_inode(host_file->f_path.dentry);
 
 		mutex_lock(&host_inode->i_mutex);
 		host_file->f_pos = coda_file->f_pos;
@@ -461,20 +461,21 @@ static int coda_venus_readdir(struct fil
 	host_file = cfi->cfi_container;
 
 	de = coda_file->f_path.dentry;
-	cii = ITOC(de->d_inode);
+	cii = ITOC(d_inode(de));
 
 	vdir = kmalloc(sizeof(*vdir), GFP_KERNEL);
 	if (!vdir) return -ENOMEM;
 
 	if (coda_file->f_pos == 0) {
-		ret = filldir(buf, ".", 1, 0, de->d_inode->i_ino, DT_DIR);
+		ret = filldir(buf, ".", 1, 0, d_inode(de)->i_ino, DT_DIR);
 		if (ret < 0)
 			goto out;
 		result++;
 		coda_file->f_pos++;
 	}
 	if (coda_file->f_pos == 1) {
-		ret = filldir(buf, "..", 2, 1, de->d_parent->d_inode->i_ino, DT_DIR);
+		ret = filldir(buf, "..", 2, 1, d_inode(de->d_parent)->i_ino,
+			      DT_DIR);
 		if (ret < 0)
 			goto out;
 		result++;
@@ -548,13 +549,13 @@ static int coda_dentry_revalidate(struct
 	if (nd->flags & LOOKUP_RCU)
 		return -ECHILD;
 
-	inode = de->d_inode;
+	inode = d_inode(de);
 	if (!inode || coda_isroot(inode))
 		goto out;
 	if (is_bad_inode(inode))
 		goto bad;
 
-	cii = ITOC(de->d_inode);
+	cii = ITOC(d_inode(de));
 	if (!(cii->c_flags & (C_PURGE | C_FLUSH)))
 		goto out;
 
@@ -586,11 +587,11 @@ static int coda_dentry_delete(const stru
 {
 	int flags;
 
-	if (!dentry->d_inode) 
+	if (!d_inode(dentry)) 
 		return 0;
 
-	flags = (ITOC(dentry->d_inode)->c_flags) & C_PURGE;
-	if (is_bad_inode(dentry->d_inode) || flags) {
+	flags = (ITOC(d_inode(dentry))->c_flags) & C_PURGE;
+	if (is_bad_inode(d_inode(dentry)) || flags) {
 		return 1;
 	}
 	return 0;
@@ -610,7 +611,7 @@ int coda_revalidate_inode(struct dentry
 	int error;
 	int old_mode;
 	ino_t old_ino;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct coda_inode_info *cii = ITOC(inode);
 
 	if (!cii->c_flags)
diff -u -p a/coda/pioctl.c b/coda/pioctl.c
--- a/coda/pioctl.c
+++ b/coda/pioctl.c
@@ -52,7 +52,7 @@ static long coda_pioctl(struct file *fil
 	struct path path;
 	int error;
 	struct PioctlData data;
-	struct inode *inode = filp->f_dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_dentry);
 	struct inode *target_inode = NULL;
 	struct coda_inode_info *cnp;
 
@@ -72,7 +72,7 @@ static long coda_pioctl(struct file *fil
 	if (error)
 		return error;
 
-	target_inode = path.dentry->d_inode;
+	target_inode = d_inode(path.dentry);
 
 	/* return if it is not a Coda inode */
 	if (target_inode->i_sb != inode->i_sb) {
diff -u -p a/coda/cache.c b/coda/cache.c
--- a/coda/cache.c
+++ b/coda/cache.c
@@ -97,9 +97,9 @@ static void coda_flag_children(struct de
 	{
 		de = list_entry(child, struct dentry, d_u.d_child);
 		/* don't know what to do with negative dentries */
-		if ( ! de->d_inode ) 
+		if ( ! d_inode(de)) 
 			continue;
-		coda_flag_inode(de->d_inode, flag);
+		coda_flag_inode(d_inode(de), flag);
 	}
 	spin_unlock(&parent->d_lock);
 	return; 
diff -u -p a/isofs/dir.c b/isofs/dir.c
--- a/isofs/dir.c
+++ b/isofs/dir.c
@@ -253,7 +253,7 @@ static int isofs_readdir(struct file *fi
 	int result;
 	char *tmpname;
 	struct iso_directory_record *tmpde;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);
 
 	tmpname = (char *)__get_free_page(GFP_KERNEL);
diff -u -p a/isofs/export.c b/isofs/export.c
--- a/isofs/export.c
+++ b/isofs/export.c
@@ -44,7 +44,7 @@ static struct dentry *isofs_export_get_p
 {
 	unsigned long parent_block = 0;
 	unsigned long parent_offset = 0;
-	struct inode *child_inode = child->d_inode;
+	struct inode *child_inode = d_inode(child);
 	struct iso_inode_info *e_child_inode = ISOFS_I(child_inode);
 	struct iso_directory_record *de = NULL;
 	struct buffer_head * bh = NULL;
@@ -112,7 +112,7 @@ isofs_export_encode_fh(struct dentry *de
 		       int *max_len,
 		       int connectable)
 {
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	struct iso_inode_info * ei = ISOFS_I(inode);
 	int len = *max_len;
 	int type = 1;
@@ -140,7 +140,7 @@ isofs_export_encode_fh(struct dentry *de
 		struct inode *parent;
 		struct iso_inode_info *eparent;
 		spin_lock(&dentry->d_lock);
-		parent = dentry->d_parent->d_inode;
+		parent = d_inode(dentry->d_parent);
 		eparent = ISOFS_I(parent);
 		fh32[3] = eparent->i_iget5_block;
 		fh16[3] = (__u16)eparent->i_iget5_offset;  /* fh16 [sic] */
diff -u -p a/isofs/compress.c b/isofs/compress.c
--- a/isofs/compress.c
+++ b/isofs/compress.c
@@ -296,7 +296,7 @@ static int zisofs_fill_pages(struct inod
  */
 static int zisofs_readpage(struct file *file, struct page *page)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct address_space *mapping = inode->i_mapping;
 	int err;
 	int i, pcount, full_page;
diff -u -p a/binfmt_aout.c b/binfmt_aout.c
--- a/binfmt_aout.c
+++ b/binfmt_aout.c
@@ -214,7 +214,7 @@ static int load_aout_binary(struct linux
 	if ((N_MAGIC(ex) != ZMAGIC && N_MAGIC(ex) != OMAGIC &&
 	     N_MAGIC(ex) != QMAGIC && N_MAGIC(ex) != NMAGIC) ||
 	    N_TRSIZE(ex) || N_DRSIZE(ex) ||
-	    i_size_read(bprm->file->f_path.dentry->d_inode) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {
+	    i_size_read(d_inode(bprm->file->f_path.dentry)) < ex.a_text+ex.a_data+N_SYMSIZE(ex)+N_TXTOFF(ex)) {
 		return -ENOEXEC;
 	}
 
@@ -376,7 +376,7 @@ static int load_aout_library(struct file
 	int retval;
 	struct exec ex;
 
-	inode = file->f_path.dentry->d_inode;
+	inode = d_inode(file->f_path.dentry);
 
 	retval = -ENOEXEC;
 	error = kernel_read(file, 0, (char *) &ex, sizeof(ex));
diff -u -p a/logfs/file.c b/logfs/file.c
--- a/logfs/file.c
+++ b/logfs/file.c
@@ -183,7 +183,7 @@ static int logfs_releasepage(struct page
 
 long logfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct logfs_inode *li = logfs_inode(inode);
 	unsigned int oldflags, flags;
 	int err;
@@ -229,7 +229,7 @@ int logfs_fsync(struct file *file, int d
 
 static int logfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int err = 0;
 
 	err = inode_change_ok(inode, attr);
diff -u -p a/logfs/dir.c b/logfs/dir.c
--- a/logfs/dir.c
+++ b/logfs/dir.c
@@ -213,7 +213,7 @@ static void abort_transaction(struct ino
 static int logfs_unlink(struct inode *dir, struct dentry *dentry)
 {
 	struct logfs_super *super = logfs_super(dir->i_sb);
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct logfs_transaction *ta;
 	struct page *page;
 	pgoff_t index;
@@ -271,7 +271,7 @@ static inline int logfs_empty_dir(struct
 
 static int logfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	if (!logfs_empty_dir(inode))
 		return -ENOTEMPTY;
@@ -284,7 +284,7 @@ static int logfs_rmdir(struct inode *dir
 #define IMPLICIT_NODES 2
 static int __logfs_readdir(struct file *file, void *buf, filldir_t filldir)
 {
-	struct inode *dir = file->f_dentry->d_inode;
+	struct inode *dir = d_inode(file->f_dentry);
 	loff_t pos = file->f_pos - IMPLICIT_NODES;
 	struct page *page;
 	struct logfs_disk_dentry *dd;
@@ -320,7 +320,7 @@ static int __logfs_readdir(struct file *
 
 static int logfs_readdir(struct file *file, void *buf, filldir_t filldir)
 {
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	ino_t pino = parent_ino(file->f_dentry);
 	int err;
 
@@ -558,7 +558,7 @@ static int logfs_symlink(struct inode *d
 static int logfs_link(struct dentry *old_dentry, struct inode *dir,
 		struct dentry *dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 
 	if (inode->i_nlink >= LOGFS_LINK_MAX)
 		return -EMLINK;
@@ -631,7 +631,7 @@ static int logfs_rename_cross(struct ino
 	/* 2. write target dd */
 	mutex_lock(&super->s_dirop_mutex);
 	logfs_add_transaction(new_dir, ta);
-	err = logfs_write_dir(new_dir, new_dentry, old_dentry->d_inode);
+	err = logfs_write_dir(new_dir, new_dentry, d_inode(old_dentry));
 	if (!err)
 		err = write_inode(new_dir);
 
@@ -682,8 +682,8 @@ static int logfs_rename_target(struct in
 			       struct inode *new_dir, struct dentry *new_dentry)
 {
 	struct logfs_super *super = logfs_super(old_dir->i_sb);
-	struct inode *old_inode = old_dentry->d_inode;
-	struct inode *new_inode = new_dentry->d_inode;
+	struct inode *old_inode = d_inode(old_dentry);
+	struct inode *new_inode = d_inode(new_dentry);
 	int isdir = S_ISDIR(old_inode->i_mode);
 	struct logfs_disk_dentry dd;
 	struct logfs_transaction *ta;
@@ -743,7 +743,7 @@ out:
 static int logfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 			struct inode *new_dir, struct dentry *new_dentry)
 {
-	if (new_dentry->d_inode)
+	if (d_inode(new_dentry))
 		return logfs_rename_target(old_dir, old_dentry,
 					   new_dir, new_dentry);
 	return logfs_rename_cross(old_dir, old_dentry, new_dir, new_dentry);
diff -u -p a/ext4/super.c b/ext4/super.c
--- a/ext4/super.c
+++ b/ext4/super.c
@@ -468,7 +468,7 @@ void ext4_error_file(struct file *file,
 	va_list args;
 	struct va_format vaf;
 	struct ext4_super_block *es;
-	struct inode *inode = file->f_dentry->d_inode;
+	struct inode *inode = d_inode(file->f_dentry);
 	char pathname[80], *path;
 
 	es = EXT4_SB(inode->i_sb)->s_es;
@@ -4635,7 +4635,7 @@ static int ext4_write_info(struct super_
 	handle_t *handle;
 
 	/* Data block + inode block */
-	handle = ext4_journal_start(sb->s_root->d_inode, 2);
+	handle = ext4_journal_start(d_inode(sb->s_root), 2);
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
 	ret = dquot_commit_info(sb, type);
@@ -4683,7 +4683,7 @@ static int ext4_quota_on(struct super_bl
 	 * all updates to the file when we bypass pagecache...
 	 */
 	if (EXT4_SB(sb)->s_journal &&
-	    ext4_should_journal_data(path->dentry->d_inode)) {
+	    ext4_should_journal_data(d_inode(path->dentry))) {
 		/*
 		 * We don't need to lock updates but journal_flush() could
 		 * otherwise be livelocked...
diff -u -p a/ext4/fsync.c b/ext4/fsync.c
--- a/ext4/fsync.c
+++ b/ext4/fsync.c
@@ -135,9 +135,9 @@ static int ext4_sync_parent(struct inode
 		ext4_clear_inode_state(inode, EXT4_STATE_NEWENTRY);
 		dentry = list_entry(inode->i_dentry.next,
 				    struct dentry, d_alias);
-		if (!dentry || !dentry->d_parent || !dentry->d_parent->d_inode)
+		if (!dentry || !dentry->d_parent || !d_inode(dentry->d_parent))
 			break;
-		inode = dentry->d_parent->d_inode;
+		inode = d_inode(dentry->d_parent);
 		ret = sync_mapping_buffers(inode->i_mapping);
 		if (ret)
 			break;
diff -u -p a/ext4/symlink.c b/ext4/symlink.c
--- a/ext4/symlink.c
+++ b/ext4/symlink.c
@@ -25,7 +25,7 @@
 
 static void *ext4_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct ext4_inode_info *ei = EXT4_I(dentry->d_inode);
+	struct ext4_inode_info *ei = EXT4_I(d_inode(dentry));
 	nd_set_link(nd, (char *) ei->i_data);
 	return NULL;
 }
diff -u -p a/ext4/xattr_user.c b/ext4/xattr_user.c
--- a/ext4/xattr_user.c
+++ b/ext4/xattr_user.c
@@ -38,7 +38,7 @@ ext4_xattr_user_get(struct dentry *dentr
 		return -EINVAL;
 	if (!test_opt(dentry->d_sb, XATTR_USER))
 		return -EOPNOTSUPP;
-	return ext4_xattr_get(dentry->d_inode, EXT4_XATTR_INDEX_USER,
+	return ext4_xattr_get(d_inode(dentry), EXT4_XATTR_INDEX_USER,
 			      name, buffer, size);
 }
 
@@ -50,7 +50,7 @@ ext4_xattr_user_set(struct dentry *dentr
 		return -EINVAL;
 	if (!test_opt(dentry->d_sb, XATTR_USER))
 		return -EOPNOTSUPP;
-	return ext4_xattr_set(dentry->d_inode, EXT4_XATTR_INDEX_USER,
+	return ext4_xattr_set(d_inode(dentry), EXT4_XATTR_INDEX_USER,
 			      name, value, size, flags);
 }
 
diff -u -p a/ext4/move_extent.c b/ext4/move_extent.c
--- a/ext4/move_extent.c
+++ b/ext4/move_extent.c
@@ -791,7 +791,7 @@ move_extent_per_page(struct file *o_filp
 		  pgoff_t orig_page_offset, int data_offset_in_page,
 		  int block_len_in_page, int uninit, int *err)
 {
-	struct inode *orig_inode = o_filp->f_dentry->d_inode;
+	struct inode *orig_inode = d_inode(o_filp->f_dentry);
 	struct address_space *mapping = orig_inode->i_mapping;
 	struct buffer_head *bh;
 	struct page *page = NULL;
@@ -1180,8 +1180,8 @@ ext4_move_extents(struct file *o_filp, s
 		 __u64 orig_start, __u64 donor_start, __u64 len,
 		 __u64 *moved_len)
 {
-	struct inode *orig_inode = o_filp->f_dentry->d_inode;
-	struct inode *donor_inode = d_filp->f_dentry->d_inode;
+	struct inode *orig_inode = d_inode(o_filp->f_dentry);
+	struct inode *donor_inode = d_inode(d_filp->f_dentry);
 	struct ext4_ext_path *orig_path = NULL, *holecheck_path = NULL;
 	struct ext4_extent *ext_prev, *ext_cur, *ext_dummy;
 	ext4_lblk_t block_start = orig_start;
diff -u -p a/ext4/inode.c b/ext4/inode.c
--- a/ext4/inode.c
+++ b/ext4/inode.c
@@ -4429,7 +4429,7 @@ int ext4_can_truncate(struct inode *inod
 
 int ext4_punch_hole(struct file *file, loff_t offset, loff_t length)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	if (!S_ISREG(inode->i_mode))
 		return -ENOTSUPP;
 
@@ -5312,7 +5312,7 @@ int ext4_write_inode(struct inode *inode
  */
 int ext4_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error, rc = 0;
 	int orphan = 0;
 	const unsigned int ia_valid = attr->ia_valid;
@@ -5433,7 +5433,7 @@ int ext4_getattr(struct vfsmount *mnt, s
 	struct inode *inode;
 	unsigned long delalloc_blocks;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	generic_fillattr(inode, stat);
 
 	/*
@@ -5846,7 +5846,7 @@ int ext4_page_mkwrite(struct vm_area_str
 	int ret = -EINVAL;
 	void *fsdata;
 	struct file *file = vma->vm_file;
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct address_space *mapping = inode->i_mapping;
 
 	/*
diff -u -p a/ext4/file.c b/ext4/file.c
--- a/ext4/file.c
+++ b/ext4/file.c
@@ -93,7 +93,7 @@ static ssize_t
 ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 		unsigned long nr_segs, loff_t pos)
 {
-	struct inode *inode = iocb->ki_filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(iocb->ki_filp->f_path.dentry);
 	int unaligned_aio = 0;
 	int ret;
 
diff -u -p a/ext4/namei.c b/ext4/namei.c
--- a/ext4/namei.c
+++ b/ext4/namei.c
@@ -632,7 +632,7 @@ int ext4_htree_fill_tree(struct file *di
 
 	dxtrace(printk(KERN_DEBUG "In htree_fill_tree, start hash: %x:%x\n",
 		       start_hash, start_minor_hash));
-	dir = dir_file->f_path.dentry->d_inode;
+	dir = d_inode(dir_file->f_path.dentry);
 	if (!(ext4_test_inode_flag(dir, EXT4_INODE_INDEX))) {
 		hinfo.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;
 		if (hinfo.hash_version <= DX_HASH_TEA)
@@ -1062,19 +1062,19 @@ struct dentry *ext4_get_parent(struct de
 	struct ext4_dir_entry_2 * de;
 	struct buffer_head *bh;
 
-	bh = ext4_find_entry(child->d_inode, &dotdot, &de);
+	bh = ext4_find_entry(d_inode(child), &dotdot, &de);
 	if (!bh)
 		return ERR_PTR(-ENOENT);
 	ino = le32_to_cpu(de->inode);
 	brelse(bh);
 
-	if (!ext4_valid_inum(child->d_inode->i_sb, ino)) {
-		EXT4_ERROR_INODE(child->d_inode,
+	if (!ext4_valid_inum(d_inode(child)->i_sb, ino)) {
+		EXT4_ERROR_INODE(d_inode(child),
 				 "bad parent inode number: %u", ino);
 		return ERR_PTR(-EIO);
 	}
 
-	return d_obtain_alias(ext4_iget(child->d_inode->i_sb, ino));
+	return d_obtain_alias(ext4_iget(d_inode(child)->i_sb, ino));
 }
 
 #define S_SHIFT 12
@@ -1256,7 +1256,7 @@ static int add_dirent_to_buf(handle_t *h
 			     struct inode *inode, struct ext4_dir_entry_2 *de,
 			     struct buffer_head *bh)
 {
-	struct inode	*dir = dentry->d_parent->d_inode;
+	struct inode	*dir = d_inode(dentry->d_parent);
 	const char	*name = dentry->d_name.name;
 	int		namelen = dentry->d_name.len;
 	unsigned int	offset = 0;
@@ -1337,7 +1337,7 @@ static int add_dirent_to_buf(handle_t *h
 static int make_indexed_dir(handle_t *handle, struct dentry *dentry,
 			    struct inode *inode, struct buffer_head *bh)
 {
-	struct inode	*dir = dentry->d_parent->d_inode;
+	struct inode	*dir = d_inode(dentry->d_parent);
 	const char	*name = dentry->d_name.name;
 	int		namelen = dentry->d_name.len;
 	struct buffer_head *bh2;
@@ -1448,7 +1448,7 @@ static int make_indexed_dir(handle_t *ha
 static int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 			  struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	struct buffer_head *bh;
 	struct ext4_dir_entry_2 *de;
 	struct super_block *sb;
@@ -1508,7 +1508,7 @@ static int ext4_dx_add_entry(handle_t *h
 	struct dx_entry *entries, *at;
 	struct dx_hash_info hinfo;
 	struct buffer_head *bh;
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	struct super_block *sb = dir->i_sb;
 	struct ext4_dir_entry_2 *de;
 	int err;
@@ -2138,7 +2138,7 @@ static int ext4_rmdir(struct inode *dir,
 	/* Initialize quotas before so that eventual writes go in
 	 * separate transaction */
 	dquot_initialize(dir);
-	dquot_initialize(dentry->d_inode);
+	dquot_initialize(d_inode(dentry));
 
 	handle = ext4_journal_start(dir, EXT4_DELETE_TRANS_BLOCKS(dir->i_sb));
 	if (IS_ERR(handle))
@@ -2152,7 +2152,7 @@ static int ext4_rmdir(struct inode *dir,
 	if (IS_DIRSYNC(dir))
 		ext4_handle_sync(handle);
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	retval = -EIO;
 	if (le32_to_cpu(de->inode) != inode->i_ino)
@@ -2200,7 +2200,7 @@ static int ext4_unlink(struct inode *dir
 	/* Initialize quotas before so that eventual writes go
 	 * in separate transaction */
 	dquot_initialize(dir);
-	dquot_initialize(dentry->d_inode);
+	dquot_initialize(d_inode(dentry));
 
 	handle = ext4_journal_start(dir, EXT4_DELETE_TRANS_BLOCKS(dir->i_sb));
 	if (IS_ERR(handle))
@@ -2214,7 +2214,7 @@ static int ext4_unlink(struct inode *dir
 	if (!bh)
 		goto end_unlink;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	retval = -EIO;
 	if (le32_to_cpu(de->inode) != inode->i_ino)
@@ -2355,7 +2355,7 @@ static int ext4_link(struct dentry *old_
 		     struct inode *dir, struct dentry *dentry)
 {
 	handle_t *handle;
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	int err, retries = 0;
 
 	if (inode->i_nlink >= EXT4_LINK_MAX)
@@ -2413,8 +2413,8 @@ static int ext4_rename(struct inode *old
 
 	/* Initialize quotas before so that eventual writes go
 	 * in separate transaction */
-	if (new_dentry->d_inode)
-		dquot_initialize(new_dentry->d_inode);
+	if (d_inode(new_dentry))
+		dquot_initialize(d_inode(new_dentry));
 	handle = ext4_journal_start(old_dir, 2 *
 					EXT4_DATA_TRANS_BLOCKS(old_dir->i_sb) +
 					EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2);
@@ -2431,12 +2431,12 @@ static int ext4_rename(struct inode *old
 	 *  and merrily kill the link to whatever was created under the
 	 *  same name. Goodbye sticky bit ;-<
 	 */
-	old_inode = old_dentry->d_inode;
+	old_inode = d_inode(old_dentry);
 	retval = -ENOENT;
 	if (!old_bh || le32_to_cpu(old_de->inode) != old_inode->i_ino)
 		goto end_rename;
 
-	new_inode = new_dentry->d_inode;
+	new_inode = d_inode(new_dentry);
 	new_bh = ext4_find_entry(new_dir, &new_dentry->d_name, &new_de);
 	if (new_bh) {
 		if (!new_inode) {
diff -u -p a/ext4/ialloc.c b/ext4/ialloc.c
--- a/ext4/ialloc.c
+++ b/ext4/ialloc.c
@@ -496,7 +496,7 @@ static int find_group_orlov(struct super
 	ndirs = percpu_counter_read_positive(&sbi->s_dirs_counter);
 
 	if (S_ISDIR(mode) &&
-	    ((parent == sb->s_root->d_inode) ||
+	    ((parent == d_inode(sb->s_root)) ||
 	     (ext4_test_inode_flag(parent, EXT4_INODE_TOPDIR)))) {
 		int best_ndir = inodes_per_group;
 		int ret = -1;
diff -u -p a/ext4/dir.c b/ext4/dir.c
--- a/ext4/dir.c
+++ b/ext4/dir.c
@@ -117,7 +117,7 @@ static int ext4_readdir(struct file *fil
 	struct ext4_dir_entry_2 *de;
 	struct super_block *sb;
 	int err;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	int ret = 0;
 	int dir_has_error = 0;
 
@@ -136,7 +136,7 @@ static int ext4_readdir(struct file *fil
 		 * We don't set the inode dirty flag since it's not
 		 * critical that it get flushed back to the disk.
 		 */
-		ext4_clear_inode_flag(filp->f_path.dentry->d_inode,
+		ext4_clear_inode_flag(d_inode(filp->f_path.dentry),
 				      EXT4_INODE_INDEX);
 	}
 	stored = 0;
@@ -418,7 +418,7 @@ static int call_filldir(struct file *fil
 {
 	struct dir_private_info *info = filp->private_data;
 	loff_t	curr_pos;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct super_block *sb;
 	int error;
 
@@ -449,7 +449,7 @@ static int ext4_dx_readdir(struct file *
 			 void *dirent, filldir_t filldir)
 {
 	struct dir_private_info *info = filp->private_data;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct fname *fname;
 	int	ret;
 
diff -u -p a/ext4/migrate.c b/ext4/migrate.c
--- a/ext4/migrate.c
+++ b/ext4/migrate.c
@@ -495,7 +495,7 @@ int ext4_ext_migrate(struct inode *inode
 	}
 	goal = (((inode->i_ino - 1) / EXT4_INODES_PER_GROUP(inode->i_sb)) *
 		EXT4_INODES_PER_GROUP(inode->i_sb)) + 1;
-	tmp_inode = ext4_new_inode(handle, inode->i_sb->s_root->d_inode,
+	tmp_inode = ext4_new_inode(handle, d_inode(inode->i_sb->s_root),
 				   S_IFREG, NULL, goal);
 	if (IS_ERR(tmp_inode)) {
 		retval = -ENOMEM;
diff -u -p a/ext4/ioctl.c b/ext4/ioctl.c
--- a/ext4/ioctl.c
+++ b/ext4/ioctl.c
@@ -20,7 +20,7 @@
 
 long ext4_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = filp->f_dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_dentry);
 	struct ext4_inode_info *ei = EXT4_I(inode);
 	unsigned int flags;
 
diff -u -p a/ext4/xattr_trusted.c b/ext4/xattr_trusted.c
--- a/ext4/xattr_trusted.c
+++ b/ext4/xattr_trusted.c
@@ -37,7 +37,7 @@ ext4_xattr_trusted_get(struct dentry *de
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext4_xattr_get(dentry->d_inode, EXT4_XATTR_INDEX_TRUSTED,
+	return ext4_xattr_get(d_inode(dentry), EXT4_XATTR_INDEX_TRUSTED,
 			      name, buffer, size);
 }
 
@@ -47,7 +47,7 @@ ext4_xattr_trusted_set(struct dentry *de
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext4_xattr_set(dentry->d_inode, EXT4_XATTR_INDEX_TRUSTED,
+	return ext4_xattr_set(d_inode(dentry), EXT4_XATTR_INDEX_TRUSTED,
 			      name, value, size, flags);
 }
 
diff -u -p a/ext4/extents.c b/ext4/extents.c
--- a/ext4/extents.c
+++ b/ext4/extents.c
@@ -3764,7 +3764,7 @@ static void ext4_falloc_update_inode(str
  */
 long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	handle_t *handle;
 	loff_t new_size;
 	unsigned int max_blocks;
@@ -4166,7 +4166,7 @@ static int ext4_xattr_fiemap(struct inod
  */
 int ext4_ext_punch_hole(struct file *file, loff_t offset, loff_t length)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct super_block *sb = inode->i_sb;
 	struct ext4_ext_cache cache_ex;
 	ext4_lblk_t first_block, last_block, num_blocks, iblock, max_blocks;
diff -u -p a/ext4/acl.c b/ext4/acl.c
--- a/ext4/acl.c
+++ b/ext4/acl.c
@@ -409,7 +409,7 @@ ext4_xattr_get_acl(struct dentry *dentry
 	if (!test_opt(dentry->d_sb, POSIX_ACL))
 		return -EOPNOTSUPP;
 
-	acl = ext4_get_acl(dentry->d_inode, type);
+	acl = ext4_get_acl(d_inode(dentry), type);
 	if (IS_ERR(acl))
 		return PTR_ERR(acl);
 	if (acl == NULL)
@@ -424,7 +424,7 @@ static int
 ext4_xattr_set_acl(struct dentry *dentry, const char *name, const void *value,
 		   size_t size, int flags, int type)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	handle_t *handle;
 	struct posix_acl *acl;
 	int error, retries = 0;
diff -u -p a/ext4/xattr.c b/ext4/xattr.c
--- a/ext4/xattr.c
+++ b/ext4/xattr.c
@@ -353,7 +353,7 @@ ext4_xattr_list_entries(struct dentry *d
 static int
 ext4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct buffer_head *bh = NULL;
 	int error;
 
@@ -388,7 +388,7 @@ cleanup:
 static int
 ext4_xattr_ibody_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ext4_xattr_ibody_header *header;
 	struct ext4_inode *raw_inode;
 	struct ext4_iloc iloc;
@@ -429,7 +429,7 @@ ext4_xattr_list(struct dentry *dentry, c
 {
 	int ret, ret2;
 
-	down_read(&EXT4_I(dentry->d_inode)->xattr_sem);
+	down_read(&EXT4_I(d_inode(dentry))->xattr_sem);
 	ret = ret2 = ext4_xattr_ibody_list(dentry, buffer, buffer_size);
 	if (ret < 0)
 		goto errout;
@@ -442,7 +442,7 @@ ext4_xattr_list(struct dentry *dentry, c
 		goto errout;
 	ret += ret2;
 errout:
-	up_read(&EXT4_I(dentry->d_inode)->xattr_sem);
+	up_read(&EXT4_I(d_inode(dentry))->xattr_sem);
 	return ret;
 }
 
diff -u -p a/ext4/xattr_security.c b/ext4/xattr_security.c
--- a/ext4/xattr_security.c
+++ b/ext4/xattr_security.c
@@ -34,7 +34,7 @@ ext4_xattr_security_get(struct dentry *d
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext4_xattr_get(dentry->d_inode, EXT4_XATTR_INDEX_SECURITY,
+	return ext4_xattr_get(d_inode(dentry), EXT4_XATTR_INDEX_SECURITY,
 			      name, buffer, size);
 }
 
@@ -44,7 +44,7 @@ ext4_xattr_security_set(struct dentry *d
 {
 	if (strcmp(name, "") == 0)
 		return -EINVAL;
-	return ext4_xattr_set(dentry->d_inode, EXT4_XATTR_INDEX_SECURITY,
+	return ext4_xattr_set(d_inode(dentry), EXT4_XATTR_INDEX_SECURITY,
 			      name, value, size, flags);
 }
 
diff -u -p a/attr.c b/attr.c
--- a/attr.c
+++ b/attr.c
@@ -164,7 +164,7 @@ EXPORT_SYMBOL(setattr_copy);
 
 int notify_change(struct dentry * dentry, struct iattr * attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	mode_t mode = inode->i_mode;
 	int error;
 	struct timespec now;
@@ -233,7 +233,7 @@ int notify_change(struct dentry * dentry
 		return error;
 
 	if (ia_valid & ATTR_SIZE)
-		down_write(&dentry->d_inode->i_alloc_sem);
+		down_write(&d_inode(dentry)->i_alloc_sem);
 
 	if (inode->i_op->setattr)
 		error = inode->i_op->setattr(dentry, attr);
@@ -241,7 +241,7 @@ int notify_change(struct dentry * dentry
 		error = simple_setattr(dentry, attr);
 
 	if (ia_valid & ATTR_SIZE)
-		up_write(&dentry->d_inode->i_alloc_sem);
+		up_write(&d_inode(dentry)->i_alloc_sem);
 
 	if (!error)
 		fsnotify_change(dentry, ia_valid);
diff -u -p a/9p/vfs_super.c b/9p/vfs_super.c
--- a/9p/vfs_super.c
+++ b/9p/vfs_super.c
@@ -169,8 +169,8 @@ static struct dentry *v9fs_mount(struct
 			retval = PTR_ERR(st);
 			goto release_sb;
 		}
-		root->d_inode->i_ino = v9fs_qid2ino(&st->qid);
-		v9fs_stat2inode_dotl(st, root->d_inode);
+		d_inode(root)->i_ino = v9fs_qid2ino(&st->qid);
+		v9fs_stat2inode_dotl(st, d_inode(root));
 		kfree(st);
 	} else {
 		struct p9_wstat *st = NULL;
@@ -180,8 +180,8 @@ static struct dentry *v9fs_mount(struct
 			goto release_sb;
 		}
 
-		root->d_inode->i_ino = v9fs_qid2ino(&st->qid);
-		v9fs_stat2inode(st, root->d_inode, sb);
+		d_inode(root)->i_ino = v9fs_qid2ino(&st->qid);
+		v9fs_stat2inode(st, d_inode(root), sb);
 
 		p9stat_free(st);
 		kfree(st);
diff -u -p a/9p/vfs_inode_dotl.c b/9p/vfs_inode_dotl.c
--- a/9p/vfs_inode_dotl.c
+++ b/9p/vfs_inode_dotl.c
@@ -398,7 +398,7 @@ v9fs_vfs_getattr_dotl(struct vfsmount *m
 	err = -EPERM;
 	v9ses = v9fs_dentry2v9ses(dentry);
 	if (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {
-		generic_fillattr(dentry->d_inode, stat);
+		generic_fillattr(d_inode(dentry), stat);
 		return 0;
 	}
 	fid = v9fs_fid_lookup(dentry);
@@ -413,8 +413,8 @@ v9fs_vfs_getattr_dotl(struct vfsmount *m
 	if (IS_ERR(st))
 		return PTR_ERR(st);
 
-	v9fs_stat2inode_dotl(st, dentry->d_inode);
-	generic_fillattr(dentry->d_inode, stat);
+	v9fs_stat2inode_dotl(st, d_inode(dentry));
+	generic_fillattr(d_inode(dentry), stat);
 	/* Change block size to what the server returned */
 	stat->blksize = st->st_blksize;
 
@@ -438,7 +438,7 @@ int v9fs_vfs_setattr_dotl(struct dentry
 
 	P9_DPRINTK(P9_DEBUG_VFS, "\n");
 
-	retval = inode_change_ok(dentry->d_inode, iattr);
+	retval = inode_change_ok(d_inode(dentry), iattr);
 	if (retval)
 		return retval;
 
@@ -459,20 +459,20 @@ int v9fs_vfs_setattr_dotl(struct dentry
 		return PTR_ERR(fid);
 
 	/* Write all dirty data */
-	if (S_ISREG(dentry->d_inode->i_mode))
-		filemap_write_and_wait(dentry->d_inode->i_mapping);
+	if (S_ISREG(d_inode(dentry)->i_mode))
+		filemap_write_and_wait(d_inode(dentry)->i_mapping);
 
 	retval = p9_client_setattr(fid, &p9attr);
 	if (retval < 0)
 		return retval;
 
 	if ((iattr->ia_valid & ATTR_SIZE) &&
-	    iattr->ia_size != i_size_read(dentry->d_inode))
-		truncate_setsize(dentry->d_inode, iattr->ia_size);
+	    iattr->ia_size != i_size_read(d_inode(dentry)))
+		truncate_setsize(d_inode(dentry), iattr->ia_size);
 
-	v9fs_invalidate_inode_attr(dentry->d_inode);
-	setattr_copy(dentry->d_inode, iattr);
-	mark_inode_dirty(dentry->d_inode);
+	v9fs_invalidate_inode_attr(d_inode(dentry));
+	setattr_copy(d_inode(dentry), iattr);
+	mark_inode_dirty(d_inode(dentry));
 	if (iattr->ia_valid & ATTR_MODE) {
 		/* We also want to update ACL when we update mode bits */
 		retval = v9fs_acl_chmod(dentry);
@@ -681,10 +681,10 @@ v9fs_vfs_link_dotl(struct dentry *old_de
 		if (IS_ERR(fid))
 			return PTR_ERR(fid);
 
-		v9fs_refresh_inode_dotl(fid, old_dentry->d_inode);
+		v9fs_refresh_inode_dotl(fid, d_inode(old_dentry));
 	}
-	ihold(old_dentry->d_inode);
-	d_instantiate(dentry, old_dentry->d_inode);
+	ihold(d_inode(old_dentry));
+	d_instantiate(dentry, d_inode(old_dentry));
 
 	return err;
 }
diff -u -p a/9p/vfs_inode.c b/9p/vfs_inode.c
--- a/9p/vfs_inode.c
+++ b/9p/vfs_inode.c
@@ -506,7 +506,7 @@ static int v9fs_remove(struct inode *dir
 	P9_DPRINTK(P9_DEBUG_VFS, "inode: %p dentry: %p rmdir: %d\n", dir, file,
 		rmdir);
 
-	file_inode = file->d_inode;
+	file_inode = d_inode(file);
 	v9fid = v9fs_fid_clone(file);
 	if (IS_ERR(v9fid))
 		return PTR_ERR(v9fid);
@@ -650,7 +650,7 @@ v9fs_vfs_create(struct inode *dir, struc
 	v9fs_invalidate_inode_attr(dir);
 	/* if we are opening a file, assign the open fid to the file */
 	if (nd && nd->flags & LOOKUP_OPEN) {
-		v9inode = V9FS_I(dentry->d_inode);
+		v9inode = V9FS_I(d_inode(dentry));
 		mutex_lock(&v9inode->v_mutex);
 		if (v9ses->cache && !v9inode->writeback_fid &&
 		    ((flags & O_ACCMODE) != O_RDONLY)) {
@@ -679,7 +679,7 @@ v9fs_vfs_create(struct inode *dir, struc
 		filp->private_data = fid;
 #ifdef CONFIG_9P_FSCACHE
 		if (v9ses->cache)
-			v9fs_cache_inode_set_cookie(dentry->d_inode, filp);
+			v9fs_cache_inode_set_cookie(d_inode(dentry), filp);
 #endif
 	} else
 		p9_client_clunk(fid);
@@ -841,8 +841,8 @@ v9fs_vfs_rename(struct inode *old_dir, s
 
 	P9_DPRINTK(P9_DEBUG_VFS, "\n");
 	retval = 0;
-	old_inode = old_dentry->d_inode;
-	new_inode = new_dentry->d_inode;
+	old_inode = d_inode(old_dentry);
+	new_inode = d_inode(new_dentry);
 	v9ses = v9fs_inode2v9ses(old_inode);
 	oldfid = v9fs_fid_lookup(old_dentry);
 	if (IS_ERR(oldfid))
@@ -938,7 +938,7 @@ v9fs_vfs_getattr(struct vfsmount *mnt, s
 	err = -EPERM;
 	v9ses = v9fs_dentry2v9ses(dentry);
 	if (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {
-		generic_fillattr(dentry->d_inode, stat);
+		generic_fillattr(d_inode(dentry), stat);
 		return 0;
 	}
 	fid = v9fs_fid_lookup(dentry);
@@ -949,8 +949,8 @@ v9fs_vfs_getattr(struct vfsmount *mnt, s
 	if (IS_ERR(st))
 		return PTR_ERR(st);
 
-	v9fs_stat2inode(st, dentry->d_inode, dentry->d_inode->i_sb);
-		generic_fillattr(dentry->d_inode, stat);
+	v9fs_stat2inode(st, d_inode(dentry), d_inode(dentry)->i_sb);
+		generic_fillattr(d_inode(dentry), stat);
 
 	p9stat_free(st);
 	kfree(st);
@@ -972,7 +972,7 @@ static int v9fs_vfs_setattr(struct dentr
 	struct p9_wstat wstat;
 
 	P9_DPRINTK(P9_DEBUG_VFS, "\n");
-	retval = inode_change_ok(dentry->d_inode, iattr);
+	retval = inode_change_ok(d_inode(dentry), iattr);
 	if (retval)
 		return retval;
 
@@ -1004,21 +1004,21 @@ static int v9fs_vfs_setattr(struct dentr
 	}
 
 	/* Write all dirty data */
-	if (S_ISREG(dentry->d_inode->i_mode))
-		filemap_write_and_wait(dentry->d_inode->i_mapping);
+	if (S_ISREG(d_inode(dentry)->i_mode))
+		filemap_write_and_wait(d_inode(dentry)->i_mapping);
 
 	retval = p9_client_wstat(fid, &wstat);
 	if (retval < 0)
 		return retval;
 
 	if ((iattr->ia_valid & ATTR_SIZE) &&
-	    iattr->ia_size != i_size_read(dentry->d_inode))
-		truncate_setsize(dentry->d_inode, iattr->ia_size);
+	    iattr->ia_size != i_size_read(d_inode(dentry)))
+		truncate_setsize(d_inode(dentry), iattr->ia_size);
 
-	v9fs_invalidate_inode_attr(dentry->d_inode);
+	v9fs_invalidate_inode_attr(d_inode(dentry));
 
-	setattr_copy(dentry->d_inode, iattr);
-	mark_inode_dirty(dentry->d_inode);
+	setattr_copy(d_inode(dentry), iattr);
+	mark_inode_dirty(d_inode(dentry));
 	return 0;
 }
 
@@ -1304,7 +1304,7 @@ v9fs_vfs_link(struct dentry *old_dentry,
 	retval = v9fs_vfs_mkspecial(dir, dentry, P9_DMLINK, name);
 	__putname(name);
 	if (!retval) {
-		v9fs_refresh_inode(oldfid, old_dentry->d_inode);
+		v9fs_refresh_inode(oldfid, d_inode(old_dentry));
 		v9fs_invalidate_inode_attr(dir);
 	}
 clunk_fid:
diff -u -p a/9p/acl.c b/9p/acl.c
--- a/9p/acl.c
+++ b/9p/acl.c
@@ -131,7 +131,7 @@ static int v9fs_set_acl(struct dentry *d
 	char *name;
 	size_t size;
 	void *buffer;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	set_cached_acl(inode, type, acl);
 
@@ -166,7 +166,7 @@ int v9fs_acl_chmod(struct dentry *dentry
 {
 	int retval = 0;
 	struct posix_acl *acl, *clone;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	if (S_ISLNK(inode->i_mode))
 		return -EOPNOTSUPP;
@@ -269,7 +269,7 @@ static int v9fs_xattr_get_acl(struct den
 	if ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT)
 		return v9fs_remote_get_acl(dentry, name, buffer, size, type);
 
-	acl = v9fs_get_cached_acl(dentry->d_inode, type);
+	acl = v9fs_get_cached_acl(d_inode(dentry), type);
 	if (IS_ERR(acl))
 		return PTR_ERR(acl);
 	if (acl == NULL)
@@ -307,7 +307,7 @@ static int v9fs_xattr_set_acl(struct den
 	int retval;
 	struct posix_acl *acl;
 	struct v9fs_session_info *v9ses;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	if (strcmp(name, "") != 0)
 		return -EINVAL;
diff -u -p a/9p/vfs_file.c b/9p/vfs_file.c
--- a/9p/vfs_file.c
+++ b/9p/vfs_file.c
@@ -133,7 +133,7 @@ out_error:
 static int v9fs_file_lock(struct file *filp, int cmd, struct file_lock *fl)
 {
 	int res = 0;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 
 	P9_DPRINTK(P9_DEBUG_VFS, "filp: %p lock: %p\n", filp, fl);
 
@@ -281,7 +281,7 @@ static int v9fs_file_getlock(struct file
 
 static int v9fs_file_lock_dotl(struct file *filp, int cmd, struct file_lock *fl)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	int ret = -ENOLCK;
 
 	P9_DPRINTK(P9_DEBUG_VFS, "filp: %p cmd:%d lock: %p name: %s\n", filp,
@@ -317,7 +317,7 @@ out_err:
 static int v9fs_file_flock_dotl(struct file *filp, int cmd,
 	struct file_lock *fl)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	int ret = -ENOLCK;
 
 	P9_DPRINTK(P9_DEBUG_VFS, "filp: %p cmd:%d lock: %p name: %s\n", filp,
@@ -508,9 +508,9 @@ v9fs_file_write(struct file *filp, const
 	if (!count)
 		goto out;
 
-	retval = v9fs_file_write_internal(filp->f_path.dentry->d_inode,
-					filp->private_data,
-					data, count, &origin, 1);
+	retval = v9fs_file_write_internal(d_inode(filp->f_path.dentry),
+					  filp->private_data,
+					  data, count, &origin, 1);
 	/* update offset on successful write */
 	if (retval > 0)
 		*offset = origin;
@@ -566,7 +566,7 @@ v9fs_vm_page_mkwrite(struct vm_area_stru
 	struct v9fs_inode *v9inode;
 	struct page *page = vmf->page;
 	struct file *filp = vma->vm_file;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 
 
 	P9_DPRINTK(P9_DEBUG_VFS, "page %p fid %lx\n",
diff -u -p a/9p/vfs_dentry.c b/9p/vfs_dentry.c
--- a/9p/vfs_dentry.c
+++ b/9p/vfs_dentry.c
@@ -70,7 +70,7 @@ static int v9fs_cached_dentry_delete(con
 		   dentry->d_name.name, dentry);
 
 	/* Don't cache negative dentries */
-	if (!dentry->d_inode)
+	if (!d_inode(dentry))
 		return 1;
 	return 0;
 }
@@ -109,7 +109,7 @@ static int v9fs_lookup_revalidate(struct
 	if (nd->flags & LOOKUP_RCU)
 		return -ECHILD;
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	if (!inode)
 		goto out_valid;
 
diff -u -p a/quota/dquot.c b/quota/dquot.c
--- a/quota/dquot.c
+++ b/quota/dquot.c
@@ -2202,7 +2202,7 @@ int dquot_quota_on(struct super_block *s
 	if (path->mnt->mnt_sb != sb)
 		error = -EXDEV;
 	else
-		error = vfs_load_quota_inode(path->dentry->d_inode, type,
+		error = vfs_load_quota_inode(d_inode(path->dentry), type,
 					     format_id, DQUOT_USAGE_ENABLED |
 					     DQUOT_LIMITS_ENABLED);
 	return error;
@@ -2266,21 +2266,21 @@ int dquot_quota_on_mount(struct super_bl
 	struct dentry *dentry;
 	int error;
 
-	mutex_lock(&sb->s_root->d_inode->i_mutex);
+	mutex_lock(&d_inode(sb->s_root)->i_mutex);
 	dentry = lookup_one_len(qf_name, sb->s_root, strlen(qf_name));
-	mutex_unlock(&sb->s_root->d_inode->i_mutex);
+	mutex_unlock(&d_inode(sb->s_root)->i_mutex);
 	if (IS_ERR(dentry))
 		return PTR_ERR(dentry);
 
-	if (!dentry->d_inode) {
+	if (!d_inode(dentry)) {
 		error = -ENOENT;
 		goto out;
 	}
 
 	error = security_quota_on(dentry);
 	if (!error)
-		error = vfs_load_quota_inode(dentry->d_inode, type, format_id,
-				DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
+		error = vfs_load_quota_inode(d_inode(dentry), type, format_id,
+					     DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
 
 out:
 	dput(dentry);
diff -u -p a/minix/inode.c b/minix/inode.c
--- a/minix/inode.c
+++ b/minix/inode.c
@@ -596,10 +596,10 @@ static int minix_write_inode(struct inod
 
 int minix_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	struct super_block *sb = dir->i_sb;
-	generic_fillattr(dentry->d_inode, stat);
-	if (INODE_VERSION(dentry->d_inode) == MINIX_V1)
+	generic_fillattr(d_inode(dentry), stat);
+	if (INODE_VERSION(d_inode(dentry)) == MINIX_V1)
 		stat->blocks = (BLOCK_SIZE / 512) * V1_minix_blocks(stat->size, sb);
 	else
 		stat->blocks = (sb->s_blocksize / 512) * V2_minix_blocks(stat->size, sb);
diff -u -p a/minix/file.c b/minix/file.c
--- a/minix/file.c
+++ b/minix/file.c
@@ -25,7 +25,7 @@ const struct file_operations minix_file_
 
 static int minix_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	error = inode_change_ok(inode, attr);
diff -u -p a/minix/namei.c b/minix/namei.c
--- a/minix/namei.c
+++ b/minix/namei.c
@@ -92,7 +92,7 @@ out_fail:
 static int minix_link(struct dentry * old_dentry, struct inode * dir,
 	struct dentry *dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 
 	if (inode->i_nlink >= minix_sb(inode->i_sb)->s_link_max)
 		return -EMLINK;
@@ -145,7 +145,7 @@ out_dir:
 static int minix_unlink(struct inode * dir, struct dentry *dentry)
 {
 	int err = -ENOENT;
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	struct page * page;
 	struct minix_dir_entry * de;
 
@@ -165,7 +165,7 @@ end_unlink:
 
 static int minix_rmdir(struct inode * dir, struct dentry *dentry)
 {
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	int err = -ENOTEMPTY;
 
 	if (minix_empty_dir(inode)) {
@@ -182,8 +182,8 @@ static int minix_rename(struct inode * o
 			   struct inode * new_dir, struct dentry *new_dentry)
 {
 	struct minix_sb_info * info = minix_sb(old_dir->i_sb);
-	struct inode * old_inode = old_dentry->d_inode;
-	struct inode * new_inode = new_dentry->d_inode;
+	struct inode * old_inode = d_inode(old_dentry);
+	struct inode * new_inode = d_inode(new_dentry);
 	struct page * dir_page = NULL;
 	struct minix_dir_entry * dir_de = NULL;
 	struct page * old_page;
diff -u -p a/minix/dir.c b/minix/dir.c
--- a/minix/dir.c
+++ b/minix/dir.c
@@ -85,7 +85,7 @@ static inline void *minix_next_entry(voi
 static int minix_readdir(struct file * filp, void * dirent, filldir_t filldir)
 {
 	unsigned long pos = filp->f_pos;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct super_block *sb = inode->i_sb;
 	unsigned offset = pos & ~PAGE_CACHE_MASK;
 	unsigned long n = pos >> PAGE_CACHE_SHIFT;
@@ -160,7 +160,7 @@ minix_dirent *minix_find_entry(struct de
 {
 	const char * name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
-	struct inode * dir = dentry->d_parent->d_inode;
+	struct inode * dir = d_inode(dentry->d_parent);
 	struct super_block * sb = dir->i_sb;
 	struct minix_sb_info * sbi = minix_sb(sb);
 	unsigned long n;
@@ -207,7 +207,7 @@ found:
 
 int minix_add_link(struct dentry *dentry, struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	const char * name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
 	struct super_block * sb = dir->i_sb;
diff -u -p a/ioctl.c b/ioctl.c
--- a/ioctl.c
+++ b/ioctl.c
@@ -175,7 +175,7 @@ static int ioctl_fiemap(struct file *fil
 	struct fiemap fiemap;
 	struct fiemap __user *ufiemap = (struct fiemap __user *) arg;
 	struct fiemap_extent_info fieinfo = { 0, };
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct super_block *sb = inode->i_sb;
 	u64 len;
 	int error;
@@ -424,7 +424,7 @@ EXPORT_SYMBOL(generic_block_fiemap);
  */
 int ioctl_preallocate(struct file *filp, void __user *argp)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct space_resv sr;
 
 	if (copy_from_user(&sr, argp, sizeof(sr)))
@@ -449,7 +449,7 @@ int ioctl_preallocate(struct file *filp,
 static int file_ioctl(struct file *filp, unsigned int cmd,
 		unsigned long arg)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	int __user *p = (int __user *)arg;
 
 	switch (cmd) {
@@ -512,7 +512,7 @@ static int ioctl_fioasync(unsigned int f
 
 static int ioctl_fsfreeze(struct file *filp)
 {
-	struct super_block *sb = filp->f_path.dentry->d_inode->i_sb;
+	struct super_block *sb = d_inode(filp->f_path.dentry)->i_sb;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
@@ -527,7 +527,7 @@ static int ioctl_fsfreeze(struct file *f
 
 static int ioctl_fsthaw(struct file *filp)
 {
-	struct super_block *sb = filp->f_path.dentry->d_inode->i_sb;
+	struct super_block *sb = d_inode(filp->f_path.dentry)->i_sb;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
@@ -548,7 +548,7 @@ int do_vfs_ioctl(struct file *filp, unsi
 {
 	int error = 0;
 	int __user *argp = (int __user *)arg;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 
 	switch (cmd) {
 	case FIOCLEX:
diff -u -p a/binfmt_misc.c b/binfmt_misc.c
--- a/binfmt_misc.c
+++ b/binfmt_misc.c
@@ -522,7 +522,7 @@ static void kill_node(Node *e)
 	write_unlock(&entries_lock);
 
 	if (dentry) {
-		dentry->d_inode->i_nlink--;
+		d_inode(dentry)->i_nlink--;
 		d_drop(dentry);
 		dput(dentry);
 		simple_release_fs(&bm_mnt, &entry_count);
@@ -534,7 +534,7 @@ static void kill_node(Node *e)
 static ssize_t
 bm_entry_read(struct file * file, char __user * buf, size_t nbytes, loff_t *ppos)
 {
-	Node *e = file->f_path.dentry->d_inode->i_private;
+	Node *e = d_inode(file->f_path.dentry)->i_private;
 	ssize_t res;
 	char *page;
 
@@ -553,7 +553,7 @@ static ssize_t bm_entry_write(struct fil
 				size_t count, loff_t *ppos)
 {
 	struct dentry *root;
-	Node *e = file->f_path.dentry->d_inode->i_private;
+	Node *e = d_inode(file->f_path.dentry)->i_private;
 	int res = parse_command(buffer, count);
 
 	switch (res) {
@@ -562,11 +562,11 @@ static ssize_t bm_entry_write(struct fil
 		case 2: set_bit(Enabled, &e->flags);
 			break;
 		case 3: root = dget(file->f_path.mnt->mnt_sb->s_root);
-			mutex_lock(&root->d_inode->i_mutex);
+			mutex_lock(&d_inode(root)->i_mutex);
 
 			kill_node(e);
 
-			mutex_unlock(&root->d_inode->i_mutex);
+			mutex_unlock(&d_inode(root)->i_mutex);
 			dput(root);
 			break;
 		default: return res;
@@ -597,14 +597,14 @@ static ssize_t bm_register_write(struct
 		return PTR_ERR(e);
 
 	root = dget(sb->s_root);
-	mutex_lock(&root->d_inode->i_mutex);
+	mutex_lock(&d_inode(root)->i_mutex);
 	dentry = lookup_one_len(e->name, root, strlen(e->name));
 	err = PTR_ERR(dentry);
 	if (IS_ERR(dentry))
 		goto out;
 
 	err = -EEXIST;
-	if (dentry->d_inode)
+	if (d_inode(dentry))
 		goto out2;
 
 	inode = bm_get_inode(sb, S_IFREG | 0644);
@@ -633,7 +633,7 @@ static ssize_t bm_register_write(struct
 out2:
 	dput(dentry);
 out:
-	mutex_unlock(&root->d_inode->i_mutex);
+	mutex_unlock(&d_inode(root)->i_mutex);
 	dput(root);
 
 	if (err) {
@@ -668,12 +668,12 @@ static ssize_t bm_status_write(struct fi
 		case 1: enabled = 0; break;
 		case 2: enabled = 1; break;
 		case 3: root = dget(file->f_path.mnt->mnt_sb->s_root);
-			mutex_lock(&root->d_inode->i_mutex);
+			mutex_lock(&d_inode(root)->i_mutex);
 
 			while (!list_empty(&entries))
 				kill_node(list_entry(entries.next, Node, list));
 
-			mutex_unlock(&root->d_inode->i_mutex);
+			mutex_unlock(&d_inode(root)->i_mutex);
 			dput(root);
 		default: return res;
 	}
diff -u -p a/libfs.c b/libfs.c
--- a/libfs.c
+++ b/libfs.c
@@ -18,13 +18,13 @@
 
 static inline int simple_positive(struct dentry *dentry)
 {
-	return dentry->d_inode && !d_unhashed(dentry);
+	return d_inode(dentry) && !d_unhashed(dentry);
 }
 
 int simple_getattr(struct vfsmount *mnt, struct dentry *dentry,
 		   struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	generic_fillattr(inode, stat);
 	stat->blocks = inode->i_mapping->nrpages << (PAGE_CACHE_SHIFT - 9);
 	return 0;
@@ -82,7 +82,7 @@ int dcache_dir_close(struct inode *inode
 loff_t dcache_dir_lseek(struct file *file, loff_t offset, int origin)
 {
 	struct dentry *dentry = file->f_path.dentry;
-	mutex_lock(&dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(dentry)->i_mutex);
 	switch (origin) {
 		case 1:
 			offset += file->f_pos;
@@ -90,7 +90,7 @@ loff_t dcache_dir_lseek(struct file *fil
 			if (offset >= 0)
 				break;
 		default:
-			mutex_unlock(&dentry->d_inode->i_mutex);
+			mutex_unlock(&d_inode(dentry)->i_mutex);
 			return -EINVAL;
 	}
 	if (offset != file->f_pos) {
@@ -117,7 +117,7 @@ loff_t dcache_dir_lseek(struct file *fil
 			spin_unlock(&dentry->d_lock);
 		}
 	}
-	mutex_unlock(&dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dentry)->i_mutex);
 	return offset;
 }
 
@@ -143,7 +143,7 @@ int dcache_readdir(struct file * filp, v
 
 	switch (i) {
 		case 0:
-			ino = dentry->d_inode->i_ino;
+			ino = d_inode(dentry)->i_ino;
 			if (filldir(dirent, ".", 1, i, ino, DT_DIR) < 0)
 				break;
 			filp->f_pos++;
@@ -174,8 +174,8 @@ int dcache_readdir(struct file * filp, v
 				spin_unlock(&dentry->d_lock);
 				if (filldir(dirent, next->d_name.name, 
 					    next->d_name.len, filp->f_pos, 
-					    next->d_inode->i_ino, 
-					    dt_type(next->d_inode)) < 0)
+					    d_inode(next)->i_ino, 
+					    dt_type(d_inode(next))) < 0)
 					return 0;
 				spin_lock(&dentry->d_lock);
 				spin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);
@@ -266,7 +266,7 @@ Enomem:
 
 int simple_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 
 	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
 	inc_nlink(inode);
@@ -298,7 +298,7 @@ out:
 
 int simple_unlink(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 
 	inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
 	drop_nlink(inode);
@@ -311,7 +311,7 @@ int simple_rmdir(struct inode *dir, stru
 	if (!simple_empty(dentry))
 		return -ENOTEMPTY;
 
-	drop_nlink(dentry->d_inode);
+	drop_nlink(d_inode(dentry));
 	simple_unlink(dir, dentry);
 	drop_nlink(dir);
 	return 0;
@@ -320,13 +320,13 @@ int simple_rmdir(struct inode *dir, stru
 int simple_rename(struct inode *old_dir, struct dentry *old_dentry,
 		struct inode *new_dir, struct dentry *new_dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
-	int they_are_dirs = S_ISDIR(old_dentry->d_inode->i_mode);
+	struct inode *inode = d_inode(old_dentry);
+	int they_are_dirs = S_ISDIR(d_inode(old_dentry)->i_mode);
 
 	if (!simple_empty(new_dentry))
 		return -ENOTEMPTY;
 
-	if (new_dentry->d_inode) {
+	if (d_inode(new_dentry)) {
 		simple_unlink(new_dir, new_dentry);
 		if (they_are_dirs)
 			drop_nlink(old_dir);
@@ -357,7 +357,7 @@ int simple_rename(struct inode *old_dir,
  */
 int simple_setattr(struct dentry *dentry, struct iattr *iattr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	WARN_ON_ONCE(inode->i_op->truncate);
diff -u -p a/ubifs/journal.c b/ubifs/journal.c
--- a/ubifs/journal.c
+++ b/ubifs/journal.c
@@ -927,8 +927,8 @@ int ubifs_jnl_rename(struct ubifs_info *
 	union ubifs_key key;
 	struct ubifs_dent_node *dent, *dent2;
 	int err, dlen1, dlen2, ilen, lnum, offs, len;
-	const struct inode *old_inode = old_dentry->d_inode;
-	const struct inode *new_inode = new_dentry->d_inode;
+	const struct inode *old_inode = d_inode(old_dentry);
+	const struct inode *new_inode = d_inode(new_dentry);
 	int aligned_dlen1, aligned_dlen2, plen = UBIFS_INO_NODE_SZ;
 	int last_reference = !!(new_inode && new_inode->i_nlink == 0);
 	int move = (old_dir != new_dir);
diff -u -p a/ubifs/file.c b/ubifs/file.c
--- a/ubifs/file.c
+++ b/ubifs/file.c
@@ -1254,7 +1254,7 @@ static int do_setattr(struct ubifs_info
 int ubifs_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	int err;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ubifs_info *c = inode->i_sb->s_fs_info;
 
 	dbg_gen("ino %lu, mode %#x, ia_valid %#x",
@@ -1298,7 +1298,7 @@ static void ubifs_invalidatepage(struct
 
 static void *ubifs_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct ubifs_inode *ui = ubifs_inode(dentry->d_inode);
+	struct ubifs_inode *ui = ubifs_inode(d_inode(dentry));
 
 	nd_set_link(nd, ui->data);
 	return NULL;
@@ -1443,7 +1443,7 @@ static int ubifs_vm_page_mkwrite(struct
 				 struct vm_fault *vmf)
 {
 	struct page *page = vmf->page;
-	struct inode *inode = vma->vm_file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(vma->vm_file->f_path.dentry);
 	struct ubifs_info *c = inode->i_sb->s_fs_info;
 	struct timespec now = ubifs_current_time(inode);
 	struct ubifs_budget_req req = { .new_page = 1 };
diff -u -p a/ubifs/dir.c b/ubifs/dir.c
--- a/ubifs/dir.c
+++ b/ubifs/dir.c
@@ -358,7 +358,7 @@ static int ubifs_readdir(struct file *fi
 	struct qstr nm;
 	union ubifs_key key;
 	struct ubifs_dent_node *dent;
-	struct inode *dir = file->f_path.dentry->d_inode;
+	struct inode *dir = d_inode(file->f_path.dentry);
 	struct ubifs_info *c = dir->i_sb->s_fs_info;
 
 	dbg_gen("dir ino %lu, f_pos %#llx", dir->i_ino, file->f_pos);
@@ -504,7 +504,7 @@ static int ubifs_link(struct dentry *old
 		      struct dentry *dentry)
 {
 	struct ubifs_info *c = dir->i_sb->s_fs_info;
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	struct ubifs_inode *ui = ubifs_inode(inode);
 	struct ubifs_inode *dir_ui = ubifs_inode(dir);
 	int err, sz_change = CALC_DENT_SIZE(dentry->d_name.len);
@@ -559,7 +559,7 @@ out_cancel:
 static int ubifs_unlink(struct inode *dir, struct dentry *dentry)
 {
 	struct ubifs_info *c = dir->i_sb->s_fs_info;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ubifs_inode *dir_ui = ubifs_inode(dir);
 	int sz_change = CALC_DENT_SIZE(dentry->d_name.len);
 	int err, budgeted = 1;
@@ -650,7 +650,7 @@ static int check_dir_empty(struct ubifs_
 static int ubifs_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	struct ubifs_info *c = dir->i_sb->s_fs_info;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int sz_change = CALC_DENT_SIZE(dentry->d_name.len);
 	int err, budgeted = 1;
 	struct ubifs_inode *dir_ui = ubifs_inode(dir);
@@ -666,7 +666,7 @@ static int ubifs_rmdir(struct inode *dir
 		dentry->d_name.name, inode->i_ino, dir->i_ino);
 	ubifs_assert(mutex_is_locked(&dir->i_mutex));
 	ubifs_assert(mutex_is_locked(&inode->i_mutex));
-	err = check_dir_empty(c, dentry->d_inode);
+	err = check_dir_empty(c, d_inode(dentry));
 	if (err)
 		return err;
 
@@ -962,8 +962,8 @@ static int ubifs_rename(struct inode *ol
 			struct inode *new_dir, struct dentry *new_dentry)
 {
 	struct ubifs_info *c = old_dir->i_sb->s_fs_info;
-	struct inode *old_inode = old_dentry->d_inode;
-	struct inode *new_inode = new_dentry->d_inode;
+	struct inode *old_inode = d_inode(old_dentry);
+	struct inode *new_inode = d_inode(new_dentry);
 	struct ubifs_inode *old_inode_ui = ubifs_inode(old_inode);
 	int err, release, sync = 0, move = (new_dir != old_dir);
 	int is_dir = S_ISDIR(old_inode->i_mode);
@@ -1129,7 +1129,7 @@ int ubifs_getattr(struct vfsmount *mnt,
 		  struct kstat *stat)
 {
 	loff_t size;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ubifs_inode *ui = ubifs_inode(inode);
 
 	mutex_lock(&ui->ui_mutex);
diff -u -p a/ubifs/ioctl.c b/ubifs/ioctl.c
--- a/ubifs/ioctl.c
+++ b/ubifs/ioctl.c
@@ -147,7 +147,7 @@ out_unlock:
 long ubifs_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	int flags, err;
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 
 	switch (cmd) {
 	case FS_IOC_GETFLAGS:
diff -u -p a/ubifs/xattr.c b/ubifs/xattr.c
--- a/ubifs/xattr.c
+++ b/ubifs/xattr.c
@@ -298,7 +298,7 @@ static struct inode *iget_xattr(struct u
 int ubifs_setxattr(struct dentry *dentry, const char *name,
 		   const void *value, size_t size, int flags)
 {
-	struct inode *inode, *host = dentry->d_inode;
+	struct inode *inode, *host = d_inode(dentry);
 	struct ubifs_info *c = host->i_sb->s_fs_info;
 	struct qstr nm = { .name = name, .len = strlen(name) };
 	struct ubifs_dent_node *xent;
@@ -361,7 +361,7 @@ out_free:
 ssize_t ubifs_getxattr(struct dentry *dentry, const char *name, void *buf,
 		       size_t size)
 {
-	struct inode *inode, *host = dentry->d_inode;
+	struct inode *inode, *host = d_inode(dentry);
 	struct ubifs_info *c = host->i_sb->s_fs_info;
 	struct qstr nm = { .name = name, .len = strlen(name) };
 	struct ubifs_inode *ui;
@@ -421,7 +421,7 @@ out_unlock:
 ssize_t ubifs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 {
 	union ubifs_key key;
-	struct inode *host = dentry->d_inode;
+	struct inode *host = d_inode(dentry);
 	struct ubifs_info *c = host->i_sb->s_fs_info;
 	struct ubifs_inode *host_ui = ubifs_inode(host);
 	struct ubifs_dent_node *xent, *pxent = NULL;
@@ -524,7 +524,7 @@ out_cancel:
 
 int ubifs_removexattr(struct dentry *dentry, const char *name)
 {
-	struct inode *inode, *host = dentry->d_inode;
+	struct inode *inode, *host = d_inode(dentry);
 	struct ubifs_info *c = host->i_sb->s_fs_info;
 	struct qstr nm = { .name = name, .len = strlen(name) };
 	struct ubifs_dent_node *xent;
diff -u -p a/autofs4/symlink.c b/autofs4/symlink.c
--- a/autofs4/symlink.c
+++ b/autofs4/symlink.c
@@ -14,7 +14,7 @@
 
 static void *autofs4_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	nd_set_link(nd, dentry->d_inode->i_private);
+	nd_set_link(nd, d_inode(dentry)->i_private);
 	return NULL;
 }
 
diff -u -p a/autofs4/inode.c b/autofs4/inode.c
--- a/autofs4/inode.c
+++ b/autofs4/inode.c
@@ -73,7 +73,7 @@ out_kill_sb:
 static int autofs4_show_options(struct seq_file *m, struct vfsmount *mnt)
 {
 	struct autofs_sb_info *sbi = autofs4_sbi(mnt->mnt_sb);
-	struct inode *root_inode = mnt->mnt_sb->s_root->d_inode;
+	struct inode *root_inode = d_inode(mnt->mnt_sb->s_root);
 
 	if (!sbi)
 		return 0;
@@ -335,8 +335,8 @@ struct inode *autofs4_get_inode(struct s
 
 	inode->i_mode = mode;
 	if (sb->s_root) {
-		inode->i_uid = sb->s_root->d_inode->i_uid;
-		inode->i_gid = sb->s_root->d_inode->i_gid;
+		inode->i_uid = d_inode(sb->s_root)->i_uid;
+		inode->i_gid = d_inode(sb->s_root)->i_gid;
 	}
 	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
 	inode->i_ino = get_next_ino();
diff -u -p a/autofs4/dev-ioctl.c b/autofs4/dev-ioctl.c
--- a/autofs4/dev-ioctl.c
+++ b/autofs4/dev-ioctl.c
@@ -159,7 +159,7 @@ static struct autofs_sb_info *autofs_dev
 	struct inode *inode;
 
 	if (f) {
-		inode = f->f_path.dentry->d_inode;
+		inode = d_inode(f->f_path.dentry);
 		sbi = autofs4_sbi(inode->i_sb);
 	}
 	return sbi;
diff -u -p a/autofs4/root.c b/autofs4/root.c
--- a/autofs4/root.c
+++ b/autofs4/root.c
@@ -234,7 +234,7 @@ static struct dentry *autofs4_lookup_exp
 		spin_lock(&expiring->d_lock);
 
 		/* Bad luck, we've already been dentry_iput */
-		if (!expiring->d_inode)
+		if (!d_inode(expiring))
 			goto next;
 
 		qstr = &expiring->d_name;
@@ -364,7 +364,7 @@ static struct vfsmount *autofs4_d_automo
 	 * having d_mountpoint() true, so there's no need to call back
 	 * to the daemon.
 	 */
-	if (dentry->d_inode && S_ISLNK(dentry->d_inode->i_mode))
+	if (d_inode(dentry) && S_ISLNK(d_inode(dentry)->i_mode))
 		goto done;
 	if (!d_mountpoint(dentry)) {
 		/*
@@ -413,7 +413,7 @@ done:
 		spin_lock(&dentry->d_lock);
 		if ((!d_mountpoint(dentry) &&
 		    !list_empty(&dentry->d_subdirs)) ||
-		    (dentry->d_inode && S_ISLNK(dentry->d_inode->i_mode)))
+		    (d_inode(dentry) && S_ISLNK(d_inode(dentry)->i_mode)))
 			__managed_dentry_clear_automount(dentry);
 		spin_unlock(&dentry->d_lock);
 	}
@@ -590,8 +590,8 @@ static int autofs4_dir_unlink(struct ino
 	}
 	dput(ino->dentry);
 
-	dentry->d_inode->i_size = 0;
-	clear_nlink(dentry->d_inode);
+	d_inode(dentry)->i_size = 0;
+	clear_nlink(d_inode(dentry));
 
 	dir->i_mtime = CURRENT_TIME;
 
@@ -690,8 +690,8 @@ static int autofs4_dir_rmdir(struct inod
 			atomic_dec(&p_ino->count);
 	}
 	dput(ino->dentry);
-	dentry->d_inode->i_size = 0;
-	clear_nlink(dentry->d_inode);
+	d_inode(dentry)->i_size = 0;
+	clear_nlink(d_inode(dentry));
 
 	if (dir->i_nlink)
 		drop_nlink(dir);
@@ -811,9 +811,9 @@ static inline int autofs4_ask_umount(str
 */
 int is_autofs4_dentry(struct dentry *dentry)
 {
-	return dentry && dentry->d_inode &&
-		dentry->d_op == &autofs4_dentry_operations &&
-		dentry->d_fsdata != NULL;
+	return dentry && d_inode(dentry) &&
+			dentry->d_op == &autofs4_dentry_operations &&
+			dentry->d_fsdata != NULL;
 }
 
 /*
@@ -873,7 +873,7 @@ static int autofs4_root_ioctl_unlocked(s
 static long autofs4_root_ioctl(struct file *filp,
 			       unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = filp->f_dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_dentry);
 	return autofs4_root_ioctl_unlocked(inode, filp, cmd, arg);
 }
 
@@ -881,7 +881,7 @@ static long autofs4_root_ioctl(struct fi
 static long autofs4_root_compat_ioctl(struct file *filp,
 			     unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	int ret;
 
 	if (cmd == AUTOFS_IOC_READY || cmd == AUTOFS_IOC_FAIL)
diff -u -p a/autofs4/waitq.c b/autofs4/waitq.c
--- a/autofs4/waitq.c
+++ b/autofs4/waitq.c
@@ -320,7 +320,7 @@ static int validate_request(struct autof
 		 * continue on and create a new request.
 		 */
 		if (!IS_ROOT(dentry)) {
-			if (dentry->d_inode && d_unhashed(dentry)) {
+			if (d_inode(dentry) && d_unhashed(dentry)) {
 				struct dentry *parent = dentry->d_parent;
 				new = d_lookup(parent, &dentry->d_name);
 				if (new)
@@ -350,7 +350,7 @@ int autofs4_wait(struct autofs_sb_info *
 	if (sbi->catatonic)
 		return -ENOENT;
 
-	if (!dentry->d_inode) {
+	if (!d_inode(dentry)) {
 		/*
 		 * A wait for a negative dentry is invalid for certain
 		 * cases. A direct or offset mount "always" has its mount
diff -u -p a/block_dev.c b/block_dev.c
--- a/block_dev.c
+++ b/block_dev.c
@@ -1615,7 +1615,7 @@ struct block_device *lookup_bdev(const c
 	if (error)
 		return ERR_PTR(error);
 
-	inode = path.dentry->d_inode;
+	inode = d_inode(path.dentry);
 	error = -ENOTBLK;
 	if (!S_ISBLK(inode->i_mode))
 		goto fail;
diff -u -p a/nfsd/nfs2acl.c b/nfsd/nfs2acl.c
--- a/nfsd/nfs2acl.c
+++ b/nfsd/nfs2acl.c
@@ -60,7 +60,7 @@ static __be32 nfsacld_proc_getacl(struct
 		if (acl == NULL) {
 			/* Solaris returns the inode's minimum ACL. */
 
-			struct inode *inode = fh->fh_dentry->d_inode;
+			struct inode *inode = d_inode(fh->fh_dentry);
 			acl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);
 		}
 		resp->acl_access = acl;
@@ -240,9 +240,9 @@ static int nfsaclsvc_encode_getaclres(st
 	 * nfsd_dispatch actually ensures the following cannot happen.
 	 * However, it seems fragile to depend on that.
 	 */
-	if (dentry == NULL || dentry->d_inode == NULL)
+	if (dentry == NULL || d_inode(dentry) == NULL)
 		return 0;
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	p = nfs2svc_encode_fattr(rqstp, p, &resp->fh);
 	*p++ = htonl(resp->mask);
diff -u -p a/nfsd/nfs3proc.c b/nfsd/nfs3proc.c
--- a/nfsd/nfs3proc.c
+++ b/nfsd/nfs3proc.c
@@ -173,7 +173,7 @@ nfsd3_proc_read(struct svc_rqst *rqstp,
 			   	  rqstp->rq_vec, argp->vlen,
 				  &resp->count);
 	if (nfserr == 0) {
-		struct inode	*inode = resp->fh.fh_dentry->d_inode;
+		struct inode	*inode = d_inode(resp->fh.fh_dentry);
 
 		resp->eof = (argp->offset + resp->count) >= inode->i_size;
 	}
@@ -556,7 +556,7 @@ nfsd3_proc_fsinfo(struct svc_rqst * rqst
 	 * different read/write sizes for file systems known to have
 	 * problems with large blocks */
 	if (nfserr == 0) {
-		struct super_block *sb = argp->fh.fh_dentry->d_inode->i_sb;
+		struct super_block *sb = d_inode(argp->fh.fh_dentry)->i_sb;
 
 		/* Note that we don't care for remote fs's here */
 		if (sb->s_magic == MSDOS_SUPER_MAGIC) {
@@ -592,7 +592,7 @@ nfsd3_proc_pathconf(struct svc_rqst * rq
 	nfserr = fh_verify(rqstp, &argp->fh, 0, NFSD_MAY_NOP);
 
 	if (nfserr == 0) {
-		struct super_block *sb = argp->fh.fh_dentry->d_inode->i_sb;
+		struct super_block *sb = d_inode(argp->fh.fh_dentry)->i_sb;
 
 		/* Note that we don't care for remote fs's here */
 		switch (sb->s_magic) {
diff -u -p a/nfsd/vfs.c b/nfsd/vfs.c
--- a/nfsd/vfs.c
+++ b/nfsd/vfs.c
@@ -170,7 +170,7 @@ int nfsd_mountpoint(struct dentry *dentr
 		return 1;
 	if (!(exp->ex_flags & NFSEXP_V4ROOT))
 		return 0;
-	return dentry->d_inode != NULL;
+	return d_inode(dentry) != NULL;
 }
 
 __be32
@@ -262,7 +262,7 @@ nfsd_lookup(struct svc_rqst *rqstp, stru
 	 * dentry may be negative, it may need to be updated.
 	 */
 	err = fh_compose(resfh, exp, dentry, fhp);
-	if (!err && !dentry->d_inode)
+	if (!err && !d_inode(dentry))
 		err = nfserr_noent;
 out:
 	dput(dentry);
@@ -283,7 +283,7 @@ static int nfsd_break_lease(struct inode
 static int
 commit_metadata(struct svc_fh *fhp)
 {
-	struct inode *inode = fhp->fh_dentry->d_inode;
+	struct inode *inode = d_inode(fhp->fh_dentry);
 	const struct export_operations *export_ops = inode->i_sb->s_export_op;
 
 	if (!EX_ISSYNC(fhp->fh_export))
@@ -321,7 +321,7 @@ nfsd_setattr(struct svc_rqst *rqstp, str
 		goto out;
 
 	dentry = fhp->fh_dentry;
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	/* Ignore any mode updates on symlinks */
 	if (S_ISLNK(inode->i_mode))
@@ -507,7 +507,7 @@ nfsd4_set_nfs4_acl(struct svc_rqst *rqst
 		return error;
 
 	dentry = fhp->fh_dentry;
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	if (S_ISDIR(inode->i_mode))
 		flags = NFS4_ACL_DIR;
 
@@ -555,7 +555,7 @@ _get_posix_acl(struct dentry *dentry, ch
 int
 nfsd4_get_nfs4_acl(struct svc_rqst *rqstp, struct dentry *dentry, struct nfs4_acl **acl)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error = 0;
 	struct posix_acl *pacl = NULL, *dpacl = NULL;
 	unsigned int flags = 0;
@@ -653,9 +653,9 @@ nfsd_access(struct svc_rqst *rqstp, stru
 	export = fhp->fh_export;
 	dentry = fhp->fh_dentry;
 
-	if (S_ISREG(dentry->d_inode->i_mode))
+	if (S_ISREG(d_inode(dentry)->i_mode))
 		map = nfs3_regaccess;
-	else if (S_ISDIR(dentry->d_inode->i_mode))
+	else if (S_ISDIR(d_inode(dentry)->i_mode))
 		map = nfs3_diraccess;
 	else
 		map = nfs3_anyaccess;
@@ -733,7 +733,7 @@ nfsd_open(struct svc_rqst *rqstp, struct
 		goto out;
 
 	dentry = fhp->fh_dentry;
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	/* Disallow write access to files with the append-only bit set
 	 * or any access when mandatory locking enabled
@@ -915,9 +915,9 @@ static void kill_suid(struct dentry *den
 	struct iattr	ia;
 	ia.ia_valid = ATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;
 
-	mutex_lock(&dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(dentry)->i_mutex);
 	notify_change(dentry, &ia);
-	mutex_unlock(&dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dentry)->i_mutex);
 }
 
 /*
@@ -936,7 +936,7 @@ static void kill_suid(struct dentry *den
  */
 static int wait_for_concurrent_writes(struct file *file)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	static ino_t last_ino;
 	static dev_t last_dev;
 	int err = 0;
@@ -972,7 +972,7 @@ nfsd_vfs_write(struct svc_rqst *rqstp, s
 	int			use_wgather;
 
 	dentry = file->f_path.dentry;
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	exp   = fhp->fh_export;
 
 	/*
@@ -1041,7 +1041,7 @@ __be32 nfsd_read(struct svc_rqst *rqstp,
 	if (err)
 		return err;
 
-	inode = file->f_path.dentry->d_inode;
+	inode = d_inode(file->f_path.dentry);
 
 	/* Get readahead parameters */
 	ra = nfsd_get_raparms(inode->i_sb->s_dev, inode->i_ino);
@@ -1229,7 +1229,7 @@ nfsd_create(struct svc_rqst *rqstp, stru
 		goto out;
 
 	dentry = fhp->fh_dentry;
-	dirp = dentry->d_inode;
+	dirp = d_inode(dentry);
 
 	err = nfserr_notdir;
 	if (!dirp->i_op->lookup)
@@ -1265,7 +1265,7 @@ nfsd_create(struct svc_rqst *rqstp, stru
 	 * Make sure the child dentry is still negative ...
 	 */
 	err = nfserr_exist;
-	if (dchild->d_inode) {
+	if (d_inode(dchild)) {
 		dprintk("nfsd_create: dentry %s/%s not negative!\n",
 			dentry->d_name.name, dchild->d_name.name);
 		goto out; 
@@ -1373,7 +1373,7 @@ do_nfsd_create(struct svc_rqst *rqstp, s
 		goto out;
 
 	dentry = fhp->fh_dentry;
-	dirp = dentry->d_inode;
+	dirp = d_inode(dentry);
 
 	/* Get all the sanity checks out of the way before
 	 * we lock the parent. */
@@ -1391,7 +1391,7 @@ do_nfsd_create(struct svc_rqst *rqstp, s
 		goto out_nfserr;
 
 	/* If file doesn't exist, check for permissions to create one */
-	if (!dchild->d_inode) {
+	if (!d_inode(dchild)) {
 		err = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);
 		if (err)
 			goto out;
@@ -1415,12 +1415,12 @@ do_nfsd_create(struct svc_rqst *rqstp, s
 	host_err = mnt_want_write(fhp->fh_export->ex_path.mnt);
 	if (host_err)
 		goto out_nfserr;
-	if (dchild->d_inode) {
+	if (d_inode(dchild)) {
 		err = 0;
 
 		switch (createmode) {
 		case NFS3_CREATE_UNCHECKED:
-			if (! S_ISREG(dchild->d_inode->i_mode))
+			if (! S_ISREG(d_inode(dchild)->i_mode))
 				err = nfserr_exist;
 			else if (truncp) {
 				/* in nfsv4, we need to treat this case a little
@@ -1438,14 +1438,14 @@ do_nfsd_create(struct svc_rqst *rqstp, s
 			}
 			break;
 		case NFS3_CREATE_EXCLUSIVE:
-			if (   dchild->d_inode->i_mtime.tv_sec == v_mtime
-			    && dchild->d_inode->i_atime.tv_sec == v_atime
-			    && dchild->d_inode->i_size  == 0 )
+			if (d_inode(dchild)->i_mtime.tv_sec == v_mtime
+			    && d_inode(dchild)->i_atime.tv_sec == v_atime
+			    && d_inode(dchild)->i_size  == 0 )
 				break;
 		case NFS4_CREATE_EXCLUSIVE4_1:
-			if (   dchild->d_inode->i_mtime.tv_sec == v_mtime
-			    && dchild->d_inode->i_atime.tv_sec == v_atime
-			    && dchild->d_inode->i_size  == 0 )
+			if (d_inode(dchild)->i_mtime.tv_sec == v_mtime
+			    && d_inode(dchild)->i_atime.tv_sec == v_atime
+			    && d_inode(dchild)->i_size  == 0 )
 				goto set_attr;
 			 /* fallthru */
 		case NFS3_CREATE_GUARDED:
@@ -1523,7 +1523,7 @@ nfsd_readlink(struct svc_rqst *rqstp, st
 		goto out;
 
 	dentry = fhp->fh_dentry;
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	err = nfserr_inval;
 	if (!inode->i_op->readlink)
@@ -1593,11 +1593,12 @@ nfsd_symlink(struct svc_rqst *rqstp, str
 		else {
 			strncpy(path_alloced, path, plen);
 			path_alloced[plen] = 0;
-			host_err = vfs_symlink(dentry->d_inode, dnew, path_alloced);
+			host_err = vfs_symlink(d_inode(dentry), dnew,
+					       path_alloced);
 			kfree(path_alloced);
 		}
 	} else
-		host_err = vfs_symlink(dentry->d_inode, dnew, path);
+		host_err = vfs_symlink(d_inode(dentry), dnew, path);
 	err = nfserrno(host_err);
 	if (!err)
 		err = nfserrno(commit_metadata(fhp));
@@ -1645,7 +1646,7 @@ nfsd_link(struct svc_rqst *rqstp, struct
 
 	fh_lock_nested(ffhp, I_MUTEX_PARENT);
 	ddir = ffhp->fh_dentry;
-	dirp = ddir->d_inode;
+	dirp = d_inode(ddir);
 
 	dnew = lookup_one_len(name, ddir, len);
 	host_err = PTR_ERR(dnew);
@@ -1660,9 +1661,9 @@ nfsd_link(struct svc_rqst *rqstp, struct
 		goto out_dput;
 	}
 	err = nfserr_noent;
-	if (!dold->d_inode)
+	if (!d_inode(dold))
 		goto out_drop_write;
-	host_err = nfsd_break_lease(dold->d_inode);
+	host_err = nfsd_break_lease(d_inode(dold));
 	if (host_err) {
 		err = nfserrno(host_err);
 		goto out_drop_write;
@@ -1713,10 +1714,10 @@ nfsd_rename(struct svc_rqst *rqstp, stru
 		goto out;
 
 	fdentry = ffhp->fh_dentry;
-	fdir = fdentry->d_inode;
+	fdir = d_inode(fdentry);
 
 	tdentry = tfhp->fh_dentry;
-	tdir = tdentry->d_inode;
+	tdir = d_inode(tdentry);
 
 	err = (rqstp->rq_vers == 2) ? nfserr_acces : nfserr_xdev;
 	if (ffhp->fh_export != tfhp->fh_export)
@@ -1739,7 +1740,7 @@ nfsd_rename(struct svc_rqst *rqstp, stru
 		goto out_nfserr;
 
 	host_err = -ENOENT;
-	if (!odentry->d_inode)
+	if (!d_inode(odentry))
 		goto out_dput_old;
 	host_err = -EINVAL;
 	if (odentry == trap)
@@ -1760,11 +1761,11 @@ nfsd_rename(struct svc_rqst *rqstp, stru
 	if (host_err)
 		goto out_dput_new;
 
-	host_err = nfsd_break_lease(odentry->d_inode);
+	host_err = nfsd_break_lease(d_inode(odentry));
 	if (host_err)
 		goto out_drop_write;
-	if (ndentry->d_inode) {
-		host_err = nfsd_break_lease(ndentry->d_inode);
+	if (d_inode(ndentry)) {
+		host_err = nfsd_break_lease(d_inode(ndentry));
 		if (host_err)
 			goto out_drop_write;
 	}
@@ -1818,27 +1819,27 @@ nfsd_unlink(struct svc_rqst *rqstp, stru
 
 	fh_lock_nested(fhp, I_MUTEX_PARENT);
 	dentry = fhp->fh_dentry;
-	dirp = dentry->d_inode;
+	dirp = d_inode(dentry);
 
 	rdentry = lookup_one_len(fname, dentry, flen);
 	host_err = PTR_ERR(rdentry);
 	if (IS_ERR(rdentry))
 		goto out_nfserr;
 
-	if (!rdentry->d_inode) {
+	if (!d_inode(rdentry)) {
 		dput(rdentry);
 		err = nfserr_noent;
 		goto out;
 	}
 
 	if (!type)
-		type = rdentry->d_inode->i_mode & S_IFMT;
+		type = d_inode(rdentry)->i_mode & S_IFMT;
 
 	host_err = mnt_want_write(fhp->fh_export->ex_path.mnt);
 	if (host_err)
 		goto out_put;
 
-	host_err = nfsd_break_lease(rdentry->d_inode);
+	host_err = nfsd_break_lease(d_inode(rdentry));
 	if (host_err)
 		goto out_drop_write;
 	if (type != S_IFDIR)
@@ -1918,7 +1919,7 @@ static __be32 nfsd_buffered_readdir(stru
 	offset = *offsetp;
 
 	while (1) {
-		struct inode *dir_inode = file->f_path.dentry->d_inode;
+		struct inode *dir_inode = d_inode(file->f_path.dentry);
 		unsigned int reclen;
 
 		cdp->err = nfserr_eof; /* will be cleared on successful read */
@@ -2043,7 +2044,7 @@ __be32
 nfsd_permission(struct svc_rqst *rqstp, struct svc_export *exp,
 					struct dentry *dentry, int acc)
 {
-	struct inode	*inode = dentry->d_inode;
+	struct inode	*inode = d_inode(dentry);
 	int		err;
 
 	if ((acc & NFSD_MAY_MASK) == NFSD_MAY_NOP)
@@ -2185,7 +2186,7 @@ out_nomem:
 struct posix_acl *
 nfsd_get_posix_acl(struct svc_fh *fhp, int type)
 {
-	struct inode *inode = fhp->fh_dentry->d_inode;
+	struct inode *inode = d_inode(fhp->fh_dentry);
 	char *name;
 	void *value = NULL;
 	ssize_t size;
@@ -2217,7 +2218,7 @@ nfsd_get_posix_acl(struct svc_fh *fhp, i
 int
 nfsd_set_posix_acl(struct svc_fh *fhp, int type, struct posix_acl *acl)
 {
-	struct inode *inode = fhp->fh_dentry->d_inode;
+	struct inode *inode = d_inode(fhp->fh_dentry);
 	char *name;
 	void *value = NULL;
 	size_t size;
diff -u -p a/nfsd/nfs3acl.c b/nfsd/nfs3acl.c
--- a/nfsd/nfs3acl.c
+++ b/nfsd/nfs3acl.c
@@ -57,7 +57,7 @@ static __be32 nfsd3_proc_getacl(struct s
 		if (acl == NULL) {
 			/* Solaris returns the inode's minimum ACL. */
 
-			struct inode *inode = fh->fh_dentry->d_inode;
+			struct inode *inode = d_inode(fh->fh_dentry);
 			acl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);
 		}
 		resp->acl_access = acl;
@@ -168,8 +168,8 @@ static int nfs3svc_encode_getaclres(stru
 	struct dentry *dentry = resp->fh.fh_dentry;
 
 	p = nfs3svc_encode_post_op_attr(rqstp, p, &resp->fh);
-	if (resp->status == 0 && dentry && dentry->d_inode) {
-		struct inode *inode = dentry->d_inode;
+	if (resp->status == 0 && dentry && d_inode(dentry)) {
+		struct inode *inode = d_inode(dentry);
 		struct kvec *head = rqstp->rq_res.head;
 		unsigned int base;
 		int n;
diff -u -p a/nfsd/nfsxdr.c b/nfsd/nfsxdr.c
--- a/nfsd/nfsxdr.c
+++ b/nfsd/nfsxdr.c
@@ -184,7 +184,7 @@ encode_fattr(struct svc_rqst *rqstp, __b
 	*p++ = htonl((u32) stat->ino);
 	*p++ = htonl((u32) stat->atime.tv_sec);
 	*p++ = htonl(stat->atime.tv_nsec ? stat->atime.tv_nsec / 1000 : 0);
-	lease_get_mtime(dentry->d_inode, &time); 
+	lease_get_mtime(d_inode(dentry), &time); 
 	*p++ = htonl((u32) time.tv_sec);
 	*p++ = htonl(time.tv_nsec ? time.tv_nsec / 1000 : 0); 
 	*p++ = htonl((u32) stat->ctime.tv_sec);
diff -u -p a/nfsd/nfs3xdr.c b/nfsd/nfs3xdr.c
--- a/nfsd/nfs3xdr.c
+++ b/nfsd/nfs3xdr.c
@@ -144,7 +144,7 @@ static __be32 *encode_fsid(__be32 *p, st
 	default:
 	case FSIDSOURCE_DEV:
 		p = xdr_encode_hyper(p, (u64)huge_encode_dev
-				     (fhp->fh_dentry->d_inode->i_sb->s_dev));
+				     (d_inode(fhp->fh_dentry)->i_sb->s_dev));
 		break;
 	case FSIDSOURCE_FSID:
 		p = xdr_encode_hyper(p, (u64) fhp->fh_export->ex_fsid);
@@ -201,14 +201,14 @@ static __be32 *
 encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)
 {
 	struct dentry *dentry = fhp->fh_dentry;
-	if (dentry && dentry->d_inode) {
+	if (dentry && d_inode(dentry)) {
 	        int err;
 		struct kstat stat;
 
 		err = vfs_getattr(fhp->fh_export->ex_path.mnt, dentry, &stat);
 		if (!err) {
 			*p++ = xdr_one;		/* attributes follow */
-			lease_get_mtime(dentry->d_inode, &stat.mtime);
+			lease_get_mtime(d_inode(dentry), &stat.mtime);
 			return encode_fattr3(rqstp, p, fhp, &stat);
 		}
 	}
@@ -231,7 +231,7 @@ encode_wcc_data(struct svc_rqst *rqstp,
 {
 	struct dentry	*dentry = fhp->fh_dentry;
 
-	if (dentry && dentry->d_inode && fhp->fh_post_saved) {
+	if (dentry && d_inode(dentry) && fhp->fh_post_saved) {
 		if (fhp->fh_pre_saved) {
 			*p++ = xdr_one;
 			p = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);
@@ -259,11 +259,11 @@ void fill_post_wcc(struct svc_fh *fhp)
 
 	err = vfs_getattr(fhp->fh_export->ex_path.mnt, fhp->fh_dentry,
 			&fhp->fh_post_attr);
-	fhp->fh_post_change = fhp->fh_dentry->d_inode->i_version;
+	fhp->fh_post_change = d_inode(fhp->fh_dentry)->i_version;
 	if (err) {
 		fhp->fh_post_saved = 0;
 		/* Grab the ctime anyway - set_change_info might use it */
-		fhp->fh_post_attr.ctime = fhp->fh_dentry->d_inode->i_ctime;
+		fhp->fh_post_attr.ctime = d_inode(fhp->fh_dentry)->i_ctime;
 	} else
 		fhp->fh_post_saved = 1;
 }
@@ -630,7 +630,7 @@ nfs3svc_encode_attrstat(struct svc_rqst
 					struct nfsd3_attrstat *resp)
 {
 	if (resp->status == 0) {
-		lease_get_mtime(resp->fh.fh_dentry->d_inode,
+		lease_get_mtime(d_inode(resp->fh.fh_dentry),
 				&resp->stat.mtime);
 		p = encode_fattr3(rqstp, p, &resp->fh, &resp->stat);
 	}
@@ -834,7 +834,7 @@ compose_entry_fh(struct nfsd3_readdirres
 	rv = fh_compose(fhp, exp, dchild, &cd->fh);
 	if (rv)
 		goto out;
-	if (!dchild->d_inode)
+	if (!d_inode(dchild))
 		goto out;
 	rv = 0;
 out:
diff -u -p a/nfsd/nfs4state.c b/nfsd/nfs4state.c
--- a/nfsd/nfs4state.c
+++ b/nfsd/nfs4state.c
@@ -2314,7 +2314,7 @@ static inline int deny_valid(u32 x)
 static __be32
 nfs4_share_conflict(struct svc_fh *current_fh, unsigned int deny_type)
 {
-	struct inode *ino = current_fh->fh_dentry->d_inode;
+	struct inode *ino = d_inode(current_fh->fh_dentry);
 	struct nfs4_file *fp;
 	struct nfs4_stateid *stp;
 	__be32 ret;
@@ -2790,7 +2790,7 @@ nfsd4_process_open2(struct svc_rqst *rqs
 {
 	struct nfsd4_compoundres *resp = rqstp->rq_resp;
 	struct nfs4_file *fp = NULL;
-	struct inode *ino = current_fh->fh_dentry->d_inode;
+	struct inode *ino = d_inode(current_fh->fh_dentry);
 	struct nfs4_stateid *stp = NULL;
 	struct nfs4_delegation *dp = NULL;
 	__be32 status;
@@ -3032,7 +3032,7 @@ search_close_lru(u32 st_id, int flags)
 static inline int
 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_stateid *stp)
 {
-	return fhp->fh_dentry->d_inode != stp->st_file->fi_inode;
+	return d_inode(fhp->fh_dentry) != stp->st_file->fi_inode;
 }
 
 static int
@@ -3147,7 +3147,7 @@ nfs4_preprocess_stateid_op(struct nfsd4_
 	struct nfs4_stateid *stp = NULL;
 	struct nfs4_delegation *dp = NULL;
 	struct svc_fh *current_fh = &cstate->current_fh;
-	struct inode *ino = current_fh->fh_dentry->d_inode;
+	struct inode *ino = d_inode(current_fh->fh_dentry);
 	__be32 status;
 
 	if (filpp)
@@ -3519,7 +3519,7 @@ nfsd4_delegreturn(struct svc_rqst *rqstp
 
 	if ((status = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0)))
 		return status;
-	inode = cstate->current_fh.fh_dentry->d_inode;
+	inode = d_inode(cstate->current_fh.fh_dentry);
 
 	if (nfsd4_has_session(cstate))
 		flags |= HAS_SESSION;
@@ -4005,7 +4005,7 @@ nfsd4_lockt(struct svc_rqst *rqstp, stru
 		goto out;
 	}
 
-	inode = cstate->current_fh.fh_dentry->d_inode;
+	inode = d_inode(cstate->current_fh.fh_dentry);
 	locks_init_lock(&file_lock);
 	switch (lockt->lt_type) {
 		case NFS4_READ_LT:
@@ -4479,7 +4479,7 @@ nfs4_reset_recoverydir(char *recdir)
 	if (status)
 		return status;
 	status = -ENOTDIR;
-	if (S_ISDIR(path.dentry->d_inode->i_mode)) {
+	if (S_ISDIR(d_inode(path.dentry)->i_mode)) {
 		nfs4_set_recdir(recdir);
 		status = 0;
 	}
diff -u -p a/nfsd/nfsproc.c b/nfsd/nfsproc.c
--- a/nfsd/nfsproc.c
+++ b/nfsd/nfsproc.c
@@ -222,7 +222,7 @@ nfsd_proc_create(struct svc_rqst *rqstp,
 	}
 	fh_init(newfhp, NFS_FHSIZE);
 	nfserr = fh_compose(newfhp, dirfhp->fh_export, dchild, dirfhp);
-	if (!nfserr && !dchild->d_inode)
+	if (!nfserr && !d_inode(dchild))
 		nfserr = nfserr_noent;
 	dput(dchild);
 	if (nfserr) {
@@ -240,7 +240,7 @@ nfsd_proc_create(struct svc_rqst *rqstp,
 		}
 	}
 
-	inode = newfhp->fh_dentry->d_inode;
+	inode = d_inode(newfhp->fh_dentry);
 
 	/* Unfudge the mode bits */
 	if (attr->ia_valid & ATTR_MODE) {
diff -u -p a/nfsd/nfsctl.c b/nfsd/nfsctl.c
--- a/nfsd/nfsctl.c
+++ b/nfsd/nfsctl.c
@@ -109,7 +109,7 @@ static ssize_t (*write_op[])(struct file
 
 static ssize_t nfsctl_transaction_write(struct file *file, const char __user *buf, size_t size, loff_t *pos)
 {
-	ino_t ino =  file->f_path.dentry->d_inode->i_ino;
+	ino_t ino =  d_inode(file->f_path.dentry)->i_ino;
 	char *data;
 	ssize_t rv;
 
diff -u -p a/nfsd/nfs4xdr.c b/nfsd/nfs4xdr.c
--- a/nfsd/nfs4xdr.c
+++ b/nfsd/nfs4xdr.c
@@ -1895,7 +1895,7 @@ nfsd4_encode_fattr(struct svc_fh *fhp, s
 	if (bmval0 & FATTR4_WORD0_CHANGE) {
 		if ((buflen -= 8) < 0)
 			goto out_resource;
-		write_change(&p, &stat, dentry->d_inode);
+		write_change(&p, &stat, d_inode(dentry));
 	}
 	if (bmval0 & FATTR4_WORD0_SIZE) {
 		if ((buflen -= 8) < 0)
@@ -2232,7 +2232,7 @@ nfsd4_encode_dirent_fattr(struct nfsd4_r
 	dentry = lookup_one_len(name, cd->rd_fhp->fh_dentry, namlen);
 	if (IS_ERR(dentry))
 		return nfserrno(PTR_ERR(dentry));
-	if (!dentry->d_inode) {
+	if (!d_inode(dentry)) {
 		/*
 		 * nfsd_buffered_readdir drops the i_mutex between
 		 * readdir and calling this callback, leaving a window
@@ -2689,7 +2689,7 @@ nfsd4_encode_read(struct nfsd4_compoundr
 	if (nfserr)
 		return nfserr;
 	eof = (read->rd_offset + maxcount >=
-	       read->rd_fhp->fh_dentry->d_inode->i_size);
+	       d_inode(read->rd_fhp->fh_dentry)->i_size);
 
 	WRITE32(eof);
 	WRITE32(maxcount);
diff -u -p a/nfsd/nfs4recover.c b/nfsd/nfs4recover.c
--- a/nfsd/nfs4recover.c
+++ b/nfsd/nfs4recover.c
@@ -135,7 +135,7 @@ nfsd4_create_clid_dir(struct nfs4_client
 
 	dir = rec_file->f_path.dentry;
 	/* lock the parent */
-	mutex_lock(&dir->d_inode->i_mutex);
+	mutex_lock(&d_inode(dir)->i_mutex);
 
 	dentry = lookup_one_len(dname, dir, HEXDIR_LEN-1);
 	if (IS_ERR(dentry)) {
@@ -143,19 +143,19 @@ nfsd4_create_clid_dir(struct nfs4_client
 		goto out_unlock;
 	}
 	status = -EEXIST;
-	if (dentry->d_inode) {
+	if (d_inode(dentry)) {
 		dprintk("NFSD: nfsd4_create_clid_dir: DIRECTORY EXISTS\n");
 		goto out_put;
 	}
 	status = mnt_want_write(rec_file->f_path.mnt);
 	if (status)
 		goto out_put;
-	status = vfs_mkdir(dir->d_inode, dentry, S_IRWXU);
+	status = vfs_mkdir(d_inode(dir), dentry, S_IRWXU);
 	mnt_drop_write(rec_file->f_path.mnt);
 out_put:
 	dput(dentry);
 out_unlock:
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 	if (status == 0) {
 		clp->cl_firststate = 1;
 		vfs_fsync(rec_file, 0);
@@ -214,7 +214,7 @@ nfsd4_list_rec_dir(struct dentry *dir, r
 		goto out;
 	status = vfs_readdir(filp, nfsd4_build_namelist, &names);
 	fput(filp);
-	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);
+	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_PARENT);
 	while (!list_empty(&names)) {
 		entry = list_entry(names.next, struct name_list, list);
 
@@ -230,7 +230,7 @@ nfsd4_list_rec_dir(struct dentry *dir, r
 		list_del(&entry->list);
 		kfree(entry);
 	}
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 out:
 	while (!list_empty(&names)) {
 		entry = list_entry(names.next, struct name_list, list);
@@ -250,20 +250,20 @@ nfsd4_unlink_clid_dir(char *name, int na
 	dprintk("NFSD: nfsd4_unlink_clid_dir. name %.*s\n", namlen, name);
 
 	dir = rec_file->f_path.dentry;
-	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);
+	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_PARENT);
 	dentry = lookup_one_len(name, dir, namlen);
 	if (IS_ERR(dentry)) {
 		status = PTR_ERR(dentry);
 		goto out_unlock;
 	}
 	status = -ENOENT;
-	if (!dentry->d_inode)
+	if (!d_inode(dentry))
 		goto out;
-	status = vfs_rmdir(dir->d_inode, dentry);
+	status = vfs_rmdir(d_inode(dir), dentry);
 out:
 	dput(dentry);
 out_unlock:
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 	return status;
 }
 
@@ -305,7 +305,7 @@ purge_old(struct dentry *parent, struct
 	if (nfs4_has_reclaimed_state(child->d_name.name, false))
 		return 0;
 
-	status = vfs_rmdir(parent->d_inode, child);
+	status = vfs_rmdir(d_inode(parent), child);
 	if (status)
 		printk("failed to remove client recovery directory %s\n",
 				child->d_name.name);
diff -u -p a/nfsd/nfs4proc.c b/nfsd/nfs4proc.c
--- a/nfsd/nfs4proc.c
+++ b/nfsd/nfs4proc.c
@@ -73,7 +73,7 @@ check_attr_support(struct svc_rqst *rqst
 	 * in current environment or not.
 	 */
 	if (bmval[0] & FATTR4_WORD0_ACL) {
-		if (!IS_POSIXACL(dentry->d_inode))
+		if (!IS_POSIXACL(d_inode(dentry)))
 			return nfserr_attrnotsupp;
 	}
 
@@ -739,8 +739,8 @@ nfsd4_rename(struct svc_rqst *rqstp, str
 	if (status == nfserr_isdir)
 		status = nfserr_exist;
 	else if ((status == nfserr_notdir) &&
-                  (S_ISDIR(cstate->save_fh.fh_dentry->d_inode->i_mode) &&
-                   S_ISDIR(cstate->current_fh.fh_dentry->d_inode->i_mode)))
+                  (S_ISDIR(d_inode(cstate->save_fh.fh_dentry)->i_mode) &&
+                   S_ISDIR(d_inode(cstate->current_fh.fh_dentry)->i_mode)))
 		status = nfserr_exist;
 	else if (status == nfserr_symlink)
 		status = nfserr_notdir;
@@ -770,7 +770,7 @@ nfsd4_secinfo(struct svc_rqst *rqstp, st
 				    &exp, &dentry);
 	if (err)
 		return err;
-	if (dentry->d_inode == NULL) {
+	if (d_inode(dentry) == NULL) {
 		exp_put(exp);
 		err = nfserr_noent;
 	} else
diff -u -p a/nfsd/export.c b/nfsd/export.c
--- a/nfsd/export.c
+++ b/nfsd/export.c
@@ -593,7 +593,7 @@ static int svc_export_parse(struct cache
 				goto out4;
 		}
 
-		err = check_export(exp.ex_path.dentry->d_inode, &exp.ex_flags,
+		err = check_export(d_inode(exp.ex_path.dentry), &exp.ex_flags,
 				   exp.ex_uuid);
 		if (err)
 			goto out4;
@@ -965,7 +965,7 @@ static int exp_fsid_hash(svc_client *clp
 static int exp_hash(struct auth_domain *clp, struct svc_export *exp)
 {
 	u32 fsid[2];
-	struct inode *inode = exp->ex_path.dentry->d_inode;
+	struct inode *inode = d_inode(exp->ex_path.dentry);
 	dev_t dev = inode->i_sb->s_dev;
 
 	if (old_valid_dev(dev)) {
@@ -979,7 +979,7 @@ static int exp_hash(struct auth_domain *
 static void exp_unhash(struct svc_export *exp)
 {
 	struct svc_expkey *ek;
-	struct inode *inode = exp->ex_path.dentry->d_inode;
+	struct inode *inode = d_inode(exp->ex_path.dentry);
 
 	ek = exp_get_key(exp->ex_client, inode->i_sb->s_dev, inode->i_ino);
 	if (!IS_ERR(ek)) {
@@ -1051,7 +1051,7 @@ exp_export(struct nfsctl_export *nxp)
 		goto finish;
 	}
 
-	err = check_export(path.dentry->d_inode, &nxp->ex_flags, NULL);
+	err = check_export(d_inode(path.dentry), &nxp->ex_flags, NULL);
 	if (err) goto finish;
 
 	err = -ENOMEM;
@@ -1180,7 +1180,7 @@ exp_rootfh(svc_client *clp, char *name,
 		printk("nfsd: exp_rootfh path not found %s", name);
 		return err;
 	}
-	inode = path.dentry->d_inode;
+	inode = d_inode(path.dentry);
 
 	dprintk("nfsd: exp_rootfh(%s [%p] %s:%s/%ld)\n",
 		 name, path.dentry, clp->name,
diff -u -p a/nfsd/nfsfh.c b/nfsd/nfsfh.c
--- a/nfsd/nfsfh.c
+++ b/nfsd/nfsfh.c
@@ -38,7 +38,7 @@ static int nfsd_acceptable(void *expv, s
 		/* make sure parents give x permission to user */
 		int err;
 		parent = dget_parent(tdentry);
-		err = inode_permission(parent->d_inode, MAY_EXEC);
+		err = inode_permission(d_inode(parent), MAY_EXEC);
 		if (err < 0) {
 			dput(parent);
 			break;
@@ -118,8 +118,8 @@ static inline __be32 check_pseudo_root(s
 	 * We're exposing only the directories and symlinks that have to be
 	 * traversed on the way to real exports:
 	 */
-	if (unlikely(!S_ISDIR(dentry->d_inode->i_mode) &&
-		     !S_ISLNK(dentry->d_inode->i_mode)))
+	if (unlikely(!S_ISDIR(d_inode(dentry)->i_mode) &&
+		     !S_ISLNK(d_inode(dentry)->i_mode)))
 		return nfserr_stale;
 	/*
 	 * A pseudoroot export gives permission to access only one
@@ -254,7 +254,7 @@ static __be32 nfsd_set_fh_dentry(struct
 		goto out;
 	}
 
-	if (S_ISDIR(dentry->d_inode->i_mode) &&
+	if (S_ISDIR(d_inode(dentry)->i_mode) &&
 			(dentry->d_flags & DCACHE_DISCONNECTED)) {
 		printk("nfsd: find_fh_dentry returned a DISCONNECTED directory: %s/%s\n",
 				dentry->d_parent->d_name.name, dentry->d_name.name);
@@ -335,7 +335,7 @@ fh_verify(struct svc_rqst *rqstp, struct
 	if (error)
 		goto out;
 
-	error = nfsd_mode_check(rqstp, dentry->d_inode->i_mode, type);
+	error = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);
 	if (error)
 		goto out;
 
@@ -408,9 +408,9 @@ static inline void _fh_update_old(struct
 				  struct svc_export *exp,
 				  struct knfsd_fh *fh)
 {
-	fh->ofh_ino = ino_t_to_u32(dentry->d_inode->i_ino);
-	fh->ofh_generation = dentry->d_inode->i_generation;
-	if (S_ISDIR(dentry->d_inode->i_mode) ||
+	fh->ofh_ino = ino_t_to_u32(d_inode(dentry)->i_ino);
+	fh->ofh_generation = d_inode(dentry)->i_generation;
+	if (S_ISDIR(d_inode(dentry)->i_mode) ||
 	    (exp->ex_flags & NFSEXP_NOSUBTREECHECK))
 		fh->ofh_dirino = 0;
 }
@@ -422,7 +422,7 @@ static bool is_root_export(struct svc_ex
 
 static struct super_block *exp_sb(struct svc_export *exp)
 {
-	return exp->ex_path.dentry->d_inode->i_sb;
+	return d_inode(exp->ex_path.dentry)->i_sb;
 }
 
 static bool fsid_type_ok_for_exp(u8 fsid_type, struct svc_export *exp)
@@ -516,14 +516,14 @@ fh_compose(struct svc_fh *fhp, struct sv
 	 *
 	 */
 
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	struct dentry *parent = dentry->d_parent;
 	__u32 *datap;
 	dev_t ex_dev = exp_sb(exp)->s_dev;
 
 	dprintk("nfsd: fh_compose(exp %02x:%02x/%ld %s/%s, ino=%ld)\n",
 		MAJOR(ex_dev), MINOR(ex_dev),
-		(long) exp->ex_path.dentry->d_inode->i_ino,
+		(long) d_inode(exp->ex_path.dentry)->i_ino,
 		parent->d_name.name, dentry->d_name.name,
 		(inode ? inode->i_ino : 0));
 
@@ -557,7 +557,7 @@ fh_compose(struct svc_fh *fhp, struct sv
 		fhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);
 		fhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;
 		fhp->fh_handle.ofh_xino =
-			ino_t_to_u32(exp->ex_path.dentry->d_inode->i_ino);
+			ino_t_to_u32(d_inode(exp->ex_path.dentry)->i_ino);
 		fhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));
 		if (inode)
 			_fh_update_old(dentry, exp, &fhp->fh_handle);
@@ -566,7 +566,7 @@ fh_compose(struct svc_fh *fhp, struct sv
 		fhp->fh_handle.fh_auth_type = 0;
 		datap = fhp->fh_handle.fh_auth+0;
 		mk_fsid(fhp->fh_handle.fh_fsid_type, datap, ex_dev,
-			exp->ex_path.dentry->d_inode->i_ino,
+			d_inode(exp->ex_path.dentry)->i_ino,
 			exp->ex_fsid, exp->ex_uuid);
 
 		len = key_len(fhp->fh_handle.fh_fsid_type);
@@ -597,7 +597,7 @@ fh_update(struct svc_fh *fhp)
 		goto out_bad;
 
 	dentry = fhp->fh_dentry;
-	if (!dentry->d_inode)
+	if (!d_inode(dentry))
 		goto out_negative;
 	if (fhp->fh_handle.fh_version != 1) {
 		_fh_update_old(dentry, fhp->fh_export, &fhp->fh_handle);
diff -u -p a/befs/linuxvfs.c b/befs/linuxvfs.c
--- a/befs/linuxvfs.c
+++ b/befs/linuxvfs.c
@@ -212,7 +212,7 @@ befs_lookup(struct inode *dir, struct de
 static int
 befs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct super_block *sb = inode->i_sb;
 	befs_data_stream *ds = &BEFS_I(inode)->i_data.ds;
 	befs_off_t value;
@@ -466,7 +466,7 @@ befs_destroy_inodecache(void)
 static void *
 befs_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	befs_inode_info *befs_ino = BEFS_I(dentry->d_inode);
+	befs_inode_info *befs_ino = BEFS_I(d_inode(dentry));
 	char *link;
 
 	if (befs_ino->i_flags & BEFS_LONG_SYMLINK) {
@@ -496,7 +496,7 @@ befs_follow_link(struct dentry *dentry,
 
 static void befs_put_link(struct dentry *dentry, struct nameidata *nd, void *p)
 {
-	befs_inode_info *befs_ino = BEFS_I(dentry->d_inode);
+	befs_inode_info *befs_ino = BEFS_I(d_inode(dentry));
 	if (befs_ino->i_flags & BEFS_LONG_SYMLINK) {
 		char *link = nd_get_link(nd);
 		if (!IS_ERR(link))
diff -u -p a/buffer.c b/buffer.c
--- a/buffer.c
+++ b/buffer.c
@@ -2342,7 +2342,7 @@ int __block_page_mkwrite(struct vm_area_
 			 get_block_t get_block)
 {
 	struct page *page = vmf->page;
-	struct inode *inode = vma->vm_file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(vma->vm_file->f_path.dentry);
 	unsigned long end;
 	loff_t size;
 	int ret;
@@ -2392,7 +2392,7 @@ int block_page_mkwrite(struct vm_area_st
 		   get_block_t get_block)
 {
 	int ret;
-	struct super_block *sb = vma->vm_file->f_path.dentry->d_inode->i_sb;
+	struct super_block *sb = d_inode(vma->vm_file->f_path.dentry)->i_sb;
 
 	/*
 	 * This check is racy but catches the common case. The check in
diff -u -p a/cachefiles/security.c b/cachefiles/security.c
--- a/cachefiles/security.c
+++ b/cachefiles/security.c
@@ -57,7 +57,7 @@ static int cachefiles_check_cache_dir(st
 {
 	int ret;
 
-	ret = security_inode_mkdir(root->d_inode, root, 0);
+	ret = security_inode_mkdir(d_inode(root), root, 0);
 	if (ret < 0) {
 		printk(KERN_ERR "CacheFiles:"
 		       " Security denies permission to make dirs: error %d",
@@ -65,7 +65,7 @@ static int cachefiles_check_cache_dir(st
 		return ret;
 	}
 
-	ret = security_inode_create(root->d_inode, root, 0);
+	ret = security_inode_create(d_inode(root), root, 0);
 	if (ret < 0)
 		printk(KERN_ERR "CacheFiles:"
 		       " Security denies permission to create files: error %d",
@@ -99,7 +99,7 @@ int cachefiles_determine_cache_security(
 
 	/* use the cache root dir's security context as the basis with
 	 * which create files */
-	ret = set_create_files_as(new, root->d_inode);
+	ret = set_create_files_as(new, d_inode(root));
 	if (ret < 0) {
 		abort_creds(new);
 		cachefiles_begin_secure(cache, _saved_cred);
diff -u -p a/cachefiles/interface.c b/cachefiles/interface.c
--- a/cachefiles/interface.c
+++ b/cachefiles/interface.c
@@ -404,12 +404,12 @@ static int cachefiles_attr_changed(struc
 
 	fscache_set_store_limit(&object->fscache, ni_size);
 
-	oi_size = i_size_read(object->backer->d_inode);
+	oi_size = i_size_read(d_inode(object->backer));
 	if (oi_size == ni_size)
 		return 0;
 
 	cachefiles_begin_secure(cache, &saved_cred);
-	mutex_lock(&object->backer->d_inode->i_mutex);
+	mutex_lock(&d_inode(object->backer)->i_mutex);
 
 	/* if there's an extension to a partial page at the end of the backing
 	 * file, we need to discard the partial page so that we pick up new
@@ -428,7 +428,7 @@ static int cachefiles_attr_changed(struc
 	ret = notify_change(object->backer, &newattrs);
 
 truncate_failed:
-	mutex_unlock(&object->backer->d_inode->i_mutex);
+	mutex_unlock(&d_inode(object->backer)->i_mutex);
 	cachefiles_end_secure(cache, saved_cred);
 
 	if (ret == -EIO) {
diff -u -p a/cachefiles/namei.c b/cachefiles/namei.c
--- a/cachefiles/namei.c
+++ b/cachefiles/namei.c
@@ -286,7 +286,7 @@ static int cachefiles_bury_object(struct
 	_debug("remove %p from %p", rep, dir);
 
 	/* non-directories can just be unlinked */
-	if (!S_ISDIR(rep->d_inode->i_mode)) {
+	if (!S_ISDIR(d_inode(rep)->i_mode)) {
 		_debug("unlink stale object");
 
 		path.mnt = cache->mnt;
@@ -295,13 +295,13 @@ static int cachefiles_bury_object(struct
 		if (ret < 0) {
 			cachefiles_io_error(cache, "Unlink security error");
 		} else {
-			ret = vfs_unlink(dir->d_inode, rep);
+			ret = vfs_unlink(d_inode(dir), rep);
 
 			if (preemptive)
 				cachefiles_mark_object_buried(cache, rep);
 		}
 
-		mutex_unlock(&dir->d_inode->i_mutex);
+		mutex_unlock(&d_inode(dir)->i_mutex);
 
 		if (ret == -EIO)
 			cachefiles_io_error(cache, "Unlink failed");
@@ -312,7 +312,7 @@ static int cachefiles_bury_object(struct
 
 	/* directories have to be moved to the graveyard */
 	_debug("move stale object to graveyard");
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 
 try_again:
 	/* first step is to make up a grave dentry in the graveyard */
@@ -332,7 +332,7 @@ try_again:
 		return 0;
 	}
 
-	if (!S_ISDIR(cache->graveyard->d_inode->i_mode)) {
+	if (!S_ISDIR(d_inode(cache->graveyard)->i_mode)) {
 		unlock_rename(cache->graveyard, dir);
 		cachefiles_io_error(cache, "Graveyard no longer a directory");
 		return -EIO;
@@ -364,7 +364,7 @@ try_again:
 		return -EIO;
 	}
 
-	if (grave->d_inode) {
+	if (d_inode(grave)) {
 		unlock_rename(cache->graveyard, dir);
 		dput(grave);
 		grave = NULL;
@@ -396,8 +396,8 @@ try_again:
 	if (ret < 0) {
 		cachefiles_io_error(cache, "Rename security error %d", ret);
 	} else {
-		ret = vfs_rename(dir->d_inode, rep,
-				 cache->graveyard->d_inode, grave);
+		ret = vfs_rename(d_inode(dir), rep,
+				 d_inode(cache->graveyard), grave);
 		if (ret != 0 && ret != -ENOMEM)
 			cachefiles_io_error(cache,
 					    "Rename failed with error %d", ret);
@@ -429,13 +429,13 @@ int cachefiles_delete_object(struct cach
 
 	dir = dget_parent(object->dentry);
 
-	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);
+	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_PARENT);
 
 	if (test_bit(CACHEFILES_OBJECT_BURIED, &object->flags)) {
 		/* object allocation for the same key preemptively deleted this
 		 * object's file so that it could create its own file */
 		_debug("object preemptively buried");
-		mutex_unlock(&dir->d_inode->i_mutex);
+		mutex_unlock(&d_inode(dir)->i_mutex);
 		ret = 0;
 	} else {
 		/* we need to check that our parent is _still_ our parent - it
@@ -447,7 +447,7 @@ int cachefiles_delete_object(struct cach
 			/* it got moved, presumably by cachefilesd culling it,
 			 * so it's no longer in the key path and we can ignore
 			 * it */
-			mutex_unlock(&dir->d_inode->i_mutex);
+			mutex_unlock(&d_inode(dir)->i_mutex);
 			ret = 0;
 		}
 	}
@@ -484,7 +484,7 @@ int cachefiles_walk_to_object(struct cac
 	ASSERT(parent->dentry);
 	ASSERT(parent->dentry->d_inode);
 
-	if (!(S_ISDIR(parent->dentry->d_inode->i_mode))) {
+	if (!(S_ISDIR(d_inode(parent->dentry)->i_mode))) {
 		// TODO: convert file to dir
 		_leave("looking up in none directory");
 		return -ENOBUFS;
@@ -506,7 +506,7 @@ lookup_again:
 	/* search the current directory for the element name */
 	_debug("lookup '%s'", name);
 
-	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);
+	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_PARENT);
 
 	start = jiffies;
 	next = lookup_one_len(name, dir, nlen);
@@ -514,21 +514,21 @@ lookup_again:
 	if (IS_ERR(next))
 		goto lookup_error;
 
-	_debug("next -> %p %s", next, next->d_inode ? "positive" : "negative");
+	_debug("next -> %p %s", next, d_inode(next) ? "positive" : "negative");
 
 	if (!key)
-		object->new = !next->d_inode;
+		object->new = !d_inode(next);
 
 	/* if this element of the path doesn't exist, then the lookup phase
 	 * failed, and we can release any readers in the certain knowledge that
 	 * there's nothing for them to actually read */
-	if (!next->d_inode)
+	if (!d_inode(next))
 		fscache_object_lookup_negative(&object->fscache);
 
 	/* we need to create the object if it's negative */
 	if (key || object->type == FSCACHE_COOKIE_TYPE_INDEX) {
 		/* index objects and intervening tree levels must be subdirs */
-		if (!next->d_inode) {
+		if (!d_inode(next)) {
 			ret = cachefiles_has_space(cache, 1, 0);
 			if (ret < 0)
 				goto create_error;
@@ -538,7 +538,7 @@ lookup_again:
 			if (ret < 0)
 				goto create_error;
 			start = jiffies;
-			ret = vfs_mkdir(dir->d_inode, next, 0);
+			ret = vfs_mkdir(d_inode(dir), next, 0);
 			cachefiles_hist(cachefiles_mkdir_histogram, start);
 			if (ret < 0)
 				goto create_error;
@@ -546,18 +546,18 @@ lookup_again:
 			ASSERT(next->d_inode);
 
 			_debug("mkdir -> %p{%p{ino=%lu}}",
-			       next, next->d_inode, next->d_inode->i_ino);
+			       next, d_inode(next), d_inode(next)->i_ino);
 
-		} else if (!S_ISDIR(next->d_inode->i_mode)) {
+		} else if (!S_ISDIR(d_inode(next)->i_mode)) {
 			kerror("inode %lu is not a directory",
-			       next->d_inode->i_ino);
+			       d_inode(next)->i_ino);
 			ret = -ENOBUFS;
 			goto error;
 		}
 
 	} else {
 		/* non-index objects start out life as files */
-		if (!next->d_inode) {
+		if (!d_inode(next)) {
 			ret = cachefiles_has_space(cache, 1, 0);
 			if (ret < 0)
 				goto create_error;
@@ -567,7 +567,7 @@ lookup_again:
 			if (ret < 0)
 				goto create_error;
 			start = jiffies;
-			ret = vfs_create(dir->d_inode, next, S_IFREG, NULL);
+			ret = vfs_create(d_inode(dir), next, S_IFREG, NULL);
 			cachefiles_hist(cachefiles_create_histogram, start);
 			if (ret < 0)
 				goto create_error;
@@ -575,13 +575,13 @@ lookup_again:
 			ASSERT(next->d_inode);
 
 			_debug("create -> %p{%p{ino=%lu}}",
-			       next, next->d_inode, next->d_inode->i_ino);
+			       next, d_inode(next), d_inode(next)->i_ino);
 
-		} else if (!S_ISDIR(next->d_inode->i_mode) &&
-			   !S_ISREG(next->d_inode->i_mode)
+		} else if (!S_ISDIR(d_inode(next)->i_mode) &&
+			   !S_ISREG(d_inode(next)->i_mode)
 			   ) {
 			kerror("inode %lu is not a file or directory",
-			       next->d_inode->i_ino);
+			       d_inode(next)->i_ino);
 			ret = -ENOBUFS;
 			goto error;
 		}
@@ -590,7 +590,7 @@ lookup_again:
 	/* process the next component */
 	if (key) {
 		_debug("advance");
-		mutex_unlock(&dir->d_inode->i_mutex);
+		mutex_unlock(&d_inode(dir)->i_mutex);
 		dput(dir);
 		dir = next;
 		next = NULL;
@@ -627,7 +627,7 @@ lookup_again:
 	/* note that we're now using this object */
 	ret = cachefiles_mark_object_active(cache, object);
 
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 	dput(dir);
 	dir = NULL;
 
@@ -651,11 +651,11 @@ lookup_again:
 
 	/* open a file interface onto a data file */
 	if (object->type != FSCACHE_COOKIE_TYPE_INDEX) {
-		if (S_ISREG(object->dentry->d_inode->i_mode)) {
+		if (S_ISREG(d_inode(object->dentry)->i_mode)) {
 			const struct address_space_operations *aops;
 
 			ret = -EPERM;
-			aops = object->dentry->d_inode->i_mapping->a_ops;
+			aops = d_inode(object->dentry)->i_mapping->a_ops;
 			if (!aops->bmap)
 				goto check_error;
 
@@ -668,7 +668,7 @@ lookup_again:
 	object->new = 0;
 	fscache_obtained_object(&object->fscache);
 
-	_leave(" = 0 [%lu]", object->dentry->d_inode->i_ino);
+	_leave(" = 0 [%lu]", d_inode(object->dentry)->i_ino);
 	return 0;
 
 create_error:
@@ -704,7 +704,7 @@ lookup_error:
 		cachefiles_io_error(cache, "Lookup failed");
 	next = NULL;
 error:
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 	dput(next);
 error_out2:
 	dput(dir);
@@ -728,7 +728,7 @@ struct dentry *cachefiles_get_directory(
 	_enter(",,%s", dirname);
 
 	/* search the current directory for the element name */
-	mutex_lock(&dir->d_inode->i_mutex);
+	mutex_lock(&d_inode(dir)->i_mutex);
 
 	start = jiffies;
 	subdir = lookup_one_len(dirname, dir, strlen(dirname));
@@ -740,10 +740,10 @@ struct dentry *cachefiles_get_directory(
 	}
 
 	_debug("subdir -> %p %s",
-	       subdir, subdir->d_inode ? "positive" : "negative");
+	       subdir, d_inode(subdir) ? "positive" : "negative");
 
 	/* we need to create the subdir if it doesn't exist yet */
-	if (!subdir->d_inode) {
+	if (!d_inode(subdir)) {
 		ret = cachefiles_has_space(cache, 1, 0);
 		if (ret < 0)
 			goto mkdir_error;
@@ -755,7 +755,7 @@ struct dentry *cachefiles_get_directory(
 		ret = security_path_mkdir(&path, subdir, 0700);
 		if (ret < 0)
 			goto mkdir_error;
-		ret = vfs_mkdir(dir->d_inode, subdir, 0700);
+		ret = vfs_mkdir(d_inode(dir), subdir, 0700);
 		if (ret < 0)
 			goto mkdir_error;
 
@@ -763,34 +763,34 @@ struct dentry *cachefiles_get_directory(
 
 		_debug("mkdir -> %p{%p{ino=%lu}}",
 		       subdir,
-		       subdir->d_inode,
-		       subdir->d_inode->i_ino);
+		       d_inode(subdir),
+		       d_inode(subdir)->i_ino);
 	}
 
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 
 	/* we need to make sure the subdir is a directory */
 	ASSERT(subdir->d_inode);
 
-	if (!S_ISDIR(subdir->d_inode->i_mode)) {
+	if (!S_ISDIR(d_inode(subdir)->i_mode)) {
 		kerror("%s is not a directory", dirname);
 		ret = -EIO;
 		goto check_error;
 	}
 
 	ret = -EPERM;
-	if (!subdir->d_inode->i_op ||
-	    !subdir->d_inode->i_op->setxattr ||
-	    !subdir->d_inode->i_op->getxattr ||
-	    !subdir->d_inode->i_op->lookup ||
-	    !subdir->d_inode->i_op->mkdir ||
-	    !subdir->d_inode->i_op->create ||
-	    !subdir->d_inode->i_op->rename ||
-	    !subdir->d_inode->i_op->rmdir ||
-	    !subdir->d_inode->i_op->unlink)
+	if (!d_inode(subdir)->i_op ||
+	    !d_inode(subdir)->i_op->setxattr ||
+	    !d_inode(subdir)->i_op->getxattr ||
+	    !d_inode(subdir)->i_op->lookup ||
+	    !d_inode(subdir)->i_op->mkdir ||
+	    !d_inode(subdir)->i_op->create ||
+	    !d_inode(subdir)->i_op->rename ||
+	    !d_inode(subdir)->i_op->rmdir ||
+	    !d_inode(subdir)->i_op->unlink)
 		goto check_error;
 
-	_leave(" = [%lu]", subdir->d_inode->i_ino);
+	_leave(" = [%lu]", d_inode(subdir)->i_ino);
 	return subdir;
 
 check_error:
@@ -799,19 +799,19 @@ check_error:
 	return ERR_PTR(ret);
 
 mkdir_error:
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 	dput(subdir);
 	kerror("mkdir %s failed with error %d", dirname, ret);
 	return ERR_PTR(ret);
 
 lookup_error:
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 	ret = PTR_ERR(subdir);
 	kerror("Lookup %s failed with error %d", dirname, ret);
 	return ERR_PTR(ret);
 
 nomem_d_alloc:
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 	_leave(" = -ENOMEM");
 	return ERR_PTR(-ENOMEM);
 }
@@ -836,7 +836,7 @@ static struct dentry *cachefiles_check_a
 	//       dir->d_name.len, dir->d_name.len, dir->d_name.name, filename);
 
 	/* look up the victim */
-	mutex_lock_nested(&dir->d_inode->i_mutex, 1);
+	mutex_lock_nested(&d_inode(dir)->i_mutex, 1);
 
 	start = jiffies;
 	victim = lookup_one_len(filename, dir, strlen(filename));
@@ -850,8 +850,8 @@ static struct dentry *cachefiles_check_a
 	/* if the object is no longer there then we probably retired the object
 	 * at the netfs's request whilst the cull was in progress
 	 */
-	if (!victim->d_inode) {
-		mutex_unlock(&dir->d_inode->i_mutex);
+	if (!d_inode(victim)) {
+		mutex_unlock(&d_inode(dir)->i_mutex);
 		dput(victim);
 		_leave(" = -ENOENT [absent]");
 		return ERR_PTR(-ENOENT);
@@ -880,13 +880,13 @@ static struct dentry *cachefiles_check_a
 
 object_in_use:
 	read_unlock(&cache->active_lock);
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 	dput(victim);
 	//_leave(" = -EBUSY [in use]");
 	return ERR_PTR(-EBUSY);
 
 lookup_error:
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 	ret = PTR_ERR(victim);
 	if (ret == -ENOENT) {
 		/* file or dir now absent - probably retired by netfs */
@@ -923,7 +923,7 @@ int cachefiles_cull(struct cachefiles_ca
 		return PTR_ERR(victim);
 
 	_debug("victim -> %p %s",
-	       victim, victim->d_inode ? "positive" : "negative");
+	       victim, d_inode(victim) ? "positive" : "negative");
 
 	/* okay... the victim is not being used so we can cull it
 	 * - start by marking it as stale
@@ -946,7 +946,7 @@ int cachefiles_cull(struct cachefiles_ca
 	return 0;
 
 error_unlock:
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 error:
 	dput(victim);
 	if (ret == -ENOENT) {
@@ -981,7 +981,7 @@ int cachefiles_check_in_use(struct cache
 	if (IS_ERR(victim))
 		return PTR_ERR(victim);
 
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 	dput(victim);
 	//_leave(" = 0");
 	return 0;
diff -u -p a/cachefiles/bind.c b/cachefiles/bind.c
--- a/cachefiles/bind.c
+++ b/cachefiles/bind.c
@@ -123,12 +123,12 @@ static int cachefiles_daemon_add_cache(s
 
 	/* check parameters */
 	ret = -EOPNOTSUPP;
-	if (!root->d_inode ||
-	    !root->d_inode->i_op ||
-	    !root->d_inode->i_op->lookup ||
-	    !root->d_inode->i_op->mkdir ||
-	    !root->d_inode->i_op->setxattr ||
-	    !root->d_inode->i_op->getxattr ||
+	if (!d_inode(root) ||
+	    !d_inode(root)->i_op ||
+	    !d_inode(root)->i_op->lookup ||
+	    !d_inode(root)->i_op->mkdir ||
+	    !d_inode(root)->i_op->setxattr ||
+	    !d_inode(root)->i_op->getxattr ||
 	    !root->d_sb ||
 	    !root->d_sb->s_op ||
 	    !root->d_sb->s_op->statfs ||
diff -u -p a/cachefiles/daemon.c b/cachefiles/daemon.c
--- a/cachefiles/daemon.c
+++ b/cachefiles/daemon.c
@@ -575,7 +575,7 @@ static int cachefiles_daemon_cull(struct
 	/* extract the directory dentry from the cwd */
 	get_fs_pwd(current->fs, &path);
 
-	if (!S_ISDIR(path.dentry->d_inode->i_mode))
+	if (!S_ISDIR(d_inode(path.dentry)->i_mode))
 		goto notdir;
 
 	cachefiles_begin_secure(cache, &saved_cred);
@@ -647,7 +647,7 @@ static int cachefiles_daemon_inuse(struc
 	/* extract the directory dentry from the cwd */
 	get_fs_pwd(current->fs, &path);
 
-	if (!S_ISDIR(path.dentry->d_inode->i_mode))
+	if (!S_ISDIR(d_inode(path.dentry)->i_mode))
 		goto notdir;
 
 	cachefiles_begin_secure(cache, &saved_cred);
diff -u -p a/cachefiles/rdwr.c b/cachefiles/rdwr.c
--- a/cachefiles/rdwr.c
+++ b/cachefiles/rdwr.c
@@ -73,12 +73,12 @@ static int cachefiles_read_waiter(wait_q
 static int cachefiles_read_reissue(struct cachefiles_object *object,
 				   struct cachefiles_one_read *monitor)
 {
-	struct address_space *bmapping = object->backer->d_inode->i_mapping;
+	struct address_space *bmapping = d_inode(object->backer)->i_mapping;
 	struct page *backpage = monitor->back_page, *backpage2;
 	int ret;
 
 	kenter("{ino=%lx},{%lx,%lx}",
-	       object->backer->d_inode->i_ino,
+	       d_inode(object->backer)->i_ino,
 	       backpage->index, backpage->flags);
 
 	/* skip if the page was truncated away completely */
@@ -157,7 +157,7 @@ static void cachefiles_read_copier(struc
 	object = container_of(op->op.object,
 			      struct cachefiles_object, fscache);
 
-	_enter("{ino=%lu}", object->backer->d_inode->i_ino);
+	_enter("{ino=%lu}", d_inode(object->backer)->i_ino);
 
 	pagevec_init(&pagevec, 0);
 
@@ -249,7 +249,7 @@ static int cachefiles_read_backing_file_
 	init_waitqueue_func_entry(&monitor->monitor, cachefiles_read_waiter);
 
 	/* attempt to get hold of the backing page */
-	bmapping = object->backer->d_inode->i_mapping;
+	bmapping = d_inode(object->backer)->i_mapping;
 	newpage = NULL;
 
 	for (;;) {
@@ -410,7 +410,7 @@ int cachefiles_read_or_alloc_page(struct
 	if (!object->backer)
 		return -ENOBUFS;
 
-	inode = object->backer->d_inode;
+	inode = d_inode(object->backer);
 	ASSERT(S_ISREG(inode->i_mode));
 	ASSERT(inode->i_mapping->a_ops->bmap);
 	ASSERT(inode->i_mapping->a_ops->readpages);
@@ -469,7 +469,7 @@ static int cachefiles_read_backing_file(
 					struct pagevec *mark_pvec)
 {
 	struct cachefiles_one_read *monitor = NULL;
-	struct address_space *bmapping = object->backer->d_inode->i_mapping;
+	struct address_space *bmapping = d_inode(object->backer)->i_mapping;
 	struct pagevec lru_pvec;
 	struct page *newpage = NULL, *netpage, *_n, *backpage = NULL;
 	int ret = 0;
@@ -715,7 +715,7 @@ int cachefiles_read_or_alloc_pages(struc
 	if (cachefiles_has_space(cache, 0, *nr_pages) < 0)
 		space = 0;
 
-	inode = object->backer->d_inode;
+	inode = d_inode(object->backer);
 	ASSERT(S_ISREG(inode->i_mode));
 	ASSERT(inode->i_mapping->a_ops->bmap);
 	ASSERT(inode->i_mapping->a_ops->readpages);
diff -u -p a/cachefiles/xattr.c b/cachefiles/xattr.c
--- a/cachefiles/xattr.c
+++ b/cachefiles/xattr.c
@@ -53,7 +53,7 @@ int cachefiles_check_object_type(struct
 	if (ret != -EEXIST) {
 		kerror("Can't set xattr on %*.*s [%lu] (err %d)",
 		       dentry->d_name.len, dentry->d_name.len,
-		       dentry->d_name.name, dentry->d_inode->i_ino,
+		       dentry->d_name.name, d_inode(dentry)->i_ino,
 		       -ret);
 		goto error;
 	}
@@ -66,7 +66,7 @@ int cachefiles_check_object_type(struct
 
 		kerror("Can't read xattr on %*.*s [%lu] (err %d)",
 		       dentry->d_name.len, dentry->d_name.len,
-		       dentry->d_name.name, dentry->d_inode->i_ino,
+		       dentry->d_name.name, d_inode(dentry)->i_ino,
 		       -ret);
 		goto error;
 	}
@@ -86,7 +86,7 @@ error:
 
 bad_type_length:
 	kerror("Cache object %lu type xattr length incorrect",
-	       dentry->d_inode->i_ino);
+	       d_inode(dentry)->i_ino);
 	ret = -EIO;
 	goto error;
 
@@ -94,7 +94,7 @@ bad_type:
 	xtype[2] = 0;
 	kerror("Cache object %*.*s [%lu] type %s not %s",
 	       dentry->d_name.len, dentry->d_name.len,
-	       dentry->d_name.name, dentry->d_inode->i_ino,
+	       dentry->d_name.name, d_inode(dentry)->i_ino,
 	       xtype, type);
 	ret = -EIO;
 	goto error;
@@ -193,7 +193,7 @@ int cachefiles_check_object_xattr(struct
 
 		cachefiles_io_error_obj(object,
 					"Can't read xattr on %lu (err %d)",
-					dentry->d_inode->i_ino, -ret);
+					d_inode(dentry)->i_ino, -ret);
 		goto error;
 	}
 
@@ -244,7 +244,7 @@ int cachefiles_check_object_xattr(struct
 			cachefiles_io_error_obj(object,
 						"Can't update xattr on %lu"
 						" (error %d)",
-						dentry->d_inode->i_ino, -ret);
+						d_inode(dentry)->i_ino, -ret);
 			goto error;
 		}
 	}
@@ -259,7 +259,7 @@ error:
 
 bad_type_length:
 	kerror("Cache object %lu xattr length incorrect",
-	       dentry->d_inode->i_ino);
+	       d_inode(dentry)->i_ino);
 	ret = -EIO;
 	goto error;
 
@@ -284,7 +284,7 @@ int cachefiles_remove_object_xattr(struc
 			cachefiles_io_error(cache,
 					    "Can't remove xattr from %lu"
 					    " (error %d)",
-					    dentry->d_inode->i_ino, -ret);
+					    d_inode(dentry)->i_ino, -ret);
 	}
 
 	_leave(" = %d", ret);
diff -u -p a/ecryptfs/inode.c b/ecryptfs/inode.c
--- a/ecryptfs/inode.c
+++ b/ecryptfs/inode.c
@@ -41,13 +41,13 @@ static struct dentry *lock_parent(struct
 	struct dentry *dir;
 
 	dir = dget_parent(dentry);
-	mutex_lock_nested(&(dir->d_inode->i_mutex), I_MUTEX_PARENT);
+	mutex_lock_nested(&(d_inode(dir)->i_mutex), I_MUTEX_PARENT);
 	return dir;
 }
 
 static void unlock_dir(struct dentry *dir)
 {
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 	dput(dir);
 }
 
@@ -133,7 +133,7 @@ struct inode *ecryptfs_get_inode(struct
 static int ecryptfs_interpose(struct dentry *lower_dentry,
 			      struct dentry *dentry, struct super_block *sb)
 {
-	struct inode *inode = ecryptfs_get_inode(lower_dentry->d_inode, sb);
+	struct inode *inode = ecryptfs_get_inode(d_inode(lower_dentry), sb);
 
 	if (IS_ERR(inode))
 		return PTR_ERR(inode);
@@ -212,7 +212,7 @@ ecryptfs_do_create(struct inode *directo
 		rc = PTR_ERR(lower_dir_dentry);
 		goto out;
 	}
-	rc = ecryptfs_create_underlying_file(lower_dir_dentry->d_inode,
+	rc = ecryptfs_create_underlying_file(d_inode(lower_dir_dentry),
 					     ecryptfs_dentry, mode, nd);
 	if (rc) {
 		printk(KERN_ERR "%s: Failure to create dentry in lower fs; "
@@ -225,8 +225,8 @@ ecryptfs_do_create(struct inode *directo
 		ecryptfs_printk(KERN_ERR, "Failure in ecryptfs_interpose\n");
 		goto out_lock;
 	}
-	fsstack_copy_attr_times(directory_inode, lower_dir_dentry->d_inode);
-	fsstack_copy_inode_size(directory_inode, lower_dir_dentry->d_inode);
+	fsstack_copy_attr_times(directory_inode, d_inode(lower_dir_dentry));
+	fsstack_copy_inode_size(directory_inode, d_inode(lower_dir_dentry));
 out_lock:
 	unlock_dir(lower_dir_dentry);
 out:
@@ -244,10 +244,10 @@ out:
 static int ecryptfs_initialize_file(struct dentry *ecryptfs_dentry)
 {
 	struct ecryptfs_crypt_stat *crypt_stat =
-		&ecryptfs_inode_to_private(ecryptfs_dentry->d_inode)->crypt_stat;
+		&ecryptfs_inode_to_private(d_inode(ecryptfs_dentry))->crypt_stat;
 	int rc = 0;
 
-	if (S_ISDIR(ecryptfs_dentry->d_inode->i_mode)) {
+	if (S_ISDIR(d_inode(ecryptfs_dentry)->i_mode)) {
 		ecryptfs_printk(KERN_DEBUG, "This is a directory\n");
 		crypt_stat->flags &= ~(ECRYPTFS_ENCRYPTED);
 		goto out;
@@ -260,7 +260,7 @@ static int ecryptfs_initialize_file(stru
 		goto out;
 	}
 	rc = ecryptfs_get_lower_file(ecryptfs_dentry,
-				     ecryptfs_dentry->d_inode);
+				     d_inode(ecryptfs_dentry));
 	if (rc) {
 		printk(KERN_ERR "%s: Error attempting to initialize "
 			"the lower file for the dentry with name "
@@ -271,7 +271,7 @@ static int ecryptfs_initialize_file(stru
 	rc = ecryptfs_write_metadata(ecryptfs_dentry);
 	if (rc)
 		printk(KERN_ERR "Error writing headers; rc = [%d]\n", rc);
-	ecryptfs_put_lower_file(ecryptfs_dentry->d_inode);
+	ecryptfs_put_lower_file(d_inode(ecryptfs_dentry));
 out:
 	return rc;
 }
@@ -345,13 +345,13 @@ static int ecryptfs_lookup_interpose(str
 				     struct dentry *lower_dentry,
 				     struct inode *dir_inode)
 {
-	struct inode *inode, *lower_inode = lower_dentry->d_inode;
+	struct inode *inode, *lower_inode = d_inode(lower_dentry);
 	struct ecryptfs_dentry_info *dentry_info;
 	struct vfsmount *lower_mnt;
 	int rc = 0;
 
 	lower_mnt = mntget(ecryptfs_dentry_to_lower_mnt(dentry->d_parent));
-	fsstack_copy_attr_atime(dir_inode, lower_dentry->d_parent->d_inode);
+	fsstack_copy_attr_atime(dir_inode, d_inode(lower_dentry->d_parent));
 	BUG_ON(!lower_dentry->d_count);
 
 	dentry_info = kmem_cache_alloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
@@ -368,7 +368,7 @@ static int ecryptfs_lookup_interpose(str
 	ecryptfs_set_dentry_lower(dentry, lower_dentry);
 	ecryptfs_set_dentry_lower_mnt(dentry, lower_mnt);
 
-	if (!lower_dentry->d_inode) {
+	if (!d_inode(lower_dentry)) {
 		/* We want to add because we couldn't find in lower */
 		d_add(dentry, NULL);
 		return 0;
@@ -420,11 +420,11 @@ static struct dentry *ecryptfs_lookup(st
 		goto out_d_drop;
 	}
 	lower_dir_dentry = ecryptfs_dentry_to_lower(ecryptfs_dentry->d_parent);
-	mutex_lock(&lower_dir_dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(lower_dir_dentry)->i_mutex);
 	lower_dentry = lookup_one_len(ecryptfs_dentry->d_name.name,
 				      lower_dir_dentry,
 				      ecryptfs_dentry->d_name.len);
-	mutex_unlock(&lower_dir_dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(lower_dir_dentry)->i_mutex);
 	if (IS_ERR(lower_dentry)) {
 		rc = PTR_ERR(lower_dentry);
 		ecryptfs_printk(KERN_DEBUG, "%s: lookup_one_len() returned "
@@ -432,7 +432,7 @@ static struct dentry *ecryptfs_lookup(st
 				encrypted_and_encoded_name);
 		goto out_d_drop;
 	}
-	if (lower_dentry->d_inode)
+	if (d_inode(lower_dentry))
 		goto interpose;
 	mount_crypt_stat = &ecryptfs_superblock_to_private(
 				ecryptfs_dentry->d_sb)->mount_crypt_stat;
@@ -449,11 +449,11 @@ static struct dentry *ecryptfs_lookup(st
 		       "filename; rc = [%d]\n", __func__, rc);
 		goto out_d_drop;
 	}
-	mutex_lock(&lower_dir_dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(lower_dir_dentry)->i_mutex);
 	lower_dentry = lookup_one_len(encrypted_and_encoded_name,
 				      lower_dir_dentry,
 				      encrypted_and_encoded_name_size);
-	mutex_unlock(&lower_dir_dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(lower_dir_dentry)->i_mutex);
 	if (IS_ERR(lower_dentry)) {
 		rc = PTR_ERR(lower_dentry);
 		ecryptfs_printk(KERN_DEBUG, "%s: lookup_one_len() returned "
@@ -481,24 +481,24 @@ static int ecryptfs_link(struct dentry *
 	u64 file_size_save;
 	int rc;
 
-	file_size_save = i_size_read(old_dentry->d_inode);
+	file_size_save = i_size_read(d_inode(old_dentry));
 	lower_old_dentry = ecryptfs_dentry_to_lower(old_dentry);
 	lower_new_dentry = ecryptfs_dentry_to_lower(new_dentry);
 	dget(lower_old_dentry);
 	dget(lower_new_dentry);
 	lower_dir_dentry = lock_parent(lower_new_dentry);
-	rc = vfs_link(lower_old_dentry, lower_dir_dentry->d_inode,
+	rc = vfs_link(lower_old_dentry, d_inode(lower_dir_dentry),
 		      lower_new_dentry);
-	if (rc || !lower_new_dentry->d_inode)
+	if (rc || !d_inode(lower_new_dentry))
 		goto out_lock;
 	rc = ecryptfs_interpose(lower_new_dentry, new_dentry, dir->i_sb);
 	if (rc)
 		goto out_lock;
-	fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
-	fsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);
-	old_dentry->d_inode->i_nlink =
-		ecryptfs_inode_to_lower(old_dentry->d_inode)->i_nlink;
-	i_size_write(new_dentry->d_inode, file_size_save);
+	fsstack_copy_attr_times(dir, d_inode(lower_dir_dentry));
+	fsstack_copy_inode_size(dir, d_inode(lower_dir_dentry));
+	d_inode(old_dentry)->i_nlink =
+			ecryptfs_inode_to_lower(d_inode(old_dentry))->i_nlink;
+	i_size_write(d_inode(new_dentry), file_size_save);
 out_lock:
 	unlock_dir(lower_dir_dentry);
 	dput(lower_new_dentry);
@@ -521,9 +521,9 @@ static int ecryptfs_unlink(struct inode
 		goto out_unlock;
 	}
 	fsstack_copy_attr_times(dir, lower_dir_inode);
-	dentry->d_inode->i_nlink =
-		ecryptfs_inode_to_lower(dentry->d_inode)->i_nlink;
-	dentry->d_inode->i_ctime = dir->i_ctime;
+	d_inode(dentry)->i_nlink =
+			ecryptfs_inode_to_lower(d_inode(dentry))->i_nlink;
+	d_inode(dentry)->i_ctime = dir->i_ctime;
 	d_drop(dentry);
 out_unlock:
 	unlock_dir(lower_dir_dentry);
@@ -553,20 +553,20 @@ static int ecryptfs_symlink(struct inode
 						  strlen(symname));
 	if (rc)
 		goto out_lock;
-	rc = vfs_symlink(lower_dir_dentry->d_inode, lower_dentry,
+	rc = vfs_symlink(d_inode(lower_dir_dentry), lower_dentry,
 			 encoded_symname);
 	kfree(encoded_symname);
-	if (rc || !lower_dentry->d_inode)
+	if (rc || !d_inode(lower_dentry))
 		goto out_lock;
 	rc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb);
 	if (rc)
 		goto out_lock;
-	fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
-	fsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);
+	fsstack_copy_attr_times(dir, d_inode(lower_dir_dentry));
+	fsstack_copy_inode_size(dir, d_inode(lower_dir_dentry));
 out_lock:
 	unlock_dir(lower_dir_dentry);
 	dput(lower_dentry);
-	if (!dentry->d_inode)
+	if (!d_inode(dentry))
 		d_drop(dentry);
 	return rc;
 }
@@ -579,18 +579,18 @@ static int ecryptfs_mkdir(struct inode *
 
 	lower_dentry = ecryptfs_dentry_to_lower(dentry);
 	lower_dir_dentry = lock_parent(lower_dentry);
-	rc = vfs_mkdir(lower_dir_dentry->d_inode, lower_dentry, mode);
-	if (rc || !lower_dentry->d_inode)
+	rc = vfs_mkdir(d_inode(lower_dir_dentry), lower_dentry, mode);
+	if (rc || !d_inode(lower_dentry))
 		goto out;
 	rc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb);
 	if (rc)
 		goto out;
-	fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
-	fsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);
-	dir->i_nlink = lower_dir_dentry->d_inode->i_nlink;
+	fsstack_copy_attr_times(dir, d_inode(lower_dir_dentry));
+	fsstack_copy_inode_size(dir, d_inode(lower_dir_dentry));
+	dir->i_nlink = d_inode(lower_dir_dentry)->i_nlink;
 out:
 	unlock_dir(lower_dir_dentry);
-	if (!dentry->d_inode)
+	if (!d_inode(dentry))
 		d_drop(dentry);
 	return rc;
 }
@@ -605,12 +605,12 @@ static int ecryptfs_rmdir(struct inode *
 	dget(dentry);
 	lower_dir_dentry = lock_parent(lower_dentry);
 	dget(lower_dentry);
-	rc = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry);
+	rc = vfs_rmdir(d_inode(lower_dir_dentry), lower_dentry);
 	dput(lower_dentry);
-	if (!rc && dentry->d_inode)
-		clear_nlink(dentry->d_inode);
-	fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
-	dir->i_nlink = lower_dir_dentry->d_inode->i_nlink;
+	if (!rc && d_inode(dentry))
+		clear_nlink(d_inode(dentry));
+	fsstack_copy_attr_times(dir, d_inode(lower_dir_dentry));
+	dir->i_nlink = d_inode(lower_dir_dentry)->i_nlink;
 	unlock_dir(lower_dir_dentry);
 	if (!rc)
 		d_drop(dentry);
@@ -627,17 +627,17 @@ ecryptfs_mknod(struct inode *dir, struct
 
 	lower_dentry = ecryptfs_dentry_to_lower(dentry);
 	lower_dir_dentry = lock_parent(lower_dentry);
-	rc = vfs_mknod(lower_dir_dentry->d_inode, lower_dentry, mode, dev);
-	if (rc || !lower_dentry->d_inode)
+	rc = vfs_mknod(d_inode(lower_dir_dentry), lower_dentry, mode, dev);
+	if (rc || !d_inode(lower_dentry))
 		goto out;
 	rc = ecryptfs_interpose(lower_dentry, dentry, dir->i_sb);
 	if (rc)
 		goto out;
-	fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
-	fsstack_copy_inode_size(dir, lower_dir_dentry->d_inode);
+	fsstack_copy_attr_times(dir, d_inode(lower_dir_dentry));
+	fsstack_copy_inode_size(dir, d_inode(lower_dir_dentry));
 out:
 	unlock_dir(lower_dir_dentry);
-	if (!dentry->d_inode)
+	if (!d_inode(dentry))
 		d_drop(dentry);
 	return rc;
 }
@@ -670,13 +670,13 @@ ecryptfs_rename(struct inode *old_dir, s
 		rc = -ENOTEMPTY;
 		goto out_lock;
 	}
-	rc = vfs_rename(lower_old_dir_dentry->d_inode, lower_old_dentry,
-			lower_new_dir_dentry->d_inode, lower_new_dentry);
+	rc = vfs_rename(d_inode(lower_old_dir_dentry), lower_old_dentry,
+			d_inode(lower_new_dir_dentry), lower_new_dentry);
 	if (rc)
 		goto out_lock;
-	fsstack_copy_attr_all(new_dir, lower_new_dir_dentry->d_inode);
+	fsstack_copy_attr_all(new_dir, d_inode(lower_new_dir_dentry));
 	if (new_dir != old_dir)
-		fsstack_copy_attr_all(old_dir, lower_old_dir_dentry->d_inode);
+		fsstack_copy_attr_all(old_dir, d_inode(lower_old_dir_dentry));
 out_lock:
 	unlock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
 	dput(lower_new_dir_dentry);
@@ -702,7 +702,7 @@ static int ecryptfs_readlink_lower(struc
 	}
 	old_fs = get_fs();
 	set_fs(get_ds());
-	rc = lower_dentry->d_inode->i_op->readlink(lower_dentry,
+	rc = d_inode(lower_dentry)->i_op->readlink(lower_dentry,
 						   (char __user *)lower_buf,
 						   lower_bufsiz);
 	set_fs(old_fs);
@@ -729,8 +729,8 @@ ecryptfs_readlink(struct dentry *dentry,
 	copied = min_t(size_t, bufsiz, kbufsiz);
 	rc = copy_to_user(buf, kbuf, copied) ? -EFAULT : copied;
 	kfree(kbuf);
-	fsstack_copy_attr_atime(dentry->d_inode,
-				ecryptfs_dentry_to_lower(dentry)->d_inode);
+	fsstack_copy_attr_atime(d_inode(dentry),
+				d_inode(ecryptfs_dentry_to_lower(dentry)));
 out:
 	return rc;
 }
@@ -749,7 +749,7 @@ static void *ecryptfs_follow_link(struct
 	}
 	old_fs = get_fs();
 	set_fs(get_ds());
-	rc = dentry->d_inode->i_op->readlink(dentry, (char __user *)buf, len);
+	rc = d_inode(dentry)->i_op->readlink(dentry, (char __user *)buf, len);
 	set_fs(old_fs);
 	if (rc < 0) {
 		kfree(buf);
@@ -820,7 +820,7 @@ static int truncate_upper(struct dentry
 			  struct iattr *lower_ia)
 {
 	int rc = 0;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct ecryptfs_crypt_stat *crypt_stat;
 	loff_t i_size = i_size_read(inode);
 	loff_t lower_size_before_truncate;
@@ -833,7 +833,7 @@ static int truncate_upper(struct dentry
 	rc = ecryptfs_get_lower_file(dentry, inode);
 	if (rc)
 		return rc;
-	crypt_stat = &ecryptfs_inode_to_private(dentry->d_inode)->crypt_stat;
+	crypt_stat = &ecryptfs_inode_to_private(d_inode(dentry))->crypt_stat;
 	/* Switch on growing or shrinking file */
 	if (ia->ia_size > i_size) {
 		char zero[] = { 0x00 };
@@ -934,9 +934,9 @@ int ecryptfs_truncate(struct dentry *den
 	if (!rc && lower_ia.ia_valid & ATTR_SIZE) {
 		struct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);
 
-		mutex_lock(&lower_dentry->d_inode->i_mutex);
+		mutex_lock(&d_inode(lower_dentry)->i_mutex);
 		rc = notify_change(lower_dentry, &lower_ia);
-		mutex_unlock(&lower_dentry->d_inode->i_mutex);
+		mutex_unlock(&d_inode(lower_dentry)->i_mutex);
 	}
 	return rc;
 }
@@ -970,16 +970,16 @@ static int ecryptfs_setattr(struct dentr
 	struct inode *lower_inode;
 	struct ecryptfs_crypt_stat *crypt_stat;
 
-	crypt_stat = &ecryptfs_inode_to_private(dentry->d_inode)->crypt_stat;
+	crypt_stat = &ecryptfs_inode_to_private(d_inode(dentry))->crypt_stat;
 	if (!(crypt_stat->flags & ECRYPTFS_STRUCT_INITIALIZED))
 		ecryptfs_init_crypt_stat(crypt_stat);
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	lower_inode = ecryptfs_inode_to_lower(inode);
 	lower_dentry = ecryptfs_dentry_to_lower(dentry);
 	mutex_lock(&crypt_stat->cs_mutex);
-	if (S_ISDIR(dentry->d_inode->i_mode))
+	if (S_ISDIR(d_inode(dentry)->i_mode))
 		crypt_stat->flags &= ~(ECRYPTFS_ENCRYPTED);
-	else if (S_ISREG(dentry->d_inode->i_mode)
+	else if (S_ISREG(d_inode(dentry)->i_mode)
 		 && (!(crypt_stat->flags & ECRYPTFS_POLICY_APPLIED)
 		     || !(crypt_stat->flags & ECRYPTFS_KEY_VALID))) {
 		struct ecryptfs_mount_crypt_stat *mount_crypt_stat;
@@ -1033,9 +1033,9 @@ static int ecryptfs_setattr(struct dentr
 	if (lower_ia.ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID))
 		lower_ia.ia_valid &= ~ATTR_MODE;
 
-	mutex_lock(&lower_dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(lower_dentry)->i_mutex);
 	rc = notify_change(lower_dentry, &lower_ia);
-	mutex_unlock(&lower_dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(lower_dentry)->i_mutex);
 out:
 	fsstack_copy_attr_all(inode, lower_inode);
 	return rc;
@@ -1049,7 +1049,7 @@ int ecryptfs_getattr_link(struct vfsmoun
 
 	mount_crypt_stat = &ecryptfs_superblock_to_private(
 						dentry->d_sb)->mount_crypt_stat;
-	generic_fillattr(dentry->d_inode, stat);
+	generic_fillattr(d_inode(dentry), stat);
 	if (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) {
 		char *target;
 		size_t targetsiz;
@@ -1072,9 +1072,9 @@ int ecryptfs_getattr(struct vfsmount *mn
 	rc = vfs_getattr(ecryptfs_dentry_to_lower_mnt(dentry),
 			 ecryptfs_dentry_to_lower(dentry), &lower_stat);
 	if (!rc) {
-		fsstack_copy_attr_all(dentry->d_inode,
-				      ecryptfs_inode_to_lower(dentry->d_inode));
-		generic_fillattr(dentry->d_inode, stat);
+		fsstack_copy_attr_all(d_inode(dentry),
+				      ecryptfs_inode_to_lower(d_inode(dentry)));
+		generic_fillattr(d_inode(dentry), stat);
 		stat->blocks = lower_stat.blocks;
 	}
 	return rc;
@@ -1088,7 +1088,7 @@ ecryptfs_setxattr(struct dentry *dentry,
 	struct dentry *lower_dentry;
 
 	lower_dentry = ecryptfs_dentry_to_lower(dentry);
-	if (!lower_dentry->d_inode->i_op->setxattr) {
+	if (!d_inode(lower_dentry)->i_op->setxattr) {
 		rc = -EOPNOTSUPP;
 		goto out;
 	}
@@ -1104,14 +1104,14 @@ ecryptfs_getxattr_lower(struct dentry *l
 {
 	int rc = 0;
 
-	if (!lower_dentry->d_inode->i_op->getxattr) {
+	if (!d_inode(lower_dentry)->i_op->getxattr) {
 		rc = -EOPNOTSUPP;
 		goto out;
 	}
-	mutex_lock(&lower_dentry->d_inode->i_mutex);
-	rc = lower_dentry->d_inode->i_op->getxattr(lower_dentry, name, value,
+	mutex_lock(&d_inode(lower_dentry)->i_mutex);
+	rc = d_inode(lower_dentry)->i_op->getxattr(lower_dentry, name, value,
 						   size);
-	mutex_unlock(&lower_dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(lower_dentry)->i_mutex);
 out:
 	return rc;
 }
@@ -1131,13 +1131,13 @@ ecryptfs_listxattr(struct dentry *dentry
 	struct dentry *lower_dentry;
 
 	lower_dentry = ecryptfs_dentry_to_lower(dentry);
-	if (!lower_dentry->d_inode->i_op->listxattr) {
+	if (!d_inode(lower_dentry)->i_op->listxattr) {
 		rc = -EOPNOTSUPP;
 		goto out;
 	}
-	mutex_lock(&lower_dentry->d_inode->i_mutex);
-	rc = lower_dentry->d_inode->i_op->listxattr(lower_dentry, list, size);
-	mutex_unlock(&lower_dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(lower_dentry)->i_mutex);
+	rc = d_inode(lower_dentry)->i_op->listxattr(lower_dentry, list, size);
+	mutex_unlock(&d_inode(lower_dentry)->i_mutex);
 out:
 	return rc;
 }
@@ -1148,13 +1148,13 @@ static int ecryptfs_removexattr(struct d
 	struct dentry *lower_dentry;
 
 	lower_dentry = ecryptfs_dentry_to_lower(dentry);
-	if (!lower_dentry->d_inode->i_op->removexattr) {
+	if (!d_inode(lower_dentry)->i_op->removexattr) {
 		rc = -EOPNOTSUPP;
 		goto out;
 	}
-	mutex_lock(&lower_dentry->d_inode->i_mutex);
-	rc = lower_dentry->d_inode->i_op->removexattr(lower_dentry, name);
-	mutex_unlock(&lower_dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(lower_dentry)->i_mutex);
+	rc = d_inode(lower_dentry)->i_op->removexattr(lower_dentry, name);
+	mutex_unlock(&d_inode(lower_dentry)->i_mutex);
 out:
 	return rc;
 }
diff -u -p a/ecryptfs/kthread.c b/ecryptfs/kthread.c
--- a/ecryptfs/kthread.c
+++ b/ecryptfs/kthread.c
@@ -145,7 +145,7 @@ int ecryptfs_privileged_open(struct file
 	 * released. */
 	dget(lower_dentry);
 	mntget(lower_mnt);
-	flags |= IS_RDONLY(lower_dentry->d_inode) ? O_RDONLY : O_RDWR;
+	flags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;
 	(*lower_file) = dentry_open(lower_dentry, lower_mnt, flags, cred);
 	if (!IS_ERR(*lower_file))
 		goto out;
diff -u -p a/ecryptfs/crypto.c b/ecryptfs/crypto.c
--- a/ecryptfs/crypto.c
+++ b/ecryptfs/crypto.c
@@ -987,7 +987,7 @@ static void ecryptfs_set_default_crypt_s
 int ecryptfs_new_file_context(struct dentry *ecryptfs_dentry)
 {
 	struct ecryptfs_crypt_stat *crypt_stat =
-	    &ecryptfs_inode_to_private(ecryptfs_dentry->d_inode)->crypt_stat;
+	    &ecryptfs_inode_to_private(d_inode(ecryptfs_dentry))->crypt_stat;
 	struct ecryptfs_mount_crypt_stat *mount_crypt_stat =
 	    &ecryptfs_superblock_to_private(
 		    ecryptfs_dentry->d_sb)->mount_crypt_stat;
@@ -1304,7 +1304,7 @@ ecryptfs_write_metadata_to_contents(stru
 {
 	int rc;
 
-	rc = ecryptfs_write_lower(ecryptfs_dentry->d_inode, virt,
+	rc = ecryptfs_write_lower(d_inode(ecryptfs_dentry), virt,
 				  0, virt_len);
 	if (rc < 0)
 		printk(KERN_ERR "%s: Error attempting to write header "
@@ -1351,7 +1351,7 @@ static unsigned long ecryptfs_get_zeroed
 int ecryptfs_write_metadata(struct dentry *ecryptfs_dentry)
 {
 	struct ecryptfs_crypt_stat *crypt_stat =
-		&ecryptfs_inode_to_private(ecryptfs_dentry->d_inode)->crypt_stat;
+		&ecryptfs_inode_to_private(d_inode(ecryptfs_dentry))->crypt_stat;
 	unsigned int order;
 	char *virt;
 	size_t virt_len;
@@ -1491,7 +1491,7 @@ static int ecryptfs_read_headers_virt(ch
 	if (rc)
 		goto out;
 	if (!(crypt_stat->flags & ECRYPTFS_I_SIZE_INITIALIZED))
-		ecryptfs_i_size_init(page_virt, ecryptfs_dentry->d_inode);
+		ecryptfs_i_size_init(page_virt, d_inode(ecryptfs_dentry));
 	offset += MAGIC_ECRYPTFS_MARKER_SIZE_BYTES;
 	rc = ecryptfs_process_flags(crypt_stat, (page_virt + offset),
 				    &bytes_read);
@@ -1590,7 +1590,7 @@ int ecryptfs_read_metadata(struct dentry
 {
 	int rc = 0;
 	char *page_virt = NULL;
-	struct inode *ecryptfs_inode = ecryptfs_dentry->d_inode;
+	struct inode *ecryptfs_inode = d_inode(ecryptfs_dentry);
 	struct ecryptfs_crypt_stat *crypt_stat =
 	    &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;
 	struct ecryptfs_mount_crypt_stat *mount_crypt_stat =
diff -u -p a/ecryptfs/dentry.c b/ecryptfs/dentry.c
--- a/ecryptfs/dentry.c
+++ b/ecryptfs/dentry.c
@@ -68,11 +68,11 @@ static int ecryptfs_d_revalidate(struct
 		nd->path.dentry = dentry_save;
 		nd->path.mnt = vfsmount_save;
 	}
-	if (dentry->d_inode) {
+	if (d_inode(dentry)) {
 		struct inode *lower_inode =
-			ecryptfs_inode_to_lower(dentry->d_inode);
+			ecryptfs_inode_to_lower(d_inode(dentry));
 
-		fsstack_copy_attr_all(dentry->d_inode, lower_inode);
+		fsstack_copy_attr_all(d_inode(dentry), lower_inode);
 	}
 out:
 	return rc;
diff -u -p a/ecryptfs/file.c b/ecryptfs/file.c
--- a/ecryptfs/file.c
+++ b/ecryptfs/file.c
@@ -119,7 +119,7 @@ static int ecryptfs_readdir(struct file
 
 	lower_file = ecryptfs_file_to_lower(file);
 	lower_file->f_pos = file->f_pos;
-	inode = file->f_path.dentry->d_inode;
+	inode = d_inode(file->f_path.dentry);
 	memset(&buf, 0, sizeof(buf));
 	buf.dirent = dirent;
 	buf.dentry = file->f_path.dentry;
@@ -134,7 +134,7 @@ static int ecryptfs_readdir(struct file
 		goto out;
 	if (rc >= 0)
 		fsstack_copy_attr_atime(inode,
-					lower_file->f_path.dentry->d_inode);
+					d_inode(lower_file->f_path.dentry));
 out:
 	return rc;
 }
@@ -208,7 +208,7 @@ static int ecryptfs_open(struct inode *i
 	}
 	ecryptfs_set_file_lower(
 		file, ecryptfs_inode_to_private(inode)->lower_file);
-	if (S_ISDIR(ecryptfs_dentry->d_inode->i_mode)) {
+	if (S_ISDIR(d_inode(ecryptfs_dentry)->i_mode)) {
 		ecryptfs_printk(KERN_DEBUG, "This is a directory\n");
 		mutex_lock(&crypt_stat->cs_mutex);
 		crypt_stat->flags &= ~(ECRYPTFS_ENCRYPTED);
diff -u -p a/ecryptfs/mmap.c b/ecryptfs/mmap.c
--- a/ecryptfs/mmap.c
+++ b/ecryptfs/mmap.c
@@ -427,7 +427,7 @@ static int ecryptfs_write_inode_size_to_
 	void *xattr_virt;
 	struct dentry *lower_dentry =
 		ecryptfs_inode_to_private(ecryptfs_inode)->lower_file->f_dentry;
-	struct inode *lower_inode = lower_dentry->d_inode;
+	struct inode *lower_inode = d_inode(lower_dentry);
 	int rc;
 
 	if (!lower_inode->i_op->getxattr || !lower_inode->i_op->setxattr) {
diff -u -p a/ecryptfs/main.c b/ecryptfs/main.c
--- a/ecryptfs/main.c
+++ b/ecryptfs/main.c
@@ -526,7 +526,7 @@ static struct dentry *ecryptfs_mount(str
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
 
-	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
+	inode = ecryptfs_get_inode(d_inode(path.dentry), s);
 	rc = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out_free;
diff -u -p a/btrfs/super.c b/btrfs/super.c
--- a/btrfs/super.c
+++ b/btrfs/super.c
@@ -561,7 +561,7 @@ setup_root:
 	 * a reference to the dentry.  We will have already gotten a reference
 	 * to the inode in btrfs_fill_super so we're good to go.
 	 */
-	if (!new && sb->s_root->d_inode == inode) {
+	if (!new && d_inode(sb->s_root) == inode) {
 		iput(inode);
 		return dget(sb->s_root);
 	}
@@ -855,10 +855,10 @@ static struct dentry *btrfs_mount(struct
 			goto error_free_subvol_name;
 		}
 
-		mutex_lock(&root->d_inode->i_mutex);
+		mutex_lock(&d_inode(root)->i_mutex);
 		new_root = lookup_one_len(subvol_name, root,
 				      strlen(subvol_name));
-		mutex_unlock(&root->d_inode->i_mutex);
+		mutex_unlock(&d_inode(root)->i_mutex);
 
 		if (IS_ERR(new_root)) {
 			dput(root);
@@ -866,7 +866,7 @@ static struct dentry *btrfs_mount(struct
 			error = PTR_ERR(new_root);
 			goto error_free_subvol_name;
 		}
-		if (!new_root->d_inode) {
+		if (!d_inode(new_root)) {
 			dput(root);
 			dput(new_root);
 			deactivate_locked_super(s);
@@ -1129,8 +1129,8 @@ static int btrfs_statfs(struct dentry *d
 	buf->f_fsid.val[0] = be32_to_cpu(fsid[0]) ^ be32_to_cpu(fsid[2]);
 	buf->f_fsid.val[1] = be32_to_cpu(fsid[1]) ^ be32_to_cpu(fsid[3]);
 	/* Mask in the root object ID too, to disambiguate subvols */
-	buf->f_fsid.val[0] ^= BTRFS_I(dentry->d_inode)->root->objectid >> 32;
-	buf->f_fsid.val[1] ^= BTRFS_I(dentry->d_inode)->root->objectid;
+	buf->f_fsid.val[0] ^= BTRFS_I(d_inode(dentry))->root->objectid >> 32;
+	buf->f_fsid.val[1] ^= BTRFS_I(d_inode(dentry))->root->objectid;
 
 	return 0;
 }
diff -u -p a/btrfs/transaction.c b/btrfs/transaction.c
--- a/btrfs/transaction.c
+++ b/btrfs/transaction.c
@@ -937,7 +937,7 @@ static noinline int create_pending_snaps
 
 	dentry = pending->dentry;
 	parent = dget_parent(dentry);
-	parent_inode = parent->d_inode;
+	parent_inode = d_inode(parent);
 	parent_root = BTRFS_I(parent_inode)->root;
 	record_root_in_trans(trans, parent_root);
 
diff -u -p a/btrfs/inode.c b/btrfs/inode.c
--- a/btrfs/inode.c
+++ b/btrfs/inode.c
@@ -2849,7 +2849,7 @@ static struct btrfs_trans_handle *__unli
 	struct btrfs_path *path;
 	struct btrfs_inode_ref *ref;
 	struct btrfs_dir_item *di;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	u64 index;
 	int check_link = 1;
 	int err = -ENOSPC;
@@ -3009,7 +3009,7 @@ static int btrfs_unlink(struct inode *di
 {
 	struct btrfs_root *root = BTRFS_I(dir)->root;
 	struct btrfs_trans_handle *trans;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int ret;
 	unsigned long nr = 0;
 
@@ -3017,9 +3017,9 @@ static int btrfs_unlink(struct inode *di
 	if (IS_ERR(trans))
 		return PTR_ERR(trans);
 
-	btrfs_record_unlink_dir(trans, dir, dentry->d_inode, 0);
+	btrfs_record_unlink_dir(trans, dir, d_inode(dentry), 0);
 
-	ret = btrfs_unlink_inode(trans, root, dir, dentry->d_inode,
+	ret = btrfs_unlink_inode(trans, root, dir, d_inode(dentry),
 				 dentry->d_name.name, dentry->d_name.len);
 	BUG_ON(ret);
 
@@ -3092,7 +3092,7 @@ int btrfs_unlink_subvol(struct btrfs_tra
 
 static int btrfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int err = 0;
 	struct btrfs_root *root = BTRFS_I(dir)->root;
 	struct btrfs_trans_handle *trans;
@@ -3119,7 +3119,7 @@ static int btrfs_rmdir(struct inode *dir
 		goto out;
 
 	/* now the directory is empty */
-	err = btrfs_unlink_inode(trans, root, dir, dentry->d_inode,
+	err = btrfs_unlink_inode(trans, root, dir, d_inode(dentry),
 				 dentry->d_name.name, dentry->d_name.len);
 	if (!err)
 		btrfs_i_size_write(inode, 0);
@@ -3595,7 +3595,7 @@ static int btrfs_setsize(struct inode *i
 
 static int btrfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	int err;
 
@@ -4065,11 +4065,11 @@ static int btrfs_dentry_delete(const str
 {
 	struct btrfs_root *root;
 
-	if (!dentry->d_inode && !IS_ROOT(dentry))
+	if (!d_inode(dentry) && !IS_ROOT(dentry))
 		dentry = dentry->d_parent;
 
-	if (dentry->d_inode) {
-		root = BTRFS_I(dentry->d_inode)->root;
+	if (d_inode(dentry)) {
+		root = BTRFS_I(d_inode(dentry))->root;
 		if (btrfs_root_refs(&root->root_item) == 0)
 			return 1;
 	}
@@ -4095,7 +4095,7 @@ unsigned char btrfs_filetype_table[] = {
 static int btrfs_real_readdir(struct file *filp, void *dirent,
 			      filldir_t filldir)
 {
-	struct inode *inode = filp->f_dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_dentry);
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_item *item;
 	struct btrfs_dir_item *di;
@@ -4735,7 +4735,7 @@ static int btrfs_link(struct dentry *old
 {
 	struct btrfs_trans_handle *trans;
 	struct btrfs_root *root = BTRFS_I(dir)->root;
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	u64 index;
 	unsigned long nr = 0;
 	int err;
@@ -6389,7 +6389,7 @@ static void btrfs_invalidatepage(struct
 int btrfs_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)
 {
 	struct page *page = vmf->page;
-	struct inode *inode = fdentry(vma->vm_file)->d_inode;
+	struct inode *inode = d_inode(fdentry(vma->vm_file));
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;
 	struct btrfs_ordered_extent *ordered;
@@ -6898,7 +6898,7 @@ fail:
 static int btrfs_getattr(struct vfsmount *mnt,
 			 struct dentry *dentry, struct kstat *stat)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	generic_fillattr(inode, stat);
 	stat->dev = BTRFS_I(inode)->root->anon_super.s_dev;
 	stat->blksize = PAGE_CACHE_SIZE;
@@ -6933,8 +6933,8 @@ static int btrfs_rename(struct inode *ol
 	struct btrfs_trans_handle *trans;
 	struct btrfs_root *root = BTRFS_I(old_dir)->root;
 	struct btrfs_root *dest = BTRFS_I(new_dir)->root;
-	struct inode *new_inode = new_dentry->d_inode;
-	struct inode *old_inode = old_dentry->d_inode;
+	struct inode *new_inode = d_inode(new_dentry);
+	struct inode *old_inode = d_inode(old_dentry);
 	struct timespec ctime = CURRENT_TIME;
 	u64 index = 0;
 	u64 root_objectid;
@@ -7029,7 +7029,7 @@ static int btrfs_rename(struct inode *ol
 					old_dentry->d_name.len);
 	} else {
 		ret = __btrfs_unlink_inode(trans, root, old_dir,
-					old_dentry->d_inode,
+					d_inode(old_dentry),
 					old_dentry->d_name.name,
 					old_dentry->d_name.len);
 		if (!ret)
@@ -7049,13 +7049,13 @@ static int btrfs_rename(struct inode *ol
 			BUG_ON(new_inode->i_nlink == 0);
 		} else {
 			ret = btrfs_unlink_inode(trans, dest, new_dir,
-						 new_dentry->d_inode,
+						 d_inode(new_dentry),
 						 new_dentry->d_name.name,
 						 new_dentry->d_name.len);
 		}
 		BUG_ON(ret);
 		if (new_inode->i_nlink == 0) {
-			ret = btrfs_orphan_add(trans, new_dentry->d_inode);
+			ret = btrfs_orphan_add(trans, d_inode(new_dentry));
 			BUG_ON(ret);
 		}
 	}
diff -u -p a/btrfs/tree-log.c b/btrfs/tree-log.c
--- a/btrfs/tree-log.c
+++ b/btrfs/tree-log.c
@@ -2941,9 +2941,9 @@ static noinline int check_parent_dirs_fo
 			goto out;
 
 	if (!S_ISDIR(inode->i_mode)) {
-		if (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)
+		if (!parent || !d_inode(parent) || sb != d_inode(parent)->i_sb)
 			goto out;
-		inode = parent->d_inode;
+		inode = d_inode(parent);
 	}
 
 	while (1) {
@@ -2963,7 +2963,7 @@ static noinline int check_parent_dirs_fo
 			break;
 		}
 
-		if (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)
+		if (!parent || !d_inode(parent) || sb != d_inode(parent)->i_sb)
 			break;
 
 		if (IS_ROOT(parent))
@@ -2972,7 +2972,7 @@ static noinline int check_parent_dirs_fo
 		parent = dget_parent(parent);
 		dput(old_parent);
 		old_parent = parent;
-		inode = parent->d_inode;
+		inode = d_inode(parent);
 
 	}
 	dput(old_parent);
@@ -3063,10 +3063,10 @@ int btrfs_log_inode_parent(struct btrfs_
 
 	inode_only = LOG_INODE_EXISTS;
 	while (1) {
-		if (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)
+		if (!parent || !d_inode(parent) || sb != d_inode(parent)->i_sb)
 			break;
 
-		inode = parent->d_inode;
+		inode = d_inode(parent);
 		if (root != BTRFS_I(inode)->root)
 			break;
 
@@ -3108,7 +3108,7 @@ int btrfs_log_dentry_safe(struct btrfs_t
 	struct dentry *parent = dget_parent(dentry);
 	int ret;
 
-	ret = btrfs_log_inode_parent(trans, root, dentry->d_inode, parent, 0);
+	ret = btrfs_log_inode_parent(trans, root, d_inode(dentry), parent, 0);
 	dput(parent);
 
 	return ret;
diff -u -p a/btrfs/file.c b/btrfs/file.c
--- a/btrfs/file.c
+++ b/btrfs/file.c
@@ -1064,7 +1064,7 @@ static noinline int prepare_pages(struct
 	struct extent_state *cached_state = NULL;
 	int i;
 	unsigned long index = pos >> PAGE_CACHE_SHIFT;
-	struct inode *inode = fdentry(file)->d_inode;
+	struct inode *inode = d_inode(fdentry(file));
 	int err = 0;
 	int faili = 0;
 	u64 start_pos;
@@ -1154,7 +1154,7 @@ static noinline ssize_t __btrfs_buffered
 					       struct iov_iter *i,
 					       loff_t pos)
 {
-	struct inode *inode = fdentry(file)->d_inode;
+	struct inode *inode = d_inode(fdentry(file));
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct page **pages = NULL;
 	unsigned long first_index;
@@ -1283,7 +1283,7 @@ static ssize_t __btrfs_direct_write(stru
 				    loff_t *ppos, size_t count, size_t ocount)
 {
 	struct file *file = iocb->ki_filp;
-	struct inode *inode = fdentry(file)->d_inode;
+	struct inode *inode = d_inode(fdentry(file));
 	struct iov_iter i;
 	ssize_t written;
 	ssize_t written_buffered;
@@ -1333,7 +1333,7 @@ static ssize_t btrfs_file_aio_write(stru
 				    unsigned long nr_segs, loff_t pos)
 {
 	struct file *file = iocb->ki_filp;
-	struct inode *inode = fdentry(file)->d_inode;
+	struct inode *inode = d_inode(fdentry(file));
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	loff_t *ppos = &iocb->ki_pos;
 	ssize_t num_written = 0;
@@ -1455,7 +1455,7 @@ int btrfs_release_file(struct inode *ino
 int btrfs_sync_file(struct file *file, int datasync)
 {
 	struct dentry *dentry = file->f_path.dentry;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	int ret = 0;
 	struct btrfs_trans_handle *trans;
@@ -1513,7 +1513,7 @@ int btrfs_sync_file(struct file *file, i
 	 * file again, but that will end up using the synchronization
 	 * inside btrfs_sync_log to keep things safe.
 	 */
-	mutex_unlock(&dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dentry)->i_mutex);
 
 	if (ret != BTRFS_NO_LOG_SYNC) {
 		if (ret > 0) {
@@ -1528,7 +1528,7 @@ int btrfs_sync_file(struct file *file, i
 	} else {
 		ret = btrfs_end_transaction(trans, root);
 	}
-	mutex_lock(&dentry->d_inode->i_mutex);
+	mutex_lock(&d_inode(dentry)->i_mutex);
 out:
 	return ret > 0 ? -EIO : ret;
 }
@@ -1555,7 +1555,7 @@ static int btrfs_file_mmap(struct file	*
 static long btrfs_fallocate(struct file *file, int mode,
 			    loff_t offset, loff_t len)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct extent_state *cached_state = NULL;
 	u64 cur_offset;
 	u64 last_byte;
diff -u -p a/btrfs/export.c b/btrfs/export.c
--- a/btrfs/export.c
+++ b/btrfs/export.c
@@ -17,7 +17,7 @@ static int btrfs_encode_fh(struct dentry
 			   int connectable)
 {
 	struct btrfs_fid *fid = (struct btrfs_fid *)fh;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int len = *max_len;
 	int type;
 
@@ -42,7 +42,7 @@ static int btrfs_encode_fh(struct dentry
 
 		spin_lock(&dentry->d_lock);
 
-		parent = dentry->d_parent->d_inode;
+		parent = d_inode(dentry->d_parent);
 		fid->parent_objectid = BTRFS_I(parent)->location.objectid;
 		fid->parent_gen = parent->i_generation;
 		parent_root_id = BTRFS_I(parent)->root->objectid;
@@ -165,7 +165,7 @@ static struct dentry *btrfs_fh_to_dentry
 
 static struct dentry *btrfs_get_parent(struct dentry *child)
 {
-	struct inode *dir = child->d_inode;
+	struct inode *dir = d_inode(child);
 	struct btrfs_root *root = BTRFS_I(dir)->root;
 	struct btrfs_path *path;
 	struct extent_buffer *leaf;
@@ -233,8 +233,8 @@ fail:
 static int btrfs_get_name(struct dentry *parent, char *name,
 			  struct dentry *child)
 {
-	struct inode *inode = child->d_inode;
-	struct inode *dir = parent->d_inode;
+	struct inode *inode = d_inode(child);
+	struct inode *dir = d_inode(parent);
 	struct btrfs_path *path;
 	struct btrfs_root *root = BTRFS_I(dir)->root;
 	struct btrfs_inode_ref *iref;
diff -u -p a/btrfs/ioctl.c b/btrfs/ioctl.c
--- a/btrfs/ioctl.c
+++ b/btrfs/ioctl.c
@@ -139,7 +139,7 @@ void btrfs_inherit_iflags(struct inode *
 
 static int btrfs_ioctl_getflags(struct file *file, void __user *arg)
 {
-	struct btrfs_inode *ip = BTRFS_I(file->f_path.dentry->d_inode);
+	struct btrfs_inode *ip = BTRFS_I(d_inode(file->f_path.dentry));
 	unsigned int flags = btrfs_flags_to_ioctl(ip->flags);
 
 	if (copy_to_user(arg, &flags, sizeof(flags)))
@@ -164,7 +164,7 @@ static int check_flags(unsigned int flag
 
 static int btrfs_ioctl_setflags(struct file *file, void __user *arg)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 	struct btrfs_inode *ip = BTRFS_I(inode);
 	struct btrfs_root *root = ip->root;
 	struct btrfs_trans_handle *trans;
@@ -263,7 +263,7 @@ static int btrfs_ioctl_setflags(struct f
 
 static int btrfs_ioctl_getversion(struct file *file, int __user *arg)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(file->f_path.dentry);
 
 	return put_user(inode->i_generation, arg);
 }
@@ -337,7 +337,7 @@ static noinline int create_subvol(struct
 		return ret;
 	}
 
-	dir = parent->d_inode;
+	dir = d_inode(parent);
 
 	/*
 	 * 1 - inode item
@@ -505,7 +505,7 @@ static int create_snapshot(struct btrfs_
 		goto fail;
 
 	parent = dget_parent(dentry);
-	inode = btrfs_lookup_dentry(parent->d_inode, dentry);
+	inode = btrfs_lookup_dentry(d_inode(parent), dentry);
 	dput(parent);
 	if (IS_ERR(inode)) {
 		ret = PTR_ERR(inode);
@@ -560,10 +560,10 @@ static int btrfs_may_delete(struct inode
 {
 	int error;
 
-	if (!victim->d_inode)
+	if (!d_inode(victim))
 		return -ENOENT;
 
-	BUG_ON(victim->d_parent->d_inode != dir);
+	BUG_ON(d_inode(victim->d_parent) != dir);
 	audit_inode_child(victim, dir);
 
 	error = inode_permission(dir, MAY_WRITE | MAY_EXEC);
@@ -571,16 +571,16 @@ static int btrfs_may_delete(struct inode
 		return error;
 	if (IS_APPEND(dir))
 		return -EPERM;
-	if (btrfs_check_sticky(dir, victim->d_inode)||
-		IS_APPEND(victim->d_inode)||
-	    IS_IMMUTABLE(victim->d_inode) || IS_SWAPFILE(victim->d_inode))
+	if (btrfs_check_sticky(dir, d_inode(victim))||
+		IS_APPEND(d_inode(victim))||
+		IS_IMMUTABLE(d_inode(victim)) || IS_SWAPFILE(d_inode(victim)))
 		return -EPERM;
 	if (isdir) {
-		if (!S_ISDIR(victim->d_inode->i_mode))
+		if (!S_ISDIR(d_inode(victim)->i_mode))
 			return -ENOTDIR;
 		if (IS_ROOT(victim))
 			return -EBUSY;
-	} else if (S_ISDIR(victim->d_inode->i_mode))
+	} else if (S_ISDIR(d_inode(victim)->i_mode))
 		return -EISDIR;
 	if (IS_DEADDIR(dir))
 		return -ENOENT;
@@ -592,7 +592,7 @@ static int btrfs_may_delete(struct inode
 /* copy of may_create in fs/namei.c() */
 static inline int btrfs_may_create(struct inode *dir, struct dentry *child)
 {
-	if (child->d_inode)
+	if (d_inode(child))
 		return -EEXIST;
 	if (IS_DEADDIR(dir))
 		return -ENOENT;
@@ -609,7 +609,7 @@ static noinline int btrfs_mksubvol(struc
 				   struct btrfs_root *snap_src,
 				   u64 *async_transid, bool readonly)
 {
-	struct inode *dir  = parent->dentry->d_inode;
+	struct inode *dir  = d_inode(parent->dentry);
 	struct dentry *dentry;
 	int error;
 
@@ -621,7 +621,7 @@ static noinline int btrfs_mksubvol(struc
 		goto out_unlock;
 
 	error = -EEXIST;
-	if (dentry->d_inode)
+	if (d_inode(dentry))
 		goto out_dput;
 
 	error = mnt_want_write(parent->mnt);
@@ -1265,7 +1265,7 @@ static noinline int btrfs_ioctl_snap_cre
 						    u64 *transid,
 						    bool readonly)
 {
-	struct btrfs_root *root = BTRFS_I(fdentry(file)->d_inode)->root;
+	struct btrfs_root *root = BTRFS_I(d_inode(fdentry(file)))->root;
 	struct file *src_file;
 	int namelen;
 	int ret = 0;
@@ -1290,8 +1290,8 @@ static noinline int btrfs_ioctl_snap_cre
 			goto out;
 		}
 
-		src_inode = src_file->f_path.dentry->d_inode;
-		if (src_inode->i_sb != file->f_path.dentry->d_inode->i_sb) {
+		src_inode = d_inode(src_file->f_path.dentry);
+		if (src_inode->i_sb != d_inode(file->f_path.dentry)->i_sb) {
 			printk(KERN_INFO "btrfs: Snapshot src from "
 			       "another FS\n");
 			ret = -EINVAL;
@@ -1368,7 +1368,7 @@ out:
 static noinline int btrfs_ioctl_subvol_getflags(struct file *file,
 						void __user *arg)
 {
-	struct inode *inode = fdentry(file)->d_inode;
+	struct inode *inode = d_inode(fdentry(file));
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	int ret = 0;
 	u64 flags = 0;
@@ -1390,7 +1390,7 @@ static noinline int btrfs_ioctl_subvol_g
 static noinline int btrfs_ioctl_subvol_setflags(struct file *file,
 					      void __user *arg)
 {
-	struct inode *inode = fdentry(file)->d_inode;
+	struct inode *inode = d_inode(fdentry(file));
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_trans_handle *trans;
 	u64 root_flags;
@@ -1670,7 +1670,7 @@ static noinline int btrfs_ioctl_tree_sea
 	if (IS_ERR(args))
 		return PTR_ERR(args);
 
-	inode = fdentry(file)->d_inode;
+	inode = d_inode(fdentry(file));
 	ret = search_ioctl(inode, args);
 	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
 		ret = -EFAULT;
@@ -1781,7 +1781,7 @@ static noinline int btrfs_ioctl_ino_look
 	if (IS_ERR(args))
 		return PTR_ERR(args);
 
-	inode = fdentry(file)->d_inode;
+	inode = d_inode(fdentry(file));
 
 	if (args->treeid == 0)
 		args->treeid = BTRFS_I(inode)->root->root_key.objectid;
@@ -1802,7 +1802,7 @@ static noinline int btrfs_ioctl_snap_des
 {
 	struct dentry *parent = fdentry(file);
 	struct dentry *dentry;
-	struct inode *dir = parent->d_inode;
+	struct inode *dir = d_inode(parent);
 	struct inode *inode;
 	struct btrfs_root *root = BTRFS_I(dir)->root;
 	struct btrfs_root *dest = NULL;
@@ -1835,12 +1835,12 @@ static noinline int btrfs_ioctl_snap_des
 		goto out_unlock_dir;
 	}
 
-	if (!dentry->d_inode) {
+	if (!d_inode(dentry)) {
 		err = -ENOENT;
 		goto out_dput;
 	}
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 	dest = BTRFS_I(inode)->root;
 	if (!capable(CAP_SYS_ADMIN)){
 		/*
@@ -1948,7 +1948,7 @@ out:
 
 static int btrfs_ioctl_defrag(struct file *file, void __user *argp)
 {
-	struct inode *inode = fdentry(file)->d_inode;
+	struct inode *inode = d_inode(fdentry(file));
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_ioctl_defrag_range_args *range;
 	int ret;
@@ -1999,7 +1999,7 @@ static int btrfs_ioctl_defrag(struct fil
 			/* the rest are all set to zero by kzalloc */
 			range->len = (u64)-1;
 		}
-		ret = btrfs_defrag_file(fdentry(file)->d_inode, file,
+		ret = btrfs_defrag_file(d_inode(fdentry(file)), file,
 					range, 0, 0);
 		if (ret > 0)
 			ret = 0;
@@ -2131,7 +2131,7 @@ out:
 static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,
 				       u64 off, u64 olen, u64 destoff)
 {
-	struct inode *inode = fdentry(file)->d_inode;
+	struct inode *inode = d_inode(fdentry(file));
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct file *src_file;
 	struct inode *src;
@@ -2174,7 +2174,7 @@ static noinline long btrfs_ioctl_clone(s
 		goto out_drop_write;
 	}
 
-	src = src_file->f_dentry->d_inode;
+	src = d_inode(src_file->f_dentry);
 
 	ret = -EINVAL;
 	if (src == inode)
@@ -2475,7 +2475,7 @@ static long btrfs_ioctl_clone_range(stru
  */
 static long btrfs_ioctl_trans_start(struct file *file)
 {
-	struct inode *inode = fdentry(file)->d_inode;
+	struct inode *inode = d_inode(fdentry(file));
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_trans_handle *trans;
 	int ret;
@@ -2515,7 +2515,7 @@ out:
 
 static long btrfs_ioctl_default_subvol(struct file *file, void __user *argp)
 {
-	struct inode *inode = fdentry(file)->d_inode;
+	struct inode *inode = d_inode(fdentry(file));
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_root *new_root;
 	struct btrfs_dir_item *di;
@@ -2730,7 +2730,7 @@ out:
  */
 long btrfs_ioctl_trans_end(struct file *file)
 {
-	struct inode *inode = fdentry(file)->d_inode;
+	struct inode *inode = d_inode(fdentry(file));
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_trans_handle *trans;
 
@@ -2749,7 +2749,7 @@ long btrfs_ioctl_trans_end(struct file *
 
 static noinline long btrfs_ioctl_start_sync(struct file *file, void __user *argp)
 {
-	struct btrfs_root *root = BTRFS_I(file->f_dentry->d_inode)->root;
+	struct btrfs_root *root = BTRFS_I(d_inode(file->f_dentry))->root;
 	struct btrfs_trans_handle *trans;
 	u64 transid;
 	int ret;
@@ -2772,7 +2772,7 @@ static noinline long btrfs_ioctl_start_s
 
 static noinline long btrfs_ioctl_wait_sync(struct file *file, void __user *argp)
 {
-	struct btrfs_root *root = BTRFS_I(file->f_dentry->d_inode)->root;
+	struct btrfs_root *root = BTRFS_I(d_inode(file->f_dentry))->root;
 	u64 transid;
 
 	if (argp) {
@@ -2839,7 +2839,7 @@ static long btrfs_ioctl_scrub_progress(s
 long btrfs_ioctl(struct file *file, unsigned int
 		cmd, unsigned long arg)
 {
-	struct btrfs_root *root = BTRFS_I(fdentry(file)->d_inode)->root;
+	struct btrfs_root *root = BTRFS_I(d_inode(fdentry(file)))->root;
 	void __user *argp = (void __user *)arg;
 
 	switch (cmd) {
diff -u -p a/btrfs/acl.c b/btrfs/acl.c
--- a/btrfs/acl.c
+++ b/btrfs/acl.c
@@ -87,10 +87,10 @@ static int btrfs_xattr_acl_get(struct de
 	struct posix_acl *acl;
 	int ret = 0;
 
-	if (!IS_POSIXACL(dentry->d_inode))
+	if (!IS_POSIXACL(d_inode(dentry)))
 		return -EOPNOTSUPP;
 
-	acl = btrfs_get_acl(dentry->d_inode, type);
+	acl = btrfs_get_acl(d_inode(dentry), type);
 
 	if (IS_ERR(acl))
 		return PTR_ERR(acl);
@@ -170,10 +170,10 @@ static int btrfs_xattr_acl_set(struct de
 	int ret;
 	struct posix_acl *acl = NULL;
 
-	if (!inode_owner_or_capable(dentry->d_inode))
+	if (!inode_owner_or_capable(d_inode(dentry)))
 		return -EPERM;
 
-	if (!IS_POSIXACL(dentry->d_inode))
+	if (!IS_POSIXACL(d_inode(dentry)))
 		return -EOPNOTSUPP;
 
 	if (value) {
@@ -188,7 +188,7 @@ static int btrfs_xattr_acl_set(struct de
 		}
 	}
 
-	ret = btrfs_set_acl(NULL, dentry->d_inode, acl, type);
+	ret = btrfs_set_acl(NULL, d_inode(dentry), acl, type);
 out:
 	posix_acl_release(acl);
 
diff -u -p a/btrfs/xattr.c b/btrfs/xattr.c
--- a/btrfs/xattr.c
+++ b/btrfs/xattr.c
@@ -173,7 +173,7 @@ out:
 ssize_t btrfs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 {
 	struct btrfs_key key, found_key;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_path *path;
 	struct extent_buffer *leaf;
@@ -301,13 +301,13 @@ ssize_t btrfs_getxattr(struct dentry *de
 
 	if (!btrfs_is_valid_xattr(name))
 		return -EOPNOTSUPP;
-	return __btrfs_getxattr(dentry->d_inode, name, buffer, size);
+	return __btrfs_getxattr(d_inode(dentry), name, buffer, size);
 }
 
 int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 		   size_t size, int flags)
 {
-	struct btrfs_root *root = BTRFS_I(dentry->d_inode)->root;
+	struct btrfs_root *root = BTRFS_I(d_inode(dentry))->root;
 
 	/*
 	 * The permission on security.* and system.* is not checked
@@ -330,13 +330,13 @@ int btrfs_setxattr(struct dentry *dentry
 	if (size == 0)
 		value = "";  /* empty EA, do not remove */
 
-	return __btrfs_setxattr(NULL, dentry->d_inode, name, value, size,
+	return __btrfs_setxattr(NULL, d_inode(dentry), name, value, size,
 				flags);
 }
 
 int btrfs_removexattr(struct dentry *dentry, const char *name)
 {
-	struct btrfs_root *root = BTRFS_I(dentry->d_inode)->root;
+	struct btrfs_root *root = BTRFS_I(d_inode(dentry))->root;
 
 	/*
 	 * The permission on security.* and system.* is not checked
@@ -356,7 +356,7 @@ int btrfs_removexattr(struct dentry *den
 	if (!btrfs_is_valid_xattr(name))
 		return -EOPNOTSUPP;
 
-	return __btrfs_setxattr(NULL, dentry->d_inode, name, NULL, 0,
+	return __btrfs_setxattr(NULL, d_inode(dentry), name, NULL, 0,
 				XATTR_REPLACE);
 }
 
diff -u -p a/xattr.c b/xattr.c
--- a/xattr.c
+++ b/xattr.c
@@ -89,7 +89,7 @@ xattr_permission(struct inode *inode, co
 int __vfs_setxattr_noperm(struct dentry *dentry, const char *name,
 		const void *value, size_t size, int flags)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error = -EOPNOTSUPP;
 	int issec = !strncmp(name, XATTR_SECURITY_PREFIX,
 				   XATTR_SECURITY_PREFIX_LEN);
@@ -119,7 +119,7 @@ int
 vfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 		size_t size, int flags)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	error = xattr_permission(inode, name, MAY_WRITE);
@@ -169,7 +169,7 @@ EXPORT_SYMBOL_GPL(xattr_getsecurity);
 ssize_t
 vfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	error = xattr_permission(inode, name, MAY_READ);
@@ -211,10 +211,10 @@ vfs_listxattr(struct dentry *d, char *li
 	if (error)
 		return error;
 	error = -EOPNOTSUPP;
-	if (d->d_inode->i_op->listxattr) {
-		error = d->d_inode->i_op->listxattr(d, list, size);
+	if (d_inode(d)->i_op->listxattr) {
+		error = d_inode(d)->i_op->listxattr(d, list, size);
 	} else {
-		error = security_inode_listsecurity(d->d_inode, list, size);
+		error = security_inode_listsecurity(d_inode(d), list, size);
 		if (size && error > size)
 			error = -ERANGE;
 	}
@@ -225,7 +225,7 @@ EXPORT_SYMBOL_GPL(vfs_listxattr);
 int
 vfs_removexattr(struct dentry *dentry, const char *name)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error;
 
 	if (!inode->i_op->removexattr)
diff -u -p a/devpts/inode.c b/devpts/inode.c
--- a/devpts/inode.c
+++ b/devpts/inode.c
@@ -173,7 +173,7 @@ static int mknod_ptmx(struct super_block
 	struct pts_fs_info *fsi = DEVPTS_SB(sb);
 	struct pts_mount_opts *opts = &fsi->mount_opts;
 
-	mutex_lock(&root->d_inode->i_mutex);
+	mutex_lock(&d_inode(root)->i_mutex);
 
 	/* If we have already created ptmx node, return */
 	if (fsi->ptmx_dentry) {
@@ -208,7 +208,7 @@ static int mknod_ptmx(struct super_block
 	fsi->ptmx_dentry = dentry;
 	rc = 0;
 out:
-	mutex_unlock(&root->d_inode->i_mutex);
+	mutex_unlock(&d_inode(root)->i_mutex);
 	return rc;
 }
 
@@ -216,7 +216,7 @@ static void update_ptmx_mode(struct pts_
 {
 	struct inode *inode;
 	if (fsi->ptmx_dentry) {
-		inode = fsi->ptmx_dentry->d_inode;
+		inode = d_inode(fsi->ptmx_dentry);
 		inode->i_mode = S_IFCHR|fsi->mount_opts.ptmxmode;
 	}
 }
@@ -499,18 +499,18 @@ int devpts_pty_new(struct inode *ptmx_in
 
 	sprintf(s, "%d", number);
 
-	mutex_lock(&root->d_inode->i_mutex);
+	mutex_lock(&d_inode(root)->i_mutex);
 
 	dentry = d_alloc_name(root, s);
 	if (dentry) {
 		d_add(dentry, inode);
-		fsnotify_create(root->d_inode, dentry);
+		fsnotify_create(d_inode(root), dentry);
 	} else {
 		iput(inode);
 		ret = -ENOMEM;
 	}
 
-	mutex_unlock(&root->d_inode->i_mutex);
+	mutex_unlock(&d_inode(root)->i_mutex);
 
 	return ret;
 }
@@ -545,7 +545,7 @@ void devpts_pty_kill(struct tty_struct *
 
 	BUG_ON(inode->i_rdev == MKDEV(TTYAUX_MAJOR, PTMX_MINOR));
 
-	mutex_lock(&root->d_inode->i_mutex);
+	mutex_lock(&d_inode(root)->i_mutex);
 
 	dentry = d_find_alias(inode);
 
@@ -554,7 +554,7 @@ void devpts_pty_kill(struct tty_struct *
 	dput(dentry);	/* d_alloc_name() in devpts_pty_new() */
 	dput(dentry);		/* d_find_alias above */
 
-	mutex_unlock(&root->d_inode->i_mutex);
+	mutex_unlock(&d_inode(root)->i_mutex);
 }
 
 static int __init init_devpts_fs(void)
diff -u -p a/hpfs/inode.c b/hpfs/inode.c
--- a/hpfs/inode.c
+++ b/hpfs/inode.c
@@ -255,7 +255,7 @@ void hpfs_write_inode_nolock(struct inod
 
 int hpfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int error = -EINVAL;
 
 	hpfs_lock(inode->i_sb);
diff -u -p a/hpfs/file.c b/hpfs/file.c
--- a/hpfs/file.c
+++ b/hpfs/file.c
@@ -140,7 +140,7 @@ static ssize_t hpfs_file_write(struct fi
 	retval = do_sync_write(file, buf, count, ppos);
 	if (retval > 0) {
 		hpfs_lock(file->f_path.dentry->d_sb);
-		hpfs_i(file->f_path.dentry->d_inode)->i_dirty = 1;
+		hpfs_i(d_inode(file->f_path.dentry))->i_dirty = 1;
 		hpfs_unlock(file->f_path.dentry->d_sb);
 	}
 	return retval;
diff -u -p a/hpfs/namei.c b/hpfs/namei.c
--- a/hpfs/namei.c
+++ b/hpfs/namei.c
@@ -359,7 +359,7 @@ static int hpfs_unlink(struct inode *dir
 	unsigned len = dentry->d_name.len;
 	struct quad_buffer_head qbh;
 	struct hpfs_dirent *de;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	dnode_secno dno;
 	int r;
 	int rep = 0;
@@ -433,7 +433,7 @@ static int hpfs_rmdir(struct inode *dir,
 	unsigned len = dentry->d_name.len;
 	struct quad_buffer_head qbh;
 	struct hpfs_dirent *de;
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	dnode_secno dno;
 	int n_items = 0;
 	int err;
@@ -522,8 +522,8 @@ static int hpfs_rename(struct inode *old
 	unsigned old_len = old_dentry->d_name.len;
 	const unsigned char *new_name = new_dentry->d_name.name;
 	unsigned new_len = new_dentry->d_name.len;
-	struct inode *i = old_dentry->d_inode;
-	struct inode *new_inode = new_dentry->d_inode;
+	struct inode *i = d_inode(old_dentry);
+	struct inode *new_inode = d_inode(new_dentry);
 	struct quad_buffer_head qbh, qbh1;
 	struct hpfs_dirent *dep, *nde;
 	struct hpfs_dirent de;
diff -u -p a/hpfs/dir.c b/hpfs/dir.c
--- a/hpfs/dir.c
+++ b/hpfs/dir.c
@@ -25,7 +25,7 @@ static loff_t hpfs_dir_lseek(struct file
 	loff_t new_off = off + (whence == 1 ? filp->f_pos : 0);
 	loff_t pos;
 	struct quad_buffer_head qbh;
-	struct inode *i = filp->f_path.dentry->d_inode;
+	struct inode *i = d_inode(filp->f_path.dentry);
 	struct hpfs_inode_info *hpfs_inode = hpfs_i(i);
 	struct super_block *s = i->i_sb;
 
@@ -53,7 +53,7 @@ fail:
 
 static int hpfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct hpfs_inode_info *hpfs_inode = hpfs_i(inode);
 	struct quad_buffer_head qbh;
 	struct hpfs_dirent *de;
diff -u -p a/binfmt_flat.c b/binfmt_flat.c
--- a/binfmt_flat.c
+++ b/binfmt_flat.c
@@ -439,7 +439,7 @@ static int load_flat_file(struct linux_b
 	int ret;
 
 	hdr = ((struct flat_hdr *) bprm->buf);		/* exec-header */
-	inode = bprm->file->f_path.dentry->d_inode;
+	inode = d_inode(bprm->file->f_path.dentry);
 
 	text_len  = ntohl(hdr->data_start);
 	data_len  = ntohl(hdr->data_end) - ntohl(hdr->data_start);
diff -u -p a/reiserfs/super.c b/reiserfs/super.c
--- a/reiserfs/super.c
+++ b/reiserfs/super.c
@@ -1456,7 +1456,7 @@ static __u32 find_hash_out(struct super_
 	struct reiserfs_dir_entry de;
 	__u32 hash = DEFAULT_HASH;
 
-	inode = s->s_root->d_inode;
+	inode = d_inode(s->s_root);
 
 	do {			// Some serious "goto"-hater was there ;)
 		u32 teahash, r5hash, yurahash;
@@ -2062,7 +2062,7 @@ static int reiserfs_quota_on(struct supe
 		err = -EXDEV;
 		goto out;
 	}
-	inode = path->dentry->d_inode;
+	inode = d_inode(path->dentry);
 	/* We must not pack tails for quota files on reiserfs for quota IO to work */
 	if (!(REISERFS_I(inode)->i_flags & i_nopack_mask)) {
 		err = reiserfs_unpack(inode, NULL);
diff -u -p a/reiserfs/xattr_user.c b/reiserfs/xattr_user.c
--- a/reiserfs/xattr_user.c
+++ b/reiserfs/xattr_user.c
@@ -15,7 +15,7 @@ user_get(struct dentry *dentry, const ch
 		return -EINVAL;
 	if (!reiserfs_xattrs_user(dentry->d_sb))
 		return -EOPNOTSUPP;
-	return reiserfs_xattr_get(dentry->d_inode, name, buffer, size);
+	return reiserfs_xattr_get(d_inode(dentry), name, buffer, size);
 }
 
 static int
@@ -27,7 +27,7 @@ user_set(struct dentry *dentry, const ch
 
 	if (!reiserfs_xattrs_user(dentry->d_sb))
 		return -EOPNOTSUPP;
-	return reiserfs_xattr_set(dentry->d_inode, name, buffer, size, flags);
+	return reiserfs_xattr_set(d_inode(dentry), name, buffer, size, flags);
 }
 
 static size_t user_list(struct dentry *dentry, char *list, size_t list_size,
diff -u -p a/reiserfs/xattr_acl.c b/reiserfs/xattr_acl.c
--- a/reiserfs/xattr_acl.c
+++ b/reiserfs/xattr_acl.c
@@ -19,7 +19,7 @@ static int
 posix_acl_set(struct dentry *dentry, const char *name, const void *value,
 		size_t size, int flags, int type)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct posix_acl *acl;
 	int error, error2;
 	struct reiserfs_transaction_handle th;
@@ -72,7 +72,7 @@ posix_acl_get(struct dentry *dentry, con
 	if (!reiserfs_posixacl(dentry->d_sb))
 		return -EOPNOTSUPP;
 
-	acl = reiserfs_get_acl(dentry->d_inode, type);
+	acl = reiserfs_get_acl(d_inode(dentry), type);
 	if (IS_ERR(acl))
 		return PTR_ERR(acl);
 	if (acl == NULL)
diff -u -p a/reiserfs/inode.c b/reiserfs/inode.c
--- a/reiserfs/inode.c
+++ b/reiserfs/inode.c
@@ -1590,7 +1590,7 @@ struct dentry *reiserfs_fh_to_parent(str
 int reiserfs_encode_fh(struct dentry *dentry, __u32 * data, int *lenp,
 		       int need_parent)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int maxlen = *lenp;
 
 	if (need_parent && (maxlen < 5)) {
@@ -1610,7 +1610,7 @@ int reiserfs_encode_fh(struct dentry *de
 		return 3;
 
 	spin_lock(&dentry->d_lock);
-	inode = dentry->d_parent->d_inode;
+	inode = d_inode(dentry->d_parent);
 	data[3] = inode->i_ino;
 	data[4] = le32_to_cpu(INODE_PKEY(inode)->k_dir_id);
 	*lenp = 5;
@@ -3089,7 +3089,7 @@ static ssize_t reiserfs_direct_IO(int rw
 
 int reiserfs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	unsigned int ia_valid;
 	int depth;
 	int error;
diff -u -p a/reiserfs/procfs.c b/reiserfs/procfs.c
--- a/reiserfs/procfs.c
+++ b/reiserfs/procfs.c
@@ -282,7 +282,7 @@ static int show_oidmap(struct seq_file *
 	}
 #if defined( REISERFS_USE_OIDMAPF )
 	if (sb_info->oidmap.use_file && (sb_info->oidmap.mapf != NULL)) {
-		loff_t size = sb_info->oidmap.mapf->f_path.dentry->d_inode->i_size;
+		loff_t size = d_inode(sb_info->oidmap.mapf->f_path.dentry)->i_size;
 		total_used += size / sizeof(reiserfs_oidinterval_d_t);
 	}
 #endif
diff -u -p a/reiserfs/file.c b/reiserfs/file.c
--- a/reiserfs/file.c
+++ b/reiserfs/file.c
@@ -261,7 +261,7 @@ static ssize_t reiserfs_file_write(struc
 							 * new current position before returning. */
 				   )
 {
-	struct inode *inode = file->f_path.dentry->d_inode;	// Inode of the file that we are writing to.
+	struct inode *inode = d_inode(file->f_path.dentry);	// Inode of the file that we are writing to.
 	/* To simplify coding at this time, we store
 	   locked pages in array for now */
 	struct reiserfs_transaction_handle th;
diff -u -p a/reiserfs/namei.c b/reiserfs/namei.c
--- a/reiserfs/namei.c
+++ b/reiserfs/namei.c
@@ -376,7 +376,7 @@ struct dentry *reiserfs_get_parent(struc
 	struct inode *inode = NULL;
 	struct reiserfs_dir_entry de;
 	INITIALIZE_PATH(path_to_entry);
-	struct inode *dir = child->d_inode;
+	struct inode *dir = d_inode(child);
 
 	if (dir->i_nlink == 0) {
 		return ERR_PTR(-ENOENT);
@@ -857,7 +857,7 @@ static int reiserfs_rmdir(struct inode *
 		goto end_rmdir;
 	}
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	reiserfs_update_inode_transaction(inode);
 	reiserfs_update_inode_transaction(dir);
@@ -924,7 +924,7 @@ static int reiserfs_unlink(struct inode
 
 	dquot_initialize(dir);
 
-	inode = dentry->d_inode;
+	inode = d_inode(dentry);
 
 	/* in this transaction we can be doing at max two balancings and update
 	 * two stat datas, we change quotas of the owner of the directory and of
@@ -1108,7 +1108,7 @@ static int reiserfs_link(struct dentry *
 			 struct dentry *dentry)
 {
 	int retval;
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	struct reiserfs_transaction_handle th;
 	/* We need blocks for transaction + update of quotas for the owners of the directory */
 	int jbegin_count =
@@ -1240,8 +1240,8 @@ static int reiserfs_rename(struct inode
 	dquot_initialize(old_dir);
 	dquot_initialize(new_dir);
 
-	old_inode = old_dentry->d_inode;
-	new_dentry_inode = new_dentry->d_inode;
+	old_inode = d_inode(old_dentry);
+	new_dentry_inode = d_inode(new_dentry);
 
 	// make sure, that oldname still exists and points to an object we
 	// are going to rename
diff -u -p a/reiserfs/dir.c b/reiserfs/dir.c
--- a/reiserfs/dir.c
+++ b/reiserfs/dir.c
@@ -45,14 +45,14 @@ static inline bool is_privroot_deh(struc
 				   struct reiserfs_de_head *deh)
 {
 	struct dentry *privroot = REISERFS_SB(dir->d_sb)->priv_root;
-	return (dir == dir->d_parent && privroot->d_inode &&
-	        deh->deh_objectid == INODE_PKEY(privroot->d_inode)->k_objectid);
+	return (dir == dir->d_parent && d_inode(privroot) &&
+	        deh->deh_objectid == INODE_PKEY(d_inode(privroot))->k_objectid);
 }
 
 int reiserfs_readdir_dentry(struct dentry *dentry, void *dirent,
 			   filldir_t filldir, loff_t *pos)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct cpu_key pos_key;	/* key of current position in the directory (key of directory entry) */
 	INITIALIZE_PATH(path_to_entry);
 	struct buffer_head *bh;
diff -u -p a/reiserfs/ioctl.c b/reiserfs/ioctl.c
--- a/reiserfs/ioctl.c
+++ b/reiserfs/ioctl.c
@@ -21,7 +21,7 @@
  */
 long reiserfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	unsigned int flags;
 	int err = 0;
 
diff -u -p a/reiserfs/xattr_trusted.c b/reiserfs/xattr_trusted.c
--- a/reiserfs/xattr_trusted.c
+++ b/reiserfs/xattr_trusted.c
@@ -14,10 +14,10 @@ trusted_get(struct dentry *dentry, const
 	if (strlen(name) < sizeof(XATTR_TRUSTED_PREFIX))
 		return -EINVAL;
 
-	if (!capable(CAP_SYS_ADMIN) || IS_PRIVATE(dentry->d_inode))
+	if (!capable(CAP_SYS_ADMIN) || IS_PRIVATE(d_inode(dentry)))
 		return -EPERM;
 
-	return reiserfs_xattr_get(dentry->d_inode, name, buffer, size);
+	return reiserfs_xattr_get(d_inode(dentry), name, buffer, size);
 }
 
 static int
@@ -27,10 +27,10 @@ trusted_set(struct dentry *dentry, const
 	if (strlen(name) < sizeof(XATTR_TRUSTED_PREFIX))
 		return -EINVAL;
 
-	if (!capable(CAP_SYS_ADMIN) || IS_PRIVATE(dentry->d_inode))
+	if (!capable(CAP_SYS_ADMIN) || IS_PRIVATE(d_inode(dentry)))
 		return -EPERM;
 
-	return reiserfs_xattr_set(dentry->d_inode, name, buffer, size, flags);
+	return reiserfs_xattr_set(d_inode(dentry), name, buffer, size, flags);
 }
 
 static size_t trusted_list(struct dentry *dentry, char *list, size_t list_size,
@@ -38,7 +38,7 @@ static size_t trusted_list(struct dentry
 {
 	const size_t len = name_len + 1;
 
-	if (!capable(CAP_SYS_ADMIN) || IS_PRIVATE(dentry->d_inode))
+	if (!capable(CAP_SYS_ADMIN) || IS_PRIVATE(d_inode(dentry)))
 		return 0;
 
 	if (list && len <= list_size) {
diff -u -p a/reiserfs/xattr.c b/reiserfs/xattr.c
--- a/reiserfs/xattr.c
+++ b/reiserfs/xattr.c
@@ -81,10 +81,10 @@ static int xattr_unlink(struct inode *di
 	int error;
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
 
-	reiserfs_mutex_lock_nested_safe(&dentry->d_inode->i_mutex,
+	reiserfs_mutex_lock_nested_safe(&d_inode(dentry)->i_mutex,
 					I_MUTEX_CHILD, dir->i_sb);
 	error = dir->i_op->unlink(dir, dentry);
-	mutex_unlock(&dentry->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dentry)->i_mutex);
 
 	if (!error)
 		d_delete(dentry);
@@ -96,12 +96,12 @@ static int xattr_rmdir(struct inode *dir
 	int error;
 	BUG_ON(!mutex_is_locked(&dir->i_mutex));
 
-	reiserfs_mutex_lock_nested_safe(&dentry->d_inode->i_mutex,
+	reiserfs_mutex_lock_nested_safe(&d_inode(dentry)->i_mutex,
 					I_MUTEX_CHILD, dir->i_sb);
 	error = dir->i_op->rmdir(dir, dentry);
 	if (!error)
-		dentry->d_inode->i_flags |= S_DEAD;
-	mutex_unlock(&dentry->d_inode->i_mutex);
+		d_inode(dentry)->i_flags |= S_DEAD;
+	mutex_unlock(&d_inode(dentry)->i_mutex);
 	if (!error)
 		d_delete(dentry);
 
@@ -114,25 +114,25 @@ static struct dentry *open_xa_root(struc
 {
 	struct dentry *privroot = REISERFS_SB(sb)->priv_root;
 	struct dentry *xaroot;
-	if (!privroot->d_inode)
+	if (!d_inode(privroot))
 		return ERR_PTR(-ENODATA);
 
-	mutex_lock_nested(&privroot->d_inode->i_mutex, I_MUTEX_XATTR);
+	mutex_lock_nested(&d_inode(privroot)->i_mutex, I_MUTEX_XATTR);
 
 	xaroot = dget(REISERFS_SB(sb)->xattr_root);
 	if (!xaroot)
 		xaroot = ERR_PTR(-ENODATA);
-	else if (!xaroot->d_inode) {
+	else if (!d_inode(xaroot)) {
 		int err = -ENODATA;
 		if (xattr_may_create(flags))
-			err = xattr_mkdir(privroot->d_inode, xaroot, 0700);
+			err = xattr_mkdir(d_inode(privroot), xaroot, 0700);
 		if (err) {
 			dput(xaroot);
 			xaroot = ERR_PTR(err);
 		}
 	}
 
-	mutex_unlock(&privroot->d_inode->i_mutex);
+	mutex_unlock(&d_inode(privroot)->i_mutex);
 	return xaroot;
 }
 
@@ -149,20 +149,20 @@ static struct dentry *open_xa_dir(const
 		 le32_to_cpu(INODE_PKEY(inode)->k_objectid),
 		 inode->i_generation);
 
-	mutex_lock_nested(&xaroot->d_inode->i_mutex, I_MUTEX_XATTR);
+	mutex_lock_nested(&d_inode(xaroot)->i_mutex, I_MUTEX_XATTR);
 
 	xadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));
-	if (!IS_ERR(xadir) && !xadir->d_inode) {
+	if (!IS_ERR(xadir) && !d_inode(xadir)) {
 		int err = -ENODATA;
 		if (xattr_may_create(flags))
-			err = xattr_mkdir(xaroot->d_inode, xadir, 0700);
+			err = xattr_mkdir(d_inode(xaroot), xadir, 0700);
 		if (err) {
 			dput(xadir);
 			xadir = ERR_PTR(err);
 		}
 	}
 
-	mutex_unlock(&xaroot->d_inode->i_mutex);
+	mutex_unlock(&d_inode(xaroot)->i_mutex);
 	dput(xaroot);
 	return xadir;
 }
@@ -182,7 +182,7 @@ fill_with_dentries(void *buf, const char
 {
 	struct reiserfs_dentry_buf *dbuf = buf;
 	struct dentry *dentry;
-	WARN_ON_ONCE(!mutex_is_locked(&dbuf->xadir->d_inode->i_mutex));
+	WARN_ON_ONCE(!mutex_is_locked(&d_inode(dbuf->xadir)->i_mutex));
 
 	if (dbuf->count == ARRAY_SIZE(dbuf->dentries))
 		return -ENOSPC;
@@ -194,7 +194,7 @@ fill_with_dentries(void *buf, const char
 	dentry = lookup_one_len(name, dbuf->xadir, namelen);
 	if (IS_ERR(dentry)) {
 		return PTR_ERR(dentry);
-	} else if (!dentry->d_inode) {
+	} else if (!d_inode(dentry)) {
 		/* A directory entry exists, but no file? */
 		reiserfs_error(dentry->d_sb, "xattr-20003",
 			       "Corrupted directory: xattr %s listed but "
@@ -238,13 +238,13 @@ static int reiserfs_for_each_xattr(struc
 		err = PTR_ERR(dir);
 		reiserfs_write_lock(inode->i_sb);
 		goto out;
-	} else if (!dir->d_inode) {
+	} else if (!d_inode(dir)) {
 		err = 0;
 		reiserfs_write_lock(inode->i_sb);
 		goto out_dir;
 	}
 
-	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
+	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_XATTR);
 
 	reiserfs_write_lock(inode->i_sb);
 
@@ -257,7 +257,7 @@ static int reiserfs_for_each_xattr(struc
 			int lerr = 0;
 			struct dentry *dentry = buf.dentries[i];
 
-			if (err == 0 && !S_ISDIR(dentry->d_inode->i_mode))
+			if (err == 0 && !S_ISDIR(d_inode(dentry)->i_mode))
 				lerr = action(dentry, data);
 
 			dput(dentry);
@@ -269,7 +269,7 @@ static int reiserfs_for_each_xattr(struc
 			err = reiserfs_readdir_dentry(dir, &buf,
 						      fill_with_dentries, &pos);
 	}
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 
 	/* Clean up after a failed readdir */
 	cleanup_dentry_buf(&buf);
@@ -287,11 +287,11 @@ static int reiserfs_for_each_xattr(struc
 		if (!err) {
 			int jerror;
 			reiserfs_mutex_lock_nested_safe(
-					  &dir->d_parent->d_inode->i_mutex,
+					  &d_inode(dir->d_parent)->i_mutex,
 					  I_MUTEX_XATTR, inode->i_sb);
 			err = action(dir, data);
 			jerror = journal_end(&th, inode->i_sb, blocks);
-			mutex_unlock(&dir->d_parent->d_inode->i_mutex);
+			mutex_unlock(&d_inode(dir->d_parent)->i_mutex);
 			err = jerror ?: err;
 		}
 	}
@@ -306,10 +306,10 @@ out:
 
 static int delete_one_xattr(struct dentry *dentry, void *data)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 
 	/* This is the xattr dir, handle specially. */
-	if (S_ISDIR(dentry->d_inode->i_mode))
+	if (S_ISDIR(d_inode(dentry)->i_mode))
 		return xattr_rmdir(dir, dentry);
 
 	return xattr_unlink(dir, dentry);
@@ -355,27 +355,27 @@ static struct dentry *xattr_lookup(struc
 	if (IS_ERR(xadir))
 		return ERR_CAST(xadir);
 
-	mutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);
+	mutex_lock_nested(&d_inode(xadir)->i_mutex, I_MUTEX_XATTR);
 	xafile = lookup_one_len(name, xadir, strlen(name));
 	if (IS_ERR(xafile)) {
 		err = PTR_ERR(xafile);
 		goto out;
 	}
 
-	if (xafile->d_inode && (flags & XATTR_CREATE))
+	if (d_inode(xafile) && (flags & XATTR_CREATE))
 		err = -EEXIST;
 
-	if (!xafile->d_inode) {
+	if (!d_inode(xafile)) {
 		err = -ENODATA;
 		if (xattr_may_create(flags))
-			err = xattr_create(xadir->d_inode, xafile,
+			err = xattr_create(d_inode(xadir), xafile,
 					      0700|S_IFREG);
 	}
 
 	if (err)
 		dput(xafile);
 out:
-	mutex_unlock(&xadir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(xadir)->i_mutex);
 	dput(xadir);
 	if (err)
 		return ERR_PTR(err);
@@ -437,23 +437,23 @@ static int lookup_and_delete_xattr(struc
 	if (IS_ERR(xadir))
 		return PTR_ERR(xadir);
 
-	mutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);
+	mutex_lock_nested(&d_inode(xadir)->i_mutex, I_MUTEX_XATTR);
 	dentry = lookup_one_len(name, xadir, strlen(name));
 	if (IS_ERR(dentry)) {
 		err = PTR_ERR(dentry);
 		goto out_dput;
 	}
 
-	if (dentry->d_inode) {
+	if (d_inode(dentry)) {
 		reiserfs_write_lock(inode->i_sb);
-		err = xattr_unlink(xadir->d_inode, dentry);
+		err = xattr_unlink(d_inode(xadir), dentry);
 		reiserfs_write_unlock(inode->i_sb);
 		update_ctime(inode);
 	}
 
 	dput(dentry);
 out_dput:
-	mutex_unlock(&xadir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(xadir)->i_mutex);
 	dput(xadir);
 	return err;
 }
@@ -509,7 +509,7 @@ reiserfs_xattr_set_handle(struct reiserf
 		else
 			chunk = buffer_size - buffer_pos;
 
-		page = reiserfs_get_page(dentry->d_inode, file_pos);
+		page = reiserfs_get_page(d_inode(dentry), file_pos);
 		if (IS_ERR(page)) {
 			err = PTR_ERR(page);
 			goto out_unlock;
@@ -546,7 +546,7 @@ reiserfs_xattr_set_handle(struct reiserf
 	}
 
 	new_size = buffer_size + sizeof(struct reiserfs_xattr_header);
-	if (!err && new_size < i_size_read(dentry->d_inode)) {
+	if (!err && new_size < i_size_read(d_inode(dentry))) {
 		struct iattr newattrs = {
 			.ia_ctime = current_fs_time(inode->i_sb),
 			.ia_size = new_size,
@@ -554,13 +554,13 @@ reiserfs_xattr_set_handle(struct reiserf
 		};
 
 		reiserfs_write_unlock(inode->i_sb);
-		mutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);
-		down_write(&dentry->d_inode->i_alloc_sem);
+		mutex_lock_nested(&d_inode(dentry)->i_mutex, I_MUTEX_XATTR);
+		down_write(&d_inode(dentry)->i_alloc_sem);
 		reiserfs_write_lock(inode->i_sb);
 
 		err = reiserfs_setattr(dentry, &newattrs);
-		up_write(&dentry->d_inode->i_alloc_sem);
-		mutex_unlock(&dentry->d_inode->i_mutex);
+		up_write(&d_inode(dentry)->i_alloc_sem);
+		mutex_unlock(&d_inode(dentry)->i_mutex);
 	} else
 		update_ctime(inode);
 out_unlock:
@@ -630,7 +630,7 @@ reiserfs_xattr_get(struct inode *inode,
 
 	down_read(&REISERFS_I(inode)->i_xattr_sem);
 
-	isize = i_size_read(dentry->d_inode);
+	isize = i_size_read(d_inode(dentry));
 
 	/* Just return the size needed */
 	if (buffer == NULL) {
@@ -652,7 +652,7 @@ reiserfs_xattr_get(struct inode *inode,
 		else
 			chunk = isize - file_pos;
 
-		page = reiserfs_get_page(dentry->d_inode, file_pos);
+		page = reiserfs_get_page(d_inode(dentry), file_pos);
 		if (IS_ERR(page)) {
 			err = PTR_ERR(page);
 			goto out_unlock;
@@ -747,7 +747,7 @@ reiserfs_getxattr(struct dentry * dentry
 
 	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
 
-	if (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
+	if (!handler || get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
 	return handler->get(dentry, name, buffer, size, handler->flags);
@@ -766,7 +766,7 @@ reiserfs_setxattr(struct dentry *dentry,
 
 	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
 
-	if (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
+	if (!handler || get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
 	return handler->set(dentry, name, value, size, flags, handler->flags);
@@ -782,7 +782,7 @@ int reiserfs_removexattr(struct dentry *
 	const struct xattr_handler *handler;
 	handler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);
 
-	if (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
+	if (!handler || get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
 	return handler->set(dentry, name, NULL, 0, XATTR_REPLACE, handler->flags);
@@ -841,14 +841,14 @@ ssize_t reiserfs_listxattr(struct dentry
 		.size = buffer ? size : 0,
 	};
 
-	if (!dentry->d_inode)
+	if (!d_inode(dentry))
 		return -EINVAL;
 
 	if (!dentry->d_sb->s_xattr ||
-	    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)
+	    get_inode_sd_version(d_inode(dentry)) == STAT_DATA_V1)
 		return -EOPNOTSUPP;
 
-	dir = open_xa_dir(dentry->d_inode, XATTR_REPLACE);
+	dir = open_xa_dir(d_inode(dentry), XATTR_REPLACE);
 	if (IS_ERR(dir)) {
 		err = PTR_ERR(dir);
 		if (err == -ENODATA)
@@ -856,9 +856,9 @@ ssize_t reiserfs_listxattr(struct dentry
 		goto out;
 	}
 
-	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);
+	mutex_lock_nested(&d_inode(dir)->i_mutex, I_MUTEX_XATTR);
 	err = reiserfs_readdir_dentry(dir, &buf, listxattr_filler, &pos);
-	mutex_unlock(&dir->d_inode->i_mutex);
+	mutex_unlock(&d_inode(dir)->i_mutex);
 
 	if (!err)
 		err = buf.pos;
@@ -892,11 +892,11 @@ static int reiserfs_check_acl(struct ino
 static int create_privroot(struct dentry *dentry)
 {
 	int err;
-	struct inode *inode = dentry->d_parent->d_inode;
+	struct inode *inode = d_inode(dentry->d_parent);
 	WARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));
 
 	err = xattr_mkdir(inode, dentry, 0700);
-	if (err || !dentry->d_inode) {
+	if (err || !d_inode(dentry)) {
 		reiserfs_warning(dentry->d_sb, "jdm-20006",
 				 "xattrs/ACLs enabled and couldn't "
 				 "find/create .reiserfs_priv. "
@@ -904,7 +904,7 @@ static int create_privroot(struct dentry
 		return -EOPNOTSUPP;
 	}
 
-	dentry->d_inode->i_flags |= S_PRIVATE;
+	d_inode(dentry)->i_flags |= S_PRIVATE;
 	reiserfs_info(dentry->d_sb, "Created %s - reserved for xattr "
 		      "storage.\n", PRIVROOT_NAME);
 
@@ -987,17 +987,17 @@ int reiserfs_lookup_privroot(struct supe
 	int err = 0;
 
 	/* If we don't have the privroot located yet - go find it */
-	reiserfs_mutex_lock_safe(&s->s_root->d_inode->i_mutex, s);
+	reiserfs_mutex_lock_safe(&d_inode(s->s_root)->i_mutex, s);
 	dentry = lookup_one_len(PRIVROOT_NAME, s->s_root,
 				strlen(PRIVROOT_NAME));
 	if (!IS_ERR(dentry)) {
 		REISERFS_SB(s)->priv_root = dentry;
 		d_set_d_op(dentry, &xattr_lookup_poison_ops);
-		if (dentry->d_inode)
-			dentry->d_inode->i_flags |= S_PRIVATE;
+		if (d_inode(dentry))
+			d_inode(dentry)->i_flags |= S_PRIVATE;
 	} else
 		err = PTR_ERR(dentry);
-	mutex_unlock(&s->s_root->d_inode->i_mutex);
+	mutex_unlock(&d_inode(s->s_root)->i_mutex);
 
 	return err;
 }
@@ -1014,15 +1014,15 @@ int reiserfs_xattr_init(struct super_blo
 	if (err)
 		goto error;
 
-	if (!privroot->d_inode && !(mount_flags & MS_RDONLY)) {
-		reiserfs_mutex_lock_safe(&s->s_root->d_inode->i_mutex, s);
+	if (!d_inode(privroot) && !(mount_flags & MS_RDONLY)) {
+		reiserfs_mutex_lock_safe(&d_inode(s->s_root)->i_mutex, s);
 		err = create_privroot(REISERFS_SB(s)->priv_root);
-		mutex_unlock(&s->s_root->d_inode->i_mutex);
+		mutex_unlock(&d_inode(s->s_root)->i_mutex);
 	}
 
-	if (privroot->d_inode) {
+	if (d_inode(privroot)) {
 		s->s_xattr = reiserfs_xattr_handlers;
-		reiserfs_mutex_lock_safe(&privroot->d_inode->i_mutex, s);
+		reiserfs_mutex_lock_safe(&d_inode(privroot)->i_mutex, s);
 		if (!REISERFS_SB(s)->xattr_root) {
 			struct dentry *dentry;
 			dentry = lookup_one_len(XAROOT_NAME, privroot,
@@ -1032,7 +1032,7 @@ int reiserfs_xattr_init(struct super_blo
 			else
 				err = PTR_ERR(dentry);
 		}
-		mutex_unlock(&privroot->d_inode->i_mutex);
+		mutex_unlock(&d_inode(privroot)->i_mutex);
 	}
 
 error:
diff -u -p a/reiserfs/xattr_security.c b/reiserfs/xattr_security.c
--- a/reiserfs/xattr_security.c
+++ b/reiserfs/xattr_security.c
@@ -15,10 +15,10 @@ security_get(struct dentry *dentry, cons
 	if (strlen(name) < sizeof(XATTR_SECURITY_PREFIX))
 		return -EINVAL;
 
-	if (IS_PRIVATE(dentry->d_inode))
+	if (IS_PRIVATE(d_inode(dentry)))
 		return -EPERM;
 
-	return reiserfs_xattr_get(dentry->d_inode, name, buffer, size);
+	return reiserfs_xattr_get(d_inode(dentry), name, buffer, size);
 }
 
 static int
@@ -28,10 +28,10 @@ security_set(struct dentry *dentry, cons
 	if (strlen(name) < sizeof(XATTR_SECURITY_PREFIX))
 		return -EINVAL;
 
-	if (IS_PRIVATE(dentry->d_inode))
+	if (IS_PRIVATE(d_inode(dentry)))
 		return -EPERM;
 
-	return reiserfs_xattr_set(dentry->d_inode, name, buffer, size, flags);
+	return reiserfs_xattr_set(d_inode(dentry), name, buffer, size, flags);
 }
 
 static size_t security_list(struct dentry *dentry, char *list, size_t list_len,
@@ -39,7 +39,7 @@ static size_t security_list(struct dentr
 {
 	const size_t len = namelen + 1;
 
-	if (IS_PRIVATE(dentry->d_inode))
+	if (IS_PRIVATE(d_inode(dentry)))
 		return 0;
 
 	if (list && len <= list_len) {
diff -u -p a/jfs/jfs_dtree.c b/jfs/jfs_dtree.c
--- a/jfs/jfs_dtree.c
+++ b/jfs/jfs_dtree.c
@@ -3004,7 +3004,7 @@ static inline struct jfs_dirent *next_jf
  */
 int jfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode *ip = filp->f_path.dentry->d_inode;
+	struct inode *ip = d_inode(filp->f_path.dentry);
 	struct nls_table *codepage = JFS_SBI(ip->i_sb)->nls_tab;
 	int rc = 0;
 	loff_t dtpos;	/* legacy OS/2 style position */
diff -u -p a/jfs/symlink.c b/jfs/symlink.c
--- a/jfs/symlink.c
+++ b/jfs/symlink.c
@@ -24,7 +24,7 @@
 
 static void *jfs_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	char *s = JFS_IP(dentry->d_inode)->i_inline;
+	char *s = JFS_IP(d_inode(dentry))->i_inline;
 	nd_set_link(nd, s);
 	return NULL;
 }
diff -u -p a/jfs/file.c b/jfs/file.c
--- a/jfs/file.c
+++ b/jfs/file.c
@@ -92,7 +92,7 @@ static int jfs_release(struct inode *ino
 
 int jfs_setattr(struct dentry *dentry, struct iattr *iattr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	int rc;
 
 	rc = inode_change_ok(inode, iattr);
diff -u -p a/jfs/namei.c b/jfs/namei.c
--- a/jfs/namei.c
+++ b/jfs/namei.c
@@ -352,7 +352,7 @@ static int jfs_rmdir(struct inode *dip,
 {
 	int rc;
 	tid_t tid;		/* transaction id */
-	struct inode *ip = dentry->d_inode;
+	struct inode *ip = d_inode(dentry);
 	ino_t ino;
 	struct component_name dname;
 	struct inode *iplist[2];
@@ -478,7 +478,7 @@ static int jfs_unlink(struct inode *dip,
 {
 	int rc;
 	tid_t tid;		/* transaction id */
-	struct inode *ip = dentry->d_inode;
+	struct inode *ip = d_inode(dentry);
 	ino_t ino;
 	struct component_name dname;	/* object name */
 	struct inode *iplist[2];
@@ -797,7 +797,7 @@ static int jfs_link(struct dentry *old_d
 {
 	int rc;
 	tid_t tid;
-	struct inode *ip = old_dentry->d_inode;
+	struct inode *ip = d_inode(old_dentry);
 	ino_t ino;
 	struct component_name dname;
 	struct btstack btstack;
@@ -889,7 +889,7 @@ static int jfs_symlink(struct inode *dip
 	struct component_name dname;
 	int ssize;		/* source pathname size */
 	struct btstack btstack;
-	struct inode *ip = dentry->d_inode;
+	struct inode *ip = d_inode(dentry);
 	unchar *i_fastsymlink;
 	s64 xlen = 0;
 	int bmask = 0, xsize;
@@ -1098,8 +1098,8 @@ static int jfs_rename(struct inode *old_
 	dquot_initialize(old_dir);
 	dquot_initialize(new_dir);
 
-	old_ip = old_dentry->d_inode;
-	new_ip = new_dentry->d_inode;
+	old_ip = d_inode(old_dentry);
+	new_ip = d_inode(new_dentry);
 
 	if ((rc = get_UCSname(&old_dname, old_dentry)))
 		goto out1;
@@ -1527,9 +1527,9 @@ struct dentry *jfs_get_parent(struct den
 	unsigned long parent_ino;
 
 	parent_ino =
-		le32_to_cpu(JFS_IP(dentry->d_inode)->i_dtroot.header.idotdot);
+		le32_to_cpu(JFS_IP(d_inode(dentry))->i_dtroot.header.idotdot);
 
-	return d_obtain_alias(jfs_iget(dentry->d_inode->i_sb, parent_ino));
+	return d_obtain_alias(jfs_iget(d_inode(dentry)->i_sb, parent_ino));
 }
 
 const struct inode_operations jfs_dir_inode_operations = {
@@ -1609,7 +1609,7 @@ static int jfs_ci_revalidate(struct dent
 	 * positive dentry isn't good idea. So it's unsupported like
 	 * rename("filename", "FILENAME") for now.
 	 */
-	if (dentry->d_inode)
+	if (d_inode(dentry))
 		return 1;
 
 	/*
diff -u -p a/jfs/ioctl.c b/jfs/ioctl.c
--- a/jfs/ioctl.c
+++ b/jfs/ioctl.c
@@ -54,7 +54,7 @@ static long jfs_map_ext2(unsigned long f
 
 long jfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-	struct inode *inode = filp->f_dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_dentry);
 	struct jfs_inode_info *jfs_inode = JFS_IP(inode);
 	unsigned int flags;
 
diff -u -p a/jfs/xattr.c b/jfs/xattr.c
--- a/jfs/xattr.c
+++ b/jfs/xattr.c
@@ -907,7 +907,7 @@ int __jfs_setxattr(tid_t tid, struct ino
 int jfs_setxattr(struct dentry *dentry, const char *name, const void *value,
 		 size_t value_len, int flags)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct jfs_inode_info *ji = JFS_IP(inode);
 	int rc;
 	tid_t tid;
@@ -922,7 +922,7 @@ int jfs_setxattr(struct dentry *dentry,
 
 	tid = txBegin(inode->i_sb, 0);
 	mutex_lock(&ji->commit_mutex);
-	rc = __jfs_setxattr(tid, dentry->d_inode, name, value, value_len,
+	rc = __jfs_setxattr(tid, d_inode(dentry), name, value, value_len,
 			    flags);
 	if (!rc)
 		rc = txCommit(tid, 1, &inode, 0);
@@ -1001,7 +1001,7 @@ ssize_t jfs_getxattr(struct dentry *dent
 			return -EOPNOTSUPP;
 	}
 
-	err = __jfs_getxattr(dentry->d_inode, name, data, buf_size);
+	err = __jfs_getxattr(d_inode(dentry), name, data, buf_size);
 
 	return err;
 }
@@ -1018,7 +1018,7 @@ static inline int can_list(struct jfs_ea
 
 ssize_t jfs_listxattr(struct dentry * dentry, char *data, size_t buf_size)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	char *buffer;
 	ssize_t size = 0;
 	int xattr_size;
@@ -1071,7 +1071,7 @@ ssize_t jfs_listxattr(struct dentry * de
 
 int jfs_removexattr(struct dentry *dentry, const char *name)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	struct jfs_inode_info *ji = JFS_IP(inode);
 	int rc;
 	tid_t tid;
@@ -1081,7 +1081,8 @@ int jfs_removexattr(struct dentry *dentr
 
 	tid = txBegin(inode->i_sb, 0);
 	mutex_lock(&ji->commit_mutex);
-	rc = __jfs_setxattr(tid, dentry->d_inode, name, NULL, 0, XATTR_REPLACE);
+	rc = __jfs_setxattr(tid, d_inode(dentry), name, NULL, 0,
+			    XATTR_REPLACE);
 	if (!rc)
 		rc = txCommit(tid, 1, &inode, 0);
 	txEnd(tid);
diff -u -p a/utimes.c b/utimes.c
--- a/utimes.c
+++ b/utimes.c
@@ -52,7 +52,7 @@ static int utimes_common(struct path *pa
 {
 	int error;
 	struct iattr newattrs;
-	struct inode *inode = path->dentry->d_inode;
+	struct inode *inode = d_inode(path->dentry);
 
 	error = mnt_want_write(path->mnt);
 	if (error)
diff -u -p a/ufs/super.c b/ufs/super.c
--- a/ufs/super.c
+++ b/ufs/super.c
@@ -153,10 +153,10 @@ static struct dentry *ufs_get_parent(str
 	};
 	ino_t ino;
 
-	ino = ufs_inode_by_name(child->d_inode, &dot_dot);
+	ino = ufs_inode_by_name(d_inode(child), &dot_dot);
 	if (!ino)
 		return ERR_PTR(-ENOENT);
-	return d_obtain_alias(ufs_iget(child->d_inode->i_sb, ino));
+	return d_obtain_alias(ufs_iget(d_inode(child)->i_sb, ino));
 }
 
 static const struct export_operations ufs_export_ops = {
diff -u -p a/ufs/symlink.c b/ufs/symlink.c
--- a/ufs/symlink.c
+++ b/ufs/symlink.c
@@ -34,7 +34,7 @@
 
 static void *ufs_follow_link(struct dentry *dentry, struct nameidata *nd)
 {
-	struct ufs_inode_info *p = UFS_I(dentry->d_inode);
+	struct ufs_inode_info *p = UFS_I(d_inode(dentry));
 	nd_set_link(nd, (char*)p->i_u1.i_symlink);
 	return NULL;
 }
diff -u -p a/ufs/truncate.c b/ufs/truncate.c
--- a/ufs/truncate.c
+++ b/ufs/truncate.c
@@ -492,7 +492,7 @@ out:
 
 int ufs_setattr(struct dentry *dentry, struct iattr *attr)
 {
-	struct inode *inode = dentry->d_inode;
+	struct inode *inode = d_inode(dentry);
 	unsigned int ia_valid = attr->ia_valid;
 	int error;
 
diff -u -p a/ufs/namei.c b/ufs/namei.c
--- a/ufs/namei.c
+++ b/ufs/namei.c
@@ -164,7 +164,7 @@ out_fail:
 static int ufs_link (struct dentry * old_dentry, struct inode * dir,
 	struct dentry *dentry)
 {
-	struct inode *inode = old_dentry->d_inode;
+	struct inode *inode = d_inode(old_dentry);
 	int error;
 
 	lock_ufs(dir->i_sb);
@@ -229,7 +229,7 @@ out_dir:
 
 static int ufs_unlink(struct inode *dir, struct dentry *dentry)
 {
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	struct ufs_dir_entry *de;
 	struct page *page;
 	int err = -ENOENT;
@@ -251,7 +251,7 @@ out:
 
 static int ufs_rmdir (struct inode * dir, struct dentry *dentry)
 {
-	struct inode * inode = dentry->d_inode;
+	struct inode * inode = d_inode(dentry);
 	int err= -ENOTEMPTY;
 
 	lock_ufs(dir->i_sb);
@@ -270,8 +270,8 @@ static int ufs_rmdir (struct inode * dir
 static int ufs_rename(struct inode *old_dir, struct dentry *old_dentry,
 		      struct inode *new_dir, struct dentry *new_dentry)
 {
-	struct inode *old_inode = old_dentry->d_inode;
-	struct inode *new_inode = new_dentry->d_inode;
+	struct inode *old_inode = d_inode(old_dentry);
+	struct inode *new_inode = d_inode(new_dentry);
 	struct page *dir_page = NULL;
 	struct ufs_dir_entry * dir_de = NULL;
 	struct page *old_page;
diff -u -p a/ufs/dir.c b/ufs/dir.c
--- a/ufs/dir.c
+++ b/ufs/dir.c
@@ -311,7 +311,7 @@ found:
  */
 int ufs_add_link(struct dentry *dentry, struct inode *inode)
 {
-	struct inode *dir = dentry->d_parent->d_inode;
+	struct inode *dir = d_inode(dentry->d_parent);
 	const unsigned char *name = dentry->d_name.name;
 	int namelen = dentry->d_name.len;
 	struct super_block *sb = dir->i_sb;
@@ -433,7 +433,7 @@ static int
 ufs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
 	loff_t pos = filp->f_pos;
-	struct inode *inode = filp->f_path.dentry->d_inode;
+	struct inode *inode = d_inode(filp->f_path.dentry);
 	struct super_block *sb = inode->i_sb;
 	unsigned int offset = pos & ~PAGE_CACHE_MASK;
 	unsigned long n = pos >> PAGE_CACHE_SHIFT;
