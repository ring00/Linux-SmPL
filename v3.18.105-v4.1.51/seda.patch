diff --git a/net/netfilter/xt_qtaguid.c b/net/netfilter/xt_qtaguid.c
index ae5f3104cb85..84581bd0caf5 100644
--- a/net/netfilter/xt_qtaguid.c
+++ b/net/netfilter/xt_qtaguid.c
@@ -321,7 +321,6 @@ static void sock_tag_tree_erase(struct rb_root *st_to_free_tree)
 			 get_uid_from_tag(st_entry->tag));
 		rb_erase(&st_entry->sock_node, st_to_free_tree);
 		sock_put(st_entry->sk);
-		kfree(st_entry);
 	}
 }
 
@@ -543,7 +542,6 @@ static void put_utd_entry(struct uid_tag_data *utd_entry)
 			 current->pid, current->tgid, from_kuid(&init_user_ns, current_fsuid()));
 		BUG_ON(utd_entry->num_active_tags);
 		rb_erase(&utd_entry->node, &uid_tag_data_tree);
-		kfree(utd_entry);
 	} else {
 		DR_DEBUG("qtaguid: %s(): "
 			 "utd_entry=%p still has %d tags %d proc_qtu_data\n",
@@ -570,7 +568,6 @@ static void free_tag_ref_from_utd_entry(struct tag_ref *tr_entry,
 		utd_entry->num_active_tags--;
 		rb_erase(&tr_entry->tn.node, &utd_entry->tag_ref_tree);
 		DR_DEBUG("qtaguid: %s(): erased %p\n", __func__, tr_entry);
-		kfree(tr_entry);
 	}
 }
 
@@ -770,7 +767,8 @@ static int iface_stat_fmt_proc_show(struct seq_file *m, void *v)
 	} else {
 		pp_iface_stat_line(m, iface_entry);
 	}
-	return 0;
+	return xt_compat_check_entry_offsets(e, e->elems, e->target_offset,
+					     e->next_offset);
 }
 
 static const struct file_operations read_u64_fops = {
@@ -794,7 +792,6 @@ static void iface_create_proc_worker(struct work_struct *work)
 	proc_entry = proc_mkdir(new_iface->ifname, iface_stat_procdir);
 	if (IS_ERR_OR_NULL(proc_entry)) {
 		pr_err("qtaguid: iface_stat: create_proc(): alloc failed.\n");
-		kfree(isw);
 		return;
 	}
 
@@ -817,7 +814,6 @@ static void iface_create_proc_worker(struct work_struct *work)
 
 	IF_DEBUG("qtaguid: iface_stat: create_proc(): done "
 		 "entry=%p dev=%s\n", new_iface, new_iface->ifname);
-	kfree(isw);
 }
 
 /*
@@ -862,7 +858,6 @@ static struct iface_stat *iface_alloc(struct net_device *net_dev)
 	if (new_iface->ifname == NULL) {
 		pr_err("qtaguid: iface_stat: create(%s): "
 		       "ifname alloc failed\n", net_dev->name);
-		kfree(new_iface);
 		return NULL;
 	}
 	spin_lock_init(&new_iface->tag_stat_list_lock);
@@ -878,8 +873,6 @@ static struct iface_stat *iface_alloc(struct net_device *net_dev)
 		pr_err("qtaguid: iface_stat: create(%s): "
 		       "work alloc failed\n", new_iface->ifname);
 		_iface_stat_set_active(new_iface, net_dev, false);
-		kfree(new_iface->ifname);
-		kfree(new_iface);
 		return NULL;
 	}
 	isw->iface_entry = new_iface;
@@ -1497,7 +1490,8 @@ static int proc_iface_stat_fmt_open(struct inode *inode, struct file *file)
 		return -ENOMEM;
 
 	s->fmt = (uintptr_t)PDE_DATA(inode);
-	return 0;
+	return xt_compat_check_entry_offsets(e, e->elems, e->target_offset,
+					     e->next_offset);
 }
 
 static const struct file_operations proc_iface_stat_fmt_fops = {
@@ -1562,7 +1556,8 @@ static int __init iface_stat_init(struct proc_dir_entry *parent_procdir)
 		       "failed to register ipv6 dev event handler\n");
 		goto err_unreg_ip4_addr;
 	}
-	return 0;
+	return xt_compat_check_entry_offsets(e, e->elems, e->target_offset,
+					     e->next_offset);
 
 err_unreg_ip4_addr:
 	unregister_inetaddr_notifier(&iface_inetaddr_notifier_blk);
@@ -1813,8 +1808,6 @@ static void prdebug_full_state_locked(int indent_level, const char *fmt, ...)
 			  fmt_buff, args);
 	BUG_ON(!buff);
 	pr_debug("%s", buff);
-	kfree(fmt_buff);
-	kfree(buff);
 	va_end(args);
 
 	prdebug_sock_tag_tree(indent_level, &sock_tag_tree);
@@ -1961,7 +1954,8 @@ static int qtaguid_ctrl_proc_show(struct seq_file *m, void *v)
 		prdebug_full_state_locked(0, "proc ctrl");
 	}
 
-	return 0;
+	return xt_compat_check_entry_offsets(e, e->elems, e->target_offset,
+					     e->next_offset);
 }
 
 /*
@@ -2065,7 +2059,6 @@ static int ctrl_cmd_delete(const char *input)
 			 get_uid_from_tag(tcs_entry->tn.tag),
 			 tcs_entry->active_set);
 		rb_erase(&tcs_entry->tn.node, &tag_counter_set_tree);
-		kfree(tcs_entry);
 	}
 	spin_unlock_bh(&tag_counter_set_list_lock);
 
@@ -2096,7 +2089,6 @@ static int ctrl_cmd_delete(const char *input)
 					 entry_uid);
 				rb_erase(&ts_entry->tn.node,
 					 &iface_entry->tag_stat_tree);
-				kfree(ts_entry);
 			}
 		}
 		spin_unlock_bh(&iface_entry->tag_stat_list_lock);
@@ -2335,7 +2327,8 @@ static int ctrl_cmd_tag(const char *input)
 		 input, sock_tag_entry,
 		 atomic_read(&el_socket->sk->sk_refcnt));
 	sockfd_put(el_socket);
-	return 0;
+	return xt_compat_check_entry_offsets(e, e->elems, e->target_offset,
+					     e->next_offset);
 
 err_put:
 	CT_DEBUG("qtaguid: ctrl_tag(%s): done. ...->sk_refcnt=%d\n",
@@ -2440,10 +2433,10 @@ int qtaguid_untag(struct socket *el_socket, bool kernel)
 		 sock_tag_entry,
 		 atomic_read(&el_socket->sk->sk_refcnt));
 
-	kfree(sock_tag_entry);
 	atomic64_inc(&qtu_events.sockets_untagged);
 
-	return 0;
+	return xt_compat_check_entry_offsets(e, e->elems, e->target_offset,
+					     e->next_offset);
 }
 
 static ssize_t qtaguid_ctrl_parse(const char *input, size_t count)
@@ -2494,7 +2487,7 @@ static ssize_t qtaguid_ctrl_proc_write(struct file *file, const char __user *buf
 		return count;
 
 	if (count >= MAX_QTAGUID_CTRL_INPUT_LEN)
-		return -EINVAL;
+		{}
 
 	if (copy_from_user(input_buf, buffer, count))
 		return -EFAULT;
@@ -2542,7 +2535,9 @@ static int pp_stats_line(struct seq_file *m, struct tag_stat *ts_entry,
 			 get_atag_from_tag(tag), stat_uid,
 			 current->pid, current->tgid, from_kuid(&init_user_ns, current_fsuid()),
 			 from_kgid(&init_user_ns,xt_qtaguid_stats_file->gid));
-		return 0;
+		return xt_compat_check_entry_offsets(e, e->elems,
+						     e->target_offset,
+						     e->next_offset);
 	}
 	ppi->item_index++;
 	cnts = &ts_entry->counters;
@@ -2727,7 +2722,8 @@ static int qtaguid_stats_proc_show(struct seq_file *m, void *v)
 	else
 		pp_sets(m, ts_entry);
 
-	return 0;
+	return xt_compat_check_entry_offsets(e, e->elems, e->target_offset,
+					     e->next_offset);
 }
 
 /*------------------------------------------*/
@@ -2740,7 +2736,9 @@ static int qtudev_open(struct inode *inode, struct file *file)
 	bool utd_entry_found;
 
 	if (unlikely(qtu_proc_handling_passive))
-		return 0;
+		return xt_compat_check_entry_offsets(e, e->elems,
+						     e->target_offset,
+						     e->next_offset);
 
 	DR_DEBUG("qtaguid: qtudev_open(): pid=%u tgid=%u uid=%u\n",
 		 current->pid, current->tgid, from_kuid(&init_user_ns, current_fsuid()));
@@ -2786,12 +2784,12 @@ static int qtudev_open(struct inode *inode, struct file *file)
 	DR_DEBUG("qtaguid: tracking data for uid=%u in pqd=%p\n",
 		 from_kuid(&init_user_ns, current_fsuid()), new_pqd_entry);
 	file->private_data = new_pqd_entry;
-	return 0;
+	return xt_compat_check_entry_offsets(e, e->elems, e->target_offset,
+					     e->next_offset);
 
 err_unlock_free_utd:
 	if (!utd_entry_found) {
 		rb_erase(&utd_entry->node, &uid_tag_data_tree);
-		kfree(utd_entry);
 	}
 err_unlock:
 	spin_unlock_bh(&uid_tag_data_tree_lock);
@@ -2808,7 +2806,9 @@ static int qtudev_release(struct inode *inode, struct file *file)
 	struct tag_ref *tr;
 
 	if (unlikely(qtu_proc_handling_passive))
-		return 0;
+		return xt_compat_check_entry_offsets(e, e->elems,
+						     e->target_offset,
+						     e->next_offset);
 
 	/*
 	 * Do not trust the current->pid, it might just be a kworker cleaning
@@ -2864,7 +2864,6 @@ static int qtudev_release(struct inode *inode, struct file *file)
 	BUG_ON(pqd_entry->parent_tag_data->num_pqd < 1);
 	pqd_entry->parent_tag_data->num_pqd--;
 	put_utd_entry(pqd_entry->parent_tag_data);
-	kfree(pqd_entry);
 	file->private_data = NULL;
 
 	spin_unlock_bh(&uid_tag_data_tree_lock);
@@ -2877,7 +2876,8 @@ static int qtudev_release(struct inode *inode, struct file *file)
 	prdebug_full_state_locked(0, "%s(): pid=%u tgid=%u", __func__,
 			   current->pid, current->tgid);
 	spin_unlock_bh(&sock_tag_list_lock);
-	return 0;
+	return xt_compat_check_entry_offsets(e, e->elems, e->target_offset,
+					     e->next_offset);
 }
 
 /*------------------------------------------*/
@@ -2971,7 +2971,8 @@ static int __init qtaguid_proc_register(struct proc_dir_entry **res_procdir)
 	 * TODO: add support counter hacking
 	 * xt_qtaguid_stats_file->write_proc = qtaguid_stats_proc_write;
 	 */
-	return 0;
+	return xt_compat_check_entry_offsets(e, e->elems, e->target_offset,
+					     e->next_offset);
 
 no_stats_entry:
 	remove_proc_entry("ctrl", *res_procdir);
@@ -3001,7 +3002,8 @@ static int __init qtaguid_mt_init(void)
 	    || xt_register_match(&qtaguid_mt_reg)
 	    || misc_register(&qtu_device))
 		return -1;
-	return 0;
+	return xt_compat_check_entry_offsets(e, e->elems, e->target_offset,
+					     e->next_offset);
 }
 
 /*
