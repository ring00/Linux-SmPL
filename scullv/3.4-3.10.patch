diff --git a/scullv/Makefile b/scullv/Makefile
index dd71bb02bf34..63770e83b70a 100644
--- a/scullv/Makefile
+++ b/scullv/Makefile
@@ -35,7 +35,7 @@ install:
 	install -c $(TARGET).o $(INSTALLDIR)
 
 clean:
-	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions
+	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions Module.symvers modules.order
 
 
 depend .depend dep:
diff --git a/scullv/main.c b/scullv/main.c
index 217c34c57860..22e754b04dcb 100644
--- a/scullv/main.c
+++ b/scullv/main.c
@@ -26,6 +26,7 @@
 #include <linux/proc_fs.h>
 #include <linux/fcntl.h>	/* O_ACCMODE */
 #include <linux/aio.h>
+#include <linux/seq_file.h>
 #include <asm/uaccess.h>
 #include <linux/vmalloc.h>
 #include "scullv.h"		/* local definitions */
@@ -58,61 +59,54 @@ void scullv_cleanup(void);
  * The proc filesystem: function to read and entry
  */
 
-void scullv_proc_offset(char *buf, char **start, off_t *offset, int *len)
+static int scullv_read_mem_proc_show(struct seq_file *m, void *v)
 {
-	if (*offset == 0)
-		return;
-	if (*offset >= *len) {
-		/* Not there yet */
-		*offset -= *len;
-		*len = 0;
-	} else {
-		/* We're into the interesting stuff now */
-		*start = buf + *offset;
-		*offset = 0;
-	}
-}
-
-/* FIXME: Do we need this here??  It be ugly  */
-int scullv_read_procmem(char *buf, char **start, off_t offset,
-                   int count, int *eof, void *data)
-{
-	int i, j, order, qset, len = 0;
-	int limit = count - 80; /* Don't print more than this */
+	int i, j, order, qset;
+	int limit = m->size - 80; /* Don't print more than this */
 	struct scullv_dev *d;
 
-	*start = buf;
 	for(i = 0; i < scullv_devs; i++) {
 		d = &scullv_devices[i];
 		if (mutex_lock_interruptible(&d->mutex))
 			return -ERESTARTSYS;
 		qset = d->qset;  /* retrieve the features of each device */
 		order = d->order;
-		len += sprintf(buf+len,"\nDevice %i: qset %i, order %i, sz %li\n",
+		seq_printf(m, "\nDevice %i: qset %i, order %i, sz %li\n",
 				i, qset, order, (long)(d->size));
 		for (; d; d = d->next) { /* scan the list */
-			len += sprintf(buf+len,"  item at %p, qset at %p\n",d,d->data);
-			scullv_proc_offset (buf, start, &offset, &len);
-			if (len > limit)
+			seq_printf(m, "  item at %p, qset at %p\n",d,d->data);
+			if (m->count > limit)
 				goto out;
 			if (d->data && !d->next) /* dump only the last item - save space */
 				for (j = 0; j < qset; j++) {
 					if (d->data[j])
-						len += sprintf(buf+len,"    % 4i:%8p\n",j,d->data[j]);
-					scullv_proc_offset (buf, start, &offset, &len);
-					if (len > limit)
+						seq_printf(m, "    % 4i:%8p\n",j,d->data[j]);
+					if (m->count > limit)
 						goto out;
 				}
 		}
 	  out:
 		mutex_unlock(&scullv_devices[i].mutex);
-		if (len > limit)
+		if (m->count > limit)
 			break;
 	}
-	*eof = 1;
-	return len;
+	return 0;
 }
 
+#define DEFINE_PROC_SEQ_FILE(_name) \
+	static int _name##_proc_open(struct inode *inode, struct file *file)\
+	{\
+		return single_open(file, _name##_proc_show, NULL);\
+	}\
+	\
+	static const struct file_operations _name##_proc_fops = {\
+		.open		= _name##_proc_open,\
+		.read		= seq_read,\
+		.llseek		= seq_lseek,\
+		.release	= single_release,\
+	};
+
+DEFINE_PROC_SEQ_FILE(scullv_read_mem)
 #endif /* SCULLV_USE_PROC */
 
 /*
@@ -631,7 +625,7 @@ int scullv_init(void)
 
 
 #ifdef SCULLV_USE_PROC /* only when available */
-	create_proc_read_entry("scullvmem", 0, NULL, scullv_read_procmem, NULL);
+	proc_create("scullvmem", 0, NULL, &scullv_read_mem_proc_fops);
 #endif
 	return 0; /* succeed */
 
diff --git a/scullv/mmap.c b/scullv/mmap.c
index 0d921b5b9f09..0bd2676436b7 100644
--- a/scullv/mmap.c
+++ b/scullv/mmap.c
@@ -113,7 +113,7 @@ int scullv_mmap(struct file *filp, struct vm_area_struct *vma)
 
 	/* don't do anything here: "nopage" will set up page table entries */
 	vma->vm_ops = &scullv_vm_ops;
-	vma->vm_flags |= VM_RESERVED;
+	vma->vm_flags |= (VM_DONTEXPAND | VM_DONTDUMP);
 	vma->vm_private_data = filp->private_data;
 	scullv_vma_open(vma);
 	return 0;
