diff --git a/misc-modules/Makefile b/misc-modules/Makefile
index d04d2d6fb090..644ce9d0c4b9 100644
--- a/misc-modules/Makefile
+++ b/misc-modules/Makefile
@@ -19,7 +19,7 @@ modules_install:
 	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install
 
 clean:
-	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions
+	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions Module.symvers modules.order
 
 .PHONY: modules modules_install clean
 
diff --git a/misc-modules/jiq.c b/misc-modules/jiq.c
index 031e22e56779..63e24d6cb39d 100644
--- a/misc-modules/jiq.c
+++ b/misc-modules/jiq.c
@@ -27,6 +27,7 @@
 #include <linux/workqueue.h>
 #include <linux/preempt.h>
 #include <linux/interrupt.h> /* tasklets */
+#include <linux/seq_file.h>
 
 MODULE_LICENSE("Dual BSD/GPL");
 
@@ -59,8 +60,7 @@ static DECLARE_WAIT_QUEUE_HEAD (jiq_wait);
  * Keep track of info we need between task queue runs.
  */
 static struct clientdata {
-	int len;
-	char *buf;
+	struct seq_file *m;
 	unsigned long jiffies;
 	long delay;
 	struct delayed_work jiq_work;
@@ -81,32 +81,40 @@ static DECLARE_TASKLET(jiq_tasklet, jiq_print_tasklet, (unsigned long)&jiq_data)
 static int jiq_print(void *ptr)
 {
 	struct clientdata *data = ptr;
-	int len = data->len;
-	char *buf = data->buf;
+	struct seq_file *m = data->m;
 	unsigned long j = jiffies;
 
-	if (len > LIMIT) { 
+	if (m->count > LIMIT) {
 		wake_up_interruptible(&jiq_wait);
 		return 0;
 	}
 
-	if (len == 0)
-		len = sprintf(buf,"    time  delta preempt   pid cpu command\n");
-	else
-		len =0;
+	if (m->count == 0)
+		seq_puts(m,"    time  delta preempt   pid cpu command\n");
 
   	/* intr_count is only exported since 1.3.5, but 1.99.4 is needed anyways */
-	len += sprintf(buf+len, "%9li  %4li     %3i %5i %3i %s\n",
+	seq_printf(m, "%9li  %4li     %3i %5i %3i %s\n",
 			j, j - data->jiffies,
 			preempt_count(), current->pid, smp_processor_id(),
 			current->comm);
 
-	data->len += len;
-	data->buf += len;
 	data->jiffies = j;
 	return 1;
 }
 
+#define DEFINE_PROC_SEQ_FILE(_name) \
+	static int _name##_proc_open(struct inode *inode, struct file *file)\
+	{\
+		return single_open(file, _name##_proc_show, NULL);\
+	}\
+	\
+	static const struct file_operations _name##_proc_fops = {\
+		.open		= _name##_proc_open,\
+		.read		= seq_read,\
+		.llseek		= seq_lseek,\
+		.release	= single_release,\
+	};
+
 
 /*
  * Call jiq_print from a work queue
@@ -134,14 +142,11 @@ static void jiq_print_work(struct work_struct *work)
 	schedule_work(&jiq_data.work);
 }
 
-
-static int jiq_read_wq(char *buf, char **start, off_t offset,
-                   int len, int *eof, void *data)
+static int jiq_read_wq_proc_show(struct seq_file *m, void *v)
 {
 	DEFINE_WAIT(wait);
 	
-	jiq_data.len = 0;                /* nothing printed, yet */
-	jiq_data.buf = buf;              /* print in this place */
+	jiq_data.m = m;              /* print in this place */
 	jiq_data.jiffies = jiffies;      /* initial time */
 	jiq_data.delay = 0;
     
@@ -150,18 +155,16 @@ static int jiq_read_wq(char *buf, char **start, off_t offset,
 	schedule();
 	finish_wait(&jiq_wait, &wait);
 
-	*eof = 1;
-	return jiq_data.len;
+	return 0;
 }
 
+DEFINE_PROC_SEQ_FILE(jiq_read_wq)
 
-static int jiq_read_wq_delayed(char *buf, char **start, off_t offset,
-                   int len, int *eof, void *data)
+static int jiq_read_wq_delayed_proc_show(struct seq_file *m, void *v)
 {
 	DEFINE_WAIT(wait);
 	
-	jiq_data.len = 0;                /* nothing printed, yet */
-	jiq_data.buf = buf;              /* print in this place */
+	jiq_data.m = m;              /* print in this place */
 	jiq_data.jiffies = jiffies;      /* initial time */
 	jiq_data.delay = delay;
     
@@ -170,40 +173,10 @@ static int jiq_read_wq_delayed(char *buf, char **start, off_t offset,
 	schedule();
 	finish_wait(&jiq_wait, &wait);
 
-	*eof = 1;
-	return jiq_data.len;
+	return 0;
 }
 
-
-
-
-/*
- * Call jiq_print from a tasklet
- */
-static void jiq_print_tasklet(unsigned long ptr)
-{
-	if (jiq_print ((void *) ptr))
-		tasklet_schedule (&jiq_tasklet);
-}
-
-
-
-static int jiq_read_tasklet(char *buf, char **start, off_t offset, int len,
-                int *eof, void *data)
-{
-	jiq_data.len = 0;                /* nothing printed, yet */
-	jiq_data.buf = buf;              /* print in this place */
-	jiq_data.jiffies = jiffies;      /* initial time */
-
-	tasklet_schedule(&jiq_tasklet);
-	interruptible_sleep_on(&jiq_wait);    /* sleep till completion */
-
-	*eof = 1;
-	return jiq_data.len;
-}
-
-
-
+DEFINE_PROC_SEQ_FILE(jiq_read_wq_delayed)
 
 /*
  * This one, instead, tests out the timers.
@@ -217,18 +190,15 @@ static void jiq_timedout(unsigned long ptr)
 	wake_up_interruptible(&jiq_wait);  /* awake the process */
 }
 
-
-static int jiq_read_run_timer(char *buf, char **start, off_t offset,
-                   int len, int *eof, void *data)
+static int jiq_read_run_timer_proc_show(struct seq_file *m, void *v)
 {
 
-	jiq_data.len = 0;           /* prepare the argument for jiq_print() */
-	jiq_data.buf = buf;
+	jiq_data.m = m;
 	jiq_data.jiffies = jiffies;
 
 	init_timer(&jiq_timer);              /* init the timer structure */
 	jiq_timer.function = jiq_timedout;
-	jiq_timer.data = (unsigned long)&jiq_data;
+	jiq_timer.data = (unsigned long)m;
 	jiq_timer.expires = jiffies + HZ; /* one second */
 
 	jiq_print(&jiq_data);   /* print and go to sleep */
@@ -236,10 +206,32 @@ static int jiq_read_run_timer(char *buf, char **start, off_t offset,
 	interruptible_sleep_on(&jiq_wait);  /* RACE */
 	del_timer_sync(&jiq_timer);  /* in case a signal woke us up */
     
-	*eof = 1;
-	return jiq_data.len;
+	return 0;
+}
+
+DEFINE_PROC_SEQ_FILE(jiq_read_run_timer)
+
+/*
+ * Call jiq_print from a tasklet
+ */
+static void jiq_print_tasklet(unsigned long ptr)
+{
+	if (jiq_print ((void *) ptr))
+		tasklet_schedule (&jiq_tasklet);
+}
+
+static int jiq_read_tasklet_proc_show(struct seq_file *m, void *v)
+{
+	jiq_data.m = m;              /* print in this place */
+	jiq_data.jiffies = jiffies;      /* initial time */
+
+	tasklet_schedule(&jiq_tasklet);
+	interruptible_sleep_on(&jiq_wait);    /* sleep till completion */
+
+	return 0;
 }
 
+DEFINE_PROC_SEQ_FILE(jiq_read_tasklet)
 
 
 /*
@@ -253,10 +245,10 @@ static int jiq_init(void)
 	INIT_DELAYED_WORK(&jiq_data.jiq_work, jiq_print_wq);
 	INIT_WORK(&jiq_data.work, jiq_print_work);
 
-	create_proc_read_entry("jiqwq", 0, NULL, jiq_read_wq, NULL);
-	create_proc_read_entry("jiqwqdelay", 0, NULL, jiq_read_wq_delayed, NULL);
-	create_proc_read_entry("jitimer", 0, NULL, jiq_read_run_timer, NULL);
-	create_proc_read_entry("jiqtasklet", 0, NULL, jiq_read_tasklet, NULL);
+	proc_create("jiqwq", 0, NULL, &jiq_read_wq_proc_fops);
+	proc_create("jiqwqdelay", 0, NULL, &jiq_read_wq_delayed_proc_fops);
+	proc_create("jitimer", 0, NULL, &jiq_read_run_timer_proc_fops);
+	proc_create("jiqtasklet", 0, NULL, &jiq_read_tasklet_proc_fops);
 
 	return 0; /* succeed */
 }
diff --git a/misc-modules/jit.c b/misc-modules/jit.c
index 5f3507ef216d..a21570ef4815 100644
--- a/misc-modules/jit.c
+++ b/misc-modules/jit.c
@@ -27,6 +27,8 @@
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/sched.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
 
 #include <asm/hardirq.h>
 /*
@@ -49,12 +51,12 @@ enum jit_files {
 	JIT_SCHEDTO
 };
 
+
 /*
  * This function prints one line of data, after sleeping one second.
  * It can sleep in different ways, according to the data pointer
  */
-int jit_fn(char *buf, char **start, off_t offset,
-	      int len, int *eof, void *data)
+static int jit_fn_proc_show(struct seq_file *m, void *v)
 {
 	unsigned long j0, j1; /* jiffies */
 	wait_queue_head_t wait;
@@ -63,7 +65,7 @@ int jit_fn(char *buf, char **start, off_t offset,
 	j0 = jiffies;
 	j1 = j0 + delay;
 
-	switch((long)data) {
+	switch((long)m->private) {
 		case JIT_BUSY:
 			while (time_before(jiffies, j1))
 				cpu_relax();
@@ -83,16 +85,27 @@ int jit_fn(char *buf, char **start, off_t offset,
 	}
 	j1 = jiffies; /* actual value after we delayed */
 
-	len = sprintf(buf, "%9li %9li\n", j0, j1);
-	*start = buf;
-	return len;
+	seq_printf(m, "%9li %9li\n", j0, j1);
+	return 0;
 }
 
+static int jit_fn_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, jit_fn_proc_show, PDE_DATA(file_inode(file)));
+}
+
+static const struct file_operations jit_fn_proc_fops = {
+	.open		= jit_fn_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+
 /*
  * This file, on the other hand, returns the current time forever
  */
-int jit_currentime(char *buf, char **start, off_t offset,
-                   int len, int *eof, void *data)
+static int jit_currenttime_proc_show(struct seq_file *m, void *v)
 {
 	struct timeval tv1;
 	struct timespec tv2;
@@ -106,19 +119,25 @@ int jit_currentime(char *buf, char **start, off_t offset,
 	tv2 = current_kernel_time();
 
 	/* print */
-	len=0;
-	len += sprintf(buf,"0x%08lx 0x%016Lx %10i.%06i\n"
-		       "%40i.%09i\n",
-		       j1, j2,
-		       (int) tv1.tv_sec, (int) tv1.tv_usec,
-		       (int) tv2.tv_sec, (int) tv2.tv_nsec);
-	*start = buf;
-	return len;
+	seq_printf(m,"0x%08lx 0x%016Lx %10i.%06i\n"
+	       "%40i.%09i\n",
+	       j1, j2,
+	       (int) tv1.tv_sec, (int) tv1.tv_usec,
+	       (int) tv2.tv_sec, (int) tv2.tv_nsec);
+	return 0;
 }
 
-/*
- * The timer example follows
- */
+static int jit_currenttime_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, jit_currenttime_proc_show, NULL);
+}
+
+static const struct file_operations jit_currentime_proc_fops = {
+	.open		= jit_currenttime_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
 
 int tdelay = 10;
 module_param(tdelay, int, 0);
@@ -130,147 +149,164 @@ struct jit_data {
 	int hi; /* tasklet or tasklet_hi */
 	wait_queue_head_t wait;
 	unsigned long prevjiffies;
-	unsigned char *buf;
+    struct seq_file *m;
 	int loops;
 };
 #define JIT_ASYNC_LOOPS 5
 
-void jit_timer_fn(unsigned long arg)
+void jit_tasklet_fn(unsigned long arg)
 {
 	struct jit_data *data = (struct jit_data *)arg;
 	unsigned long j = jiffies;
-	data->buf += sprintf(data->buf, "%9li  %3li     %i    %6i   %i   %s\n",
+	seq_printf(data->m, "%9li  %3li     %i    %6i   %i   %s\n",
 			     j, j - data->prevjiffies, in_interrupt() ? 1 : 0,
 			     current->pid, smp_processor_id(), current->comm);
 
 	if (--data->loops) {
-		data->timer.expires += tdelay;
 		data->prevjiffies = j;
-		add_timer(&data->timer);
+		if (data->hi)
+			tasklet_hi_schedule(&data->tlet);
+		else
+			tasklet_schedule(&data->tlet);
 	} else {
 		wake_up_interruptible(&data->wait);
 	}
 }
 
 /* the /proc function: allocate everything to allow concurrency */
-int jit_timer(char *buf, char **start, off_t offset,
-	      int len, int *eof, void *unused_data)
+static int jit_tasklet_proc_show(struct seq_file *m, void *v)
 {
 	struct jit_data *data;
-	char *buf2 = buf;
 	unsigned long j = jiffies;
+	long hi = (long)m->private;
 
 	data = kmalloc(sizeof(*data), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
 
-	init_timer(&data->timer);
 	init_waitqueue_head (&data->wait);
 
 	/* write the first lines in the buffer */
-	buf2 += sprintf(buf2, "   time   delta  inirq    pid   cpu command\n");
-	buf2 += sprintf(buf2, "%9li  %3li     %i    %6i   %i   %s\n",
+	seq_puts(m, "   time   delta  inirq    pid   cpu command\n");
+	seq_printf(m, "%9li  %3li     %i    %6i   %i   %s\n",
 			j, 0L, in_interrupt() ? 1 : 0,
 			current->pid, smp_processor_id(), current->comm);
 
-	/* fill the data for our timer function */
+	/* fill the data for our tasklet function */
 	data->prevjiffies = j;
-	data->buf = buf2;
+	data->m = m;
 	data->loops = JIT_ASYNC_LOOPS;
 	
-	/* register the timer */
-	data->timer.data = (unsigned long)data;
-	data->timer.function = jit_timer_fn;
-	data->timer.expires = j + tdelay; /* parameter */
-	add_timer(&data->timer);
+	/* register the tasklet */
+	tasklet_init(&data->tlet, jit_tasklet_fn, (unsigned long)data);
+	data->hi = hi;
+	if (hi)
+		tasklet_hi_schedule(&data->tlet);
+	else
+		tasklet_schedule(&data->tlet);
 
 	/* wait for the buffer to fill */
 	wait_event_interruptible(data->wait, !data->loops);
+
 	if (signal_pending(current))
 		return -ERESTARTSYS;
-	buf2 = data->buf;
 	kfree(data);
-	*eof = 1;
-	return buf2 - buf;
+    return 0;
 }
 
-void jit_tasklet_fn(unsigned long arg)
+static int jit_tasklet_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, jit_tasklet_proc_show, PDE_DATA(file_inode(file)));
+}
+
+static const struct file_operations jit_tasklet_proc_fops = {
+	.open		= jit_tasklet_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/*
+ * The timer example follows
+ */
+void jit_timer_fn(unsigned long arg)
 {
 	struct jit_data *data = (struct jit_data *)arg;
 	unsigned long j = jiffies;
-	data->buf += sprintf(data->buf, "%9li  %3li     %i    %6i   %i   %s\n",
+	seq_printf(data->m, "%9li  %3li     %i    %6i   %i   %s\n",
 			     j, j - data->prevjiffies, in_interrupt() ? 1 : 0,
 			     current->pid, smp_processor_id(), current->comm);
 
 	if (--data->loops) {
+		data->timer.expires += tdelay;
 		data->prevjiffies = j;
-		if (data->hi)
-			tasklet_hi_schedule(&data->tlet);
-		else
-			tasklet_schedule(&data->tlet);
+		add_timer(&data->timer);
 	} else {
 		wake_up_interruptible(&data->wait);
 	}
 }
 
 /* the /proc function: allocate everything to allow concurrency */
-int jit_tasklet(char *buf, char **start, off_t offset,
-	      int len, int *eof, void *arg)
+static int jit_timer_proc_show(struct seq_file *m, void *v)
 {
 	struct jit_data *data;
-	char *buf2 = buf;
 	unsigned long j = jiffies;
-	long hi = (long)arg;
 
 	data = kmalloc(sizeof(*data), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
 
+	init_timer(&data->timer);
 	init_waitqueue_head (&data->wait);
 
 	/* write the first lines in the buffer */
-	buf2 += sprintf(buf2, "   time   delta  inirq    pid   cpu command\n");
-	buf2 += sprintf(buf2, "%9li  %3li     %i    %6i   %i   %s\n",
-			j, 0L, in_interrupt() ? 1 : 0,
-			current->pid, smp_processor_id(), current->comm);
+	seq_puts(m, "   time   delta  inirq    pid   cpu command\n");
+	seq_printf(m, "%9li  %3li     %i    %6i   %i   %s\n",
+		j, 0L, in_interrupt() ? 1 : 0,
+		current->pid, smp_processor_id(), current->comm);
 
-	/* fill the data for our tasklet function */
+	/* fill the data for our timer function */
 	data->prevjiffies = j;
-	data->buf = buf2;
+	data->m = m;
 	data->loops = JIT_ASYNC_LOOPS;
 	
-	/* register the tasklet */
-	tasklet_init(&data->tlet, jit_tasklet_fn, (unsigned long)data);
-	data->hi = hi;
-	if (hi)
-		tasklet_hi_schedule(&data->tlet);
-	else
-		tasklet_schedule(&data->tlet);
+	/* register the timer */
+	data->timer.data = (unsigned long)data;
+	data->timer.function = jit_timer_fn;
+	data->timer.expires = j + tdelay; /* parameter */
+	add_timer(&data->timer);
 
 	/* wait for the buffer to fill */
 	wait_event_interruptible(data->wait, !data->loops);
-
 	if (signal_pending(current))
 		return -ERESTARTSYS;
-	buf2 = data->buf;
 	kfree(data);
-	*eof = 1;
-	return buf2 - buf;
+    return 0;
 }
 
+static int jit_timer_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, jit_timer_proc_show, NULL);
+}
 
+static const struct file_operations jit_timer_proc_fops = {
+	.open		= jit_timer_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
 
 int __init jit_init(void)
 {
-	create_proc_read_entry("currentime", 0, NULL, jit_currentime, NULL);
-	create_proc_read_entry("jitbusy", 0, NULL, jit_fn, (void *)JIT_BUSY);
-	create_proc_read_entry("jitsched",0, NULL, jit_fn, (void *)JIT_SCHED);
-	create_proc_read_entry("jitqueue",0, NULL, jit_fn, (void *)JIT_QUEUE);
-	create_proc_read_entry("jitschedto", 0, NULL, jit_fn, (void *)JIT_SCHEDTO);
-
-	create_proc_read_entry("jitimer", 0, NULL, jit_timer, NULL);
-	create_proc_read_entry("jitasklet", 0, NULL, jit_tasklet, NULL);
-	create_proc_read_entry("jitasklethi", 0, NULL, jit_tasklet, (void *)1);
+	proc_create("currentime", 0, NULL, &jit_currentime_proc_fops);
+	proc_create_data("jitbusy", 0, NULL, &jit_fn_proc_fops, (void *)JIT_BUSY);
+	proc_create_data("jitsched",0, NULL, &jit_fn_proc_fops, (void *)JIT_SCHED);
+	proc_create_data("jitqueue",0, NULL, &jit_fn_proc_fops, (void *)JIT_QUEUE);
+	proc_create_data("jitschedto", 0, NULL, &jit_fn_proc_fops, (void *)JIT_SCHEDTO);
+
+	proc_create("jitimer", 0, NULL, &jit_timer_proc_fops);
+	proc_create("jitasklet", 0, NULL, &jit_tasklet_proc_fops);
+	proc_create_data("jitasklethi", 0, NULL, &jit_tasklet_proc_fops, (void *)1);
 
 	return 0; /* success */
 }
diff --git a/misc-modules/seq.c b/misc-modules/seq.c
index 59026a5878e3..1dc1cfd1b4b8 100644
--- a/misc-modules/seq.c
+++ b/misc-modules/seq.c
@@ -94,9 +94,9 @@ static int ct_init(void)
 {
 	struct proc_dir_entry *entry;
 
-	entry = create_proc_entry("sequence", 0, NULL);
-	if (entry)
-		entry->proc_fops = &ct_file_ops;
+	entry = proc_create("sequence", 0, NULL, &ct_file_ops);
+	if (!entry)
+		return -ENOMEM;
 	return 0;
 }
 
